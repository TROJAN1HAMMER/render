
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model SalesManager
 * 
 */
export type SalesManager = $Result.DefaultSelection<Prisma.$SalesManagerPayload>
/**
 * Model Plumber
 * 
 */
export type Plumber = $Result.DefaultSelection<Prisma.$PlumberPayload>
/**
 * Model PlumberAccountProfile
 * 
 */
export type PlumberAccountProfile = $Result.DefaultSelection<Prisma.$PlumberAccountProfilePayload>
/**
 * Model Accountant
 * 
 */
export type Accountant = $Result.DefaultSelection<Prisma.$AccountantPayload>
/**
 * Model Distributor
 * 
 */
export type Distributor = $Result.DefaultSelection<Prisma.$DistributorPayload>
/**
 * Model FieldExecutive
 * 
 */
export type FieldExecutive = $Result.DefaultSelection<Prisma.$FieldExecutivePayload>
/**
 * Model Worker
 * 
 */
export type Worker = $Result.DefaultSelection<Prisma.$WorkerPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Stock
 * 
 */
export type Stock = $Result.DefaultSelection<Prisma.$StockPayload>
/**
 * Model WarrantyCard
 * 
 */
export type WarrantyCard = $Result.DefaultSelection<Prisma.$WarrantyCardPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model CustomerFollowUp
 * 
 */
export type CustomerFollowUp = $Result.DefaultSelection<Prisma.$CustomerFollowUpPayload>
/**
 * Model PointTransaction
 * 
 */
export type PointTransaction = $Result.DefaultSelection<Prisma.$PointTransactionPayload>
/**
 * Model Incentive
 * 
 */
export type Incentive = $Result.DefaultSelection<Prisma.$IncentivePayload>
/**
 * Model DVR
 * 
 */
export type DVR = $Result.DefaultSelection<Prisma.$DVRPayload>
/**
 * Model DeliveryReport
 * 
 */
export type DeliveryReport = $Result.DefaultSelection<Prisma.$DeliveryReportPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model LiveLocation
 * 
 */
export type LiveLocation = $Result.DefaultSelection<Prisma.$LiveLocationPayload>
/**
 * Model ShiftAlert
 * 
 */
export type ShiftAlert = $Result.DefaultSelection<Prisma.$ShiftAlertPayload>
/**
 * Model RegisterWarranty
 * 
 */
export type RegisterWarranty = $Result.DefaultSelection<Prisma.$RegisterWarrantyPayload>
/**
 * Model PostDeliveryReport
 * 
 */
export type PostDeliveryReport = $Result.DefaultSelection<Prisma.$PostDeliveryReportPayload>
/**
 * Model CommissionedWork
 * 
 */
export type CommissionedWork = $Result.DefaultSelection<Prisma.$CommissionedWorkPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Cart
 * 
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>
/**
 * Model CartItem
 * 
 */
export type CartItem = $Result.DefaultSelection<Prisma.$CartItemPayload>
/**
 * Model PromoCode
 * 
 */
export type PromoCode = $Result.DefaultSelection<Prisma.$PromoCodePayload>
/**
 * Model Audit
 * 
 */
export type Audit = $Result.DefaultSelection<Prisma.$AuditPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model FinancialLog
 * 
 */
export type FinancialLog = $Result.DefaultSelection<Prisma.$FinancialLogPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model DamageReport
 * 
 */
export type DamageReport = $Result.DefaultSelection<Prisma.$DamageReportPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model CustomerVisit
 * 
 */
export type CustomerVisit = $Result.DefaultSelection<Prisma.$CustomerVisitPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model CapturedImage
 * 
 */
export type CapturedImage = $Result.DefaultSelection<Prisma.$CapturedImagePayload>
/**
 * Model Signature
 * 
 */
export type Signature = $Result.DefaultSelection<Prisma.$SignaturePayload>
/**
 * Model OfflineData
 * 
 */
export type OfflineData = $Result.DefaultSelection<Prisma.$OfflineDataPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  Admin: 'Admin',
  SalesManager: 'SalesManager',
  Plumber: 'Plumber',
  Accountant: 'Accountant',
  Distributor: 'Distributor',
  FieldExecutive: 'FieldExecutive',
  Worker: 'Worker'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const StockStatus: {
  Available: 'Available',
  Moved: 'Moved',
  Missing: 'Missing',
  Damaged: 'Damaged'
};

export type StockStatus = (typeof StockStatus)[keyof typeof StockStatus]


export const OrderStatus: {
  Pending: 'Pending',
  Completed: 'Completed',
  Cancelled: 'Cancelled'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const FollowUpStatus: {
  Pending: 'Pending',
  Completed: 'Completed',
  Postponed: 'Postponed'
};

export type FollowUpStatus = (typeof FollowUpStatus)[keyof typeof FollowUpStatus]


export const TransactionType: {
  Earned: 'Earned',
  Claimed: 'Claimed',
  Adjusted: 'Adjusted'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const CartStatus: {
  Active: 'Active',
  CheckedOut: 'CheckedOut',
  Abandoned: 'Abandoned'
};

export type CartStatus = (typeof CartStatus)[keyof typeof CartStatus]


export const PromoCodeStatus: {
  Active: 'Active',
  Inactive: 'Inactive',
  Expired: 'Expired'
};

export type PromoCodeStatus = (typeof PromoCodeStatus)[keyof typeof PromoCodeStatus]


export const InvoiceStatus: {
  Draft: 'Draft',
  Sent: 'Sent',
  Paid: 'Paid',
  Overdue: 'Overdue',
  Cancelled: 'Cancelled'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const NotificationType: {
  Info: 'Info',
  Alert: 'Alert',
  Promo: 'Promo',
  System: 'System'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const TaskStatus: {
  Pending: 'Pending',
  InProgress: 'InProgress',
  Completed: 'Completed'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const FinancialLogType: {
  Income: 'Income',
  Expense: 'Expense',
  Transfer: 'Transfer',
  Adjustment: 'Adjustment'
};

export type FinancialLogType = (typeof FinancialLogType)[keyof typeof FinancialLogType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type StockStatus = $Enums.StockStatus

export const StockStatus: typeof $Enums.StockStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type FollowUpStatus = $Enums.FollowUpStatus

export const FollowUpStatus: typeof $Enums.FollowUpStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type CartStatus = $Enums.CartStatus

export const CartStatus: typeof $Enums.CartStatus

export type PromoCodeStatus = $Enums.PromoCodeStatus

export const PromoCodeStatus: typeof $Enums.PromoCodeStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type FinancialLogType = $Enums.FinancialLogType

export const FinancialLogType: typeof $Enums.FinancialLogType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesManager`: Exposes CRUD operations for the **SalesManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesManagers
    * const salesManagers = await prisma.salesManager.findMany()
    * ```
    */
  get salesManager(): Prisma.SalesManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plumber`: Exposes CRUD operations for the **Plumber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plumbers
    * const plumbers = await prisma.plumber.findMany()
    * ```
    */
  get plumber(): Prisma.PlumberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plumberAccountProfile`: Exposes CRUD operations for the **PlumberAccountProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlumberAccountProfiles
    * const plumberAccountProfiles = await prisma.plumberAccountProfile.findMany()
    * ```
    */
  get plumberAccountProfile(): Prisma.PlumberAccountProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountant`: Exposes CRUD operations for the **Accountant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accountants
    * const accountants = await prisma.accountant.findMany()
    * ```
    */
  get accountant(): Prisma.AccountantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.distributor`: Exposes CRUD operations for the **Distributor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Distributors
    * const distributors = await prisma.distributor.findMany()
    * ```
    */
  get distributor(): Prisma.DistributorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fieldExecutive`: Exposes CRUD operations for the **FieldExecutive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldExecutives
    * const fieldExecutives = await prisma.fieldExecutive.findMany()
    * ```
    */
  get fieldExecutive(): Prisma.FieldExecutiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.worker`: Exposes CRUD operations for the **Worker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workers
    * const workers = await prisma.worker.findMany()
    * ```
    */
  get worker(): Prisma.WorkerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stock`: Exposes CRUD operations for the **Stock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stocks
    * const stocks = await prisma.stock.findMany()
    * ```
    */
  get stock(): Prisma.StockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warrantyCard`: Exposes CRUD operations for the **WarrantyCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarrantyCards
    * const warrantyCards = await prisma.warrantyCard.findMany()
    * ```
    */
  get warrantyCard(): Prisma.WarrantyCardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerFollowUp`: Exposes CRUD operations for the **CustomerFollowUp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerFollowUps
    * const customerFollowUps = await prisma.customerFollowUp.findMany()
    * ```
    */
  get customerFollowUp(): Prisma.CustomerFollowUpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pointTransaction`: Exposes CRUD operations for the **PointTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointTransactions
    * const pointTransactions = await prisma.pointTransaction.findMany()
    * ```
    */
  get pointTransaction(): Prisma.PointTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.incentive`: Exposes CRUD operations for the **Incentive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incentives
    * const incentives = await prisma.incentive.findMany()
    * ```
    */
  get incentive(): Prisma.IncentiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dVR`: Exposes CRUD operations for the **DVR** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DVRS
    * const dVRS = await prisma.dVR.findMany()
    * ```
    */
  get dVR(): Prisma.DVRDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryReport`: Exposes CRUD operations for the **DeliveryReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryReports
    * const deliveryReports = await prisma.deliveryReport.findMany()
    * ```
    */
  get deliveryReport(): Prisma.DeliveryReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.liveLocation`: Exposes CRUD operations for the **LiveLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiveLocations
    * const liveLocations = await prisma.liveLocation.findMany()
    * ```
    */
  get liveLocation(): Prisma.LiveLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shiftAlert`: Exposes CRUD operations for the **ShiftAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShiftAlerts
    * const shiftAlerts = await prisma.shiftAlert.findMany()
    * ```
    */
  get shiftAlert(): Prisma.ShiftAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.registerWarranty`: Exposes CRUD operations for the **RegisterWarranty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegisterWarranties
    * const registerWarranties = await prisma.registerWarranty.findMany()
    * ```
    */
  get registerWarranty(): Prisma.RegisterWarrantyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postDeliveryReport`: Exposes CRUD operations for the **PostDeliveryReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostDeliveryReports
    * const postDeliveryReports = await prisma.postDeliveryReport.findMany()
    * ```
    */
  get postDeliveryReport(): Prisma.PostDeliveryReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commissionedWork`: Exposes CRUD operations for the **CommissionedWork** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommissionedWorks
    * const commissionedWorks = await prisma.commissionedWork.findMany()
    * ```
    */
  get commissionedWork(): Prisma.CommissionedWorkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItem`: Exposes CRUD operations for the **CartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItems
    * const cartItems = await prisma.cartItem.findMany()
    * ```
    */
  get cartItem(): Prisma.CartItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promoCode`: Exposes CRUD operations for the **PromoCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoCodes
    * const promoCodes = await prisma.promoCode.findMany()
    * ```
    */
  get promoCode(): Prisma.PromoCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audit`: Exposes CRUD operations for the **Audit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audits
    * const audits = await prisma.audit.findMany()
    * ```
    */
  get audit(): Prisma.AuditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financialLog`: Exposes CRUD operations for the **FinancialLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialLogs
    * const financialLogs = await prisma.financialLog.findMany()
    * ```
    */
  get financialLog(): Prisma.FinancialLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.damageReport`: Exposes CRUD operations for the **DamageReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DamageReports
    * const damageReports = await prisma.damageReport.findMany()
    * ```
    */
  get damageReport(): Prisma.DamageReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerVisit`: Exposes CRUD operations for the **CustomerVisit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerVisits
    * const customerVisits = await prisma.customerVisit.findMany()
    * ```
    */
  get customerVisit(): Prisma.CustomerVisitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capturedImage`: Exposes CRUD operations for the **CapturedImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CapturedImages
    * const capturedImages = await prisma.capturedImage.findMany()
    * ```
    */
  get capturedImage(): Prisma.CapturedImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.signature`: Exposes CRUD operations for the **Signature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Signatures
    * const signatures = await prisma.signature.findMany()
    * ```
    */
  get signature(): Prisma.SignatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offlineData`: Exposes CRUD operations for the **OfflineData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfflineData
    * const offlineData = await prisma.offlineData.findMany()
    * ```
    */
  get offlineData(): Prisma.OfflineDataDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Company: 'Company',
    Admin: 'Admin',
    SalesManager: 'SalesManager',
    Plumber: 'Plumber',
    PlumberAccountProfile: 'PlumberAccountProfile',
    Accountant: 'Accountant',
    Distributor: 'Distributor',
    FieldExecutive: 'FieldExecutive',
    Worker: 'Worker',
    Product: 'Product',
    Stock: 'Stock',
    WarrantyCard: 'WarrantyCard',
    Attendance: 'Attendance',
    CustomerFollowUp: 'CustomerFollowUp',
    PointTransaction: 'PointTransaction',
    Incentive: 'Incentive',
    DVR: 'DVR',
    DeliveryReport: 'DeliveryReport',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Invoice: 'Invoice',
    LiveLocation: 'LiveLocation',
    ShiftAlert: 'ShiftAlert',
    RegisterWarranty: 'RegisterWarranty',
    PostDeliveryReport: 'PostDeliveryReport',
    CommissionedWork: 'CommissionedWork',
    Category: 'Category',
    Cart: 'Cart',
    CartItem: 'CartItem',
    PromoCode: 'PromoCode',
    Audit: 'Audit',
    Notification: 'Notification',
    FinancialLog: 'FinancialLog',
    Task: 'Task',
    DamageReport: 'DamageReport',
    Customer: 'Customer',
    CustomerVisit: 'CustomerVisit',
    ChatMessage: 'ChatMessage',
    CapturedImage: 'CapturedImage',
    Signature: 'Signature',
    OfflineData: 'OfflineData'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "company" | "admin" | "salesManager" | "plumber" | "plumberAccountProfile" | "accountant" | "distributor" | "fieldExecutive" | "worker" | "product" | "stock" | "warrantyCard" | "attendance" | "customerFollowUp" | "pointTransaction" | "incentive" | "dVR" | "deliveryReport" | "order" | "orderItem" | "invoice" | "liveLocation" | "shiftAlert" | "registerWarranty" | "postDeliveryReport" | "commissionedWork" | "category" | "cart" | "cartItem" | "promoCode" | "audit" | "notification" | "financialLog" | "task" | "damageReport" | "customer" | "customerVisit" | "chatMessage" | "capturedImage" | "signature" | "offlineData"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CompanyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CompanyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AdminFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AdminAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      SalesManager: {
        payload: Prisma.$SalesManagerPayload<ExtArgs>
        fields: Prisma.SalesManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesManagerPayload>
          }
          findFirst: {
            args: Prisma.SalesManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesManagerPayload>
          }
          findMany: {
            args: Prisma.SalesManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesManagerPayload>[]
          }
          create: {
            args: Prisma.SalesManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesManagerPayload>
          }
          createMany: {
            args: Prisma.SalesManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SalesManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesManagerPayload>
          }
          update: {
            args: Prisma.SalesManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesManagerPayload>
          }
          deleteMany: {
            args: Prisma.SalesManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalesManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesManagerPayload>
          }
          aggregate: {
            args: Prisma.SalesManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesManager>
          }
          groupBy: {
            args: Prisma.SalesManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesManagerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SalesManagerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SalesManagerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SalesManagerCountArgs<ExtArgs>
            result: $Utils.Optional<SalesManagerCountAggregateOutputType> | number
          }
        }
      }
      Plumber: {
        payload: Prisma.$PlumberPayload<ExtArgs>
        fields: Prisma.PlumberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlumberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlumberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberPayload>
          }
          findFirst: {
            args: Prisma.PlumberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlumberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberPayload>
          }
          findMany: {
            args: Prisma.PlumberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberPayload>[]
          }
          create: {
            args: Prisma.PlumberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberPayload>
          }
          createMany: {
            args: Prisma.PlumberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlumberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberPayload>
          }
          update: {
            args: Prisma.PlumberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberPayload>
          }
          deleteMany: {
            args: Prisma.PlumberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlumberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlumberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberPayload>
          }
          aggregate: {
            args: Prisma.PlumberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlumber>
          }
          groupBy: {
            args: Prisma.PlumberGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlumberGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PlumberFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PlumberAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PlumberCountArgs<ExtArgs>
            result: $Utils.Optional<PlumberCountAggregateOutputType> | number
          }
        }
      }
      PlumberAccountProfile: {
        payload: Prisma.$PlumberAccountProfilePayload<ExtArgs>
        fields: Prisma.PlumberAccountProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlumberAccountProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberAccountProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlumberAccountProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberAccountProfilePayload>
          }
          findFirst: {
            args: Prisma.PlumberAccountProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberAccountProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlumberAccountProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberAccountProfilePayload>
          }
          findMany: {
            args: Prisma.PlumberAccountProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberAccountProfilePayload>[]
          }
          create: {
            args: Prisma.PlumberAccountProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberAccountProfilePayload>
          }
          createMany: {
            args: Prisma.PlumberAccountProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlumberAccountProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberAccountProfilePayload>
          }
          update: {
            args: Prisma.PlumberAccountProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberAccountProfilePayload>
          }
          deleteMany: {
            args: Prisma.PlumberAccountProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlumberAccountProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlumberAccountProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlumberAccountProfilePayload>
          }
          aggregate: {
            args: Prisma.PlumberAccountProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlumberAccountProfile>
          }
          groupBy: {
            args: Prisma.PlumberAccountProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlumberAccountProfileGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PlumberAccountProfileFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PlumberAccountProfileAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PlumberAccountProfileCountArgs<ExtArgs>
            result: $Utils.Optional<PlumberAccountProfileCountAggregateOutputType> | number
          }
        }
      }
      Accountant: {
        payload: Prisma.$AccountantPayload<ExtArgs>
        fields: Prisma.AccountantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountantPayload>
          }
          findFirst: {
            args: Prisma.AccountantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountantPayload>
          }
          findMany: {
            args: Prisma.AccountantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountantPayload>[]
          }
          create: {
            args: Prisma.AccountantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountantPayload>
          }
          createMany: {
            args: Prisma.AccountantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountantPayload>
          }
          update: {
            args: Prisma.AccountantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountantPayload>
          }
          deleteMany: {
            args: Prisma.AccountantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountantPayload>
          }
          aggregate: {
            args: Prisma.AccountantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountant>
          }
          groupBy: {
            args: Prisma.AccountantGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountantGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AccountantFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AccountantAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AccountantCountArgs<ExtArgs>
            result: $Utils.Optional<AccountantCountAggregateOutputType> | number
          }
        }
      }
      Distributor: {
        payload: Prisma.$DistributorPayload<ExtArgs>
        fields: Prisma.DistributorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistributorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistributorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>
          }
          findFirst: {
            args: Prisma.DistributorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistributorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>
          }
          findMany: {
            args: Prisma.DistributorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>[]
          }
          create: {
            args: Prisma.DistributorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>
          }
          createMany: {
            args: Prisma.DistributorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DistributorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>
          }
          update: {
            args: Prisma.DistributorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>
          }
          deleteMany: {
            args: Prisma.DistributorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistributorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DistributorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributorPayload>
          }
          aggregate: {
            args: Prisma.DistributorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistributor>
          }
          groupBy: {
            args: Prisma.DistributorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistributorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DistributorFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DistributorAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DistributorCountArgs<ExtArgs>
            result: $Utils.Optional<DistributorCountAggregateOutputType> | number
          }
        }
      }
      FieldExecutive: {
        payload: Prisma.$FieldExecutivePayload<ExtArgs>
        fields: Prisma.FieldExecutiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldExecutiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldExecutiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>
          }
          findFirst: {
            args: Prisma.FieldExecutiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldExecutiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>
          }
          findMany: {
            args: Prisma.FieldExecutiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>[]
          }
          create: {
            args: Prisma.FieldExecutiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>
          }
          createMany: {
            args: Prisma.FieldExecutiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FieldExecutiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>
          }
          update: {
            args: Prisma.FieldExecutiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>
          }
          deleteMany: {
            args: Prisma.FieldExecutiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FieldExecutiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FieldExecutiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>
          }
          aggregate: {
            args: Prisma.FieldExecutiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFieldExecutive>
          }
          groupBy: {
            args: Prisma.FieldExecutiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldExecutiveGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FieldExecutiveFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FieldExecutiveAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FieldExecutiveCountArgs<ExtArgs>
            result: $Utils.Optional<FieldExecutiveCountAggregateOutputType> | number
          }
        }
      }
      Worker: {
        payload: Prisma.$WorkerPayload<ExtArgs>
        fields: Prisma.WorkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findFirst: {
            args: Prisma.WorkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findMany: {
            args: Prisma.WorkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          create: {
            args: Prisma.WorkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          createMany: {
            args: Prisma.WorkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WorkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          update: {
            args: Prisma.WorkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          deleteMany: {
            args: Prisma.WorkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          aggregate: {
            args: Prisma.WorkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorker>
          }
          groupBy: {
            args: Prisma.WorkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.WorkerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.WorkerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.WorkerCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProductFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProductAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Stock: {
        payload: Prisma.$StockPayload<ExtArgs>
        fields: Prisma.StockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findFirst: {
            args: Prisma.StockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findMany: {
            args: Prisma.StockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          create: {
            args: Prisma.StockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          createMany: {
            args: Prisma.StockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          update: {
            args: Prisma.StockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          deleteMany: {
            args: Prisma.StockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          aggregate: {
            args: Prisma.StockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStock>
          }
          groupBy: {
            args: Prisma.StockGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.StockFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.StockAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.StockCountArgs<ExtArgs>
            result: $Utils.Optional<StockCountAggregateOutputType> | number
          }
        }
      }
      WarrantyCard: {
        payload: Prisma.$WarrantyCardPayload<ExtArgs>
        fields: Prisma.WarrantyCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarrantyCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarrantyCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarrantyCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarrantyCardPayload>
          }
          findFirst: {
            args: Prisma.WarrantyCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarrantyCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarrantyCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarrantyCardPayload>
          }
          findMany: {
            args: Prisma.WarrantyCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarrantyCardPayload>[]
          }
          create: {
            args: Prisma.WarrantyCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarrantyCardPayload>
          }
          createMany: {
            args: Prisma.WarrantyCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WarrantyCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarrantyCardPayload>
          }
          update: {
            args: Prisma.WarrantyCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarrantyCardPayload>
          }
          deleteMany: {
            args: Prisma.WarrantyCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarrantyCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WarrantyCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarrantyCardPayload>
          }
          aggregate: {
            args: Prisma.WarrantyCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarrantyCard>
          }
          groupBy: {
            args: Prisma.WarrantyCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarrantyCardGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.WarrantyCardFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.WarrantyCardAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.WarrantyCardCountArgs<ExtArgs>
            result: $Utils.Optional<WarrantyCardCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AttendanceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AttendanceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      CustomerFollowUp: {
        payload: Prisma.$CustomerFollowUpPayload<ExtArgs>
        fields: Prisma.CustomerFollowUpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFollowUpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFollowUpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFollowUpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFollowUpPayload>
          }
          findFirst: {
            args: Prisma.CustomerFollowUpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFollowUpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFollowUpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFollowUpPayload>
          }
          findMany: {
            args: Prisma.CustomerFollowUpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFollowUpPayload>[]
          }
          create: {
            args: Prisma.CustomerFollowUpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFollowUpPayload>
          }
          createMany: {
            args: Prisma.CustomerFollowUpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerFollowUpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFollowUpPayload>
          }
          update: {
            args: Prisma.CustomerFollowUpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFollowUpPayload>
          }
          deleteMany: {
            args: Prisma.CustomerFollowUpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerFollowUpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerFollowUpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFollowUpPayload>
          }
          aggregate: {
            args: Prisma.CustomerFollowUpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerFollowUp>
          }
          groupBy: {
            args: Prisma.CustomerFollowUpGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerFollowUpGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CustomerFollowUpFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CustomerFollowUpAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CustomerFollowUpCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerFollowUpCountAggregateOutputType> | number
          }
        }
      }
      PointTransaction: {
        payload: Prisma.$PointTransactionPayload<ExtArgs>
        fields: Prisma.PointTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          findFirst: {
            args: Prisma.PointTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          findMany: {
            args: Prisma.PointTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>[]
          }
          create: {
            args: Prisma.PointTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          createMany: {
            args: Prisma.PointTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PointTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          update: {
            args: Prisma.PointTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          deleteMany: {
            args: Prisma.PointTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PointTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          aggregate: {
            args: Prisma.PointTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointTransaction>
          }
          groupBy: {
            args: Prisma.PointTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointTransactionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PointTransactionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PointTransactionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PointTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<PointTransactionCountAggregateOutputType> | number
          }
        }
      }
      Incentive: {
        payload: Prisma.$IncentivePayload<ExtArgs>
        fields: Prisma.IncentiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncentiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncentiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>
          }
          findFirst: {
            args: Prisma.IncentiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncentiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>
          }
          findMany: {
            args: Prisma.IncentiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>[]
          }
          create: {
            args: Prisma.IncentiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>
          }
          createMany: {
            args: Prisma.IncentiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IncentiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>
          }
          update: {
            args: Prisma.IncentiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>
          }
          deleteMany: {
            args: Prisma.IncentiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncentiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncentiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>
          }
          aggregate: {
            args: Prisma.IncentiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncentive>
          }
          groupBy: {
            args: Prisma.IncentiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncentiveGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.IncentiveFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.IncentiveAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.IncentiveCountArgs<ExtArgs>
            result: $Utils.Optional<IncentiveCountAggregateOutputType> | number
          }
        }
      }
      DVR: {
        payload: Prisma.$DVRPayload<ExtArgs>
        fields: Prisma.DVRFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DVRFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DVRPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DVRFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DVRPayload>
          }
          findFirst: {
            args: Prisma.DVRFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DVRPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DVRFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DVRPayload>
          }
          findMany: {
            args: Prisma.DVRFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DVRPayload>[]
          }
          create: {
            args: Prisma.DVRCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DVRPayload>
          }
          createMany: {
            args: Prisma.DVRCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DVRDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DVRPayload>
          }
          update: {
            args: Prisma.DVRUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DVRPayload>
          }
          deleteMany: {
            args: Prisma.DVRDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DVRUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DVRUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DVRPayload>
          }
          aggregate: {
            args: Prisma.DVRAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDVR>
          }
          groupBy: {
            args: Prisma.DVRGroupByArgs<ExtArgs>
            result: $Utils.Optional<DVRGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DVRFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DVRAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DVRCountArgs<ExtArgs>
            result: $Utils.Optional<DVRCountAggregateOutputType> | number
          }
        }
      }
      DeliveryReport: {
        payload: Prisma.$DeliveryReportPayload<ExtArgs>
        fields: Prisma.DeliveryReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryReportPayload>
          }
          findFirst: {
            args: Prisma.DeliveryReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryReportPayload>
          }
          findMany: {
            args: Prisma.DeliveryReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryReportPayload>[]
          }
          create: {
            args: Prisma.DeliveryReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryReportPayload>
          }
          createMany: {
            args: Prisma.DeliveryReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeliveryReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryReportPayload>
          }
          update: {
            args: Prisma.DeliveryReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryReportPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryReportPayload>
          }
          aggregate: {
            args: Prisma.DeliveryReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryReport>
          }
          groupBy: {
            args: Prisma.DeliveryReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryReportGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DeliveryReportFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DeliveryReportAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DeliveryReportCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryReportCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OrderFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OrderAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OrderItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OrderItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InvoiceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InvoiceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      LiveLocation: {
        payload: Prisma.$LiveLocationPayload<ExtArgs>
        fields: Prisma.LiveLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiveLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiveLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveLocationPayload>
          }
          findFirst: {
            args: Prisma.LiveLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiveLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveLocationPayload>
          }
          findMany: {
            args: Prisma.LiveLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveLocationPayload>[]
          }
          create: {
            args: Prisma.LiveLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveLocationPayload>
          }
          createMany: {
            args: Prisma.LiveLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LiveLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveLocationPayload>
          }
          update: {
            args: Prisma.LiveLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveLocationPayload>
          }
          deleteMany: {
            args: Prisma.LiveLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiveLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LiveLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveLocationPayload>
          }
          aggregate: {
            args: Prisma.LiveLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiveLocation>
          }
          groupBy: {
            args: Prisma.LiveLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiveLocationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LiveLocationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LiveLocationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LiveLocationCountArgs<ExtArgs>
            result: $Utils.Optional<LiveLocationCountAggregateOutputType> | number
          }
        }
      }
      ShiftAlert: {
        payload: Prisma.$ShiftAlertPayload<ExtArgs>
        fields: Prisma.ShiftAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAlertPayload>
          }
          findFirst: {
            args: Prisma.ShiftAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAlertPayload>
          }
          findMany: {
            args: Prisma.ShiftAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAlertPayload>[]
          }
          create: {
            args: Prisma.ShiftAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAlertPayload>
          }
          createMany: {
            args: Prisma.ShiftAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShiftAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAlertPayload>
          }
          update: {
            args: Prisma.ShiftAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAlertPayload>
          }
          deleteMany: {
            args: Prisma.ShiftAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShiftAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAlertPayload>
          }
          aggregate: {
            args: Prisma.ShiftAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiftAlert>
          }
          groupBy: {
            args: Prisma.ShiftAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftAlertGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ShiftAlertFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ShiftAlertAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ShiftAlertCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftAlertCountAggregateOutputType> | number
          }
        }
      }
      RegisterWarranty: {
        payload: Prisma.$RegisterWarrantyPayload<ExtArgs>
        fields: Prisma.RegisterWarrantyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegisterWarrantyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterWarrantyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegisterWarrantyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterWarrantyPayload>
          }
          findFirst: {
            args: Prisma.RegisterWarrantyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterWarrantyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegisterWarrantyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterWarrantyPayload>
          }
          findMany: {
            args: Prisma.RegisterWarrantyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterWarrantyPayload>[]
          }
          create: {
            args: Prisma.RegisterWarrantyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterWarrantyPayload>
          }
          createMany: {
            args: Prisma.RegisterWarrantyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RegisterWarrantyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterWarrantyPayload>
          }
          update: {
            args: Prisma.RegisterWarrantyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterWarrantyPayload>
          }
          deleteMany: {
            args: Prisma.RegisterWarrantyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegisterWarrantyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegisterWarrantyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterWarrantyPayload>
          }
          aggregate: {
            args: Prisma.RegisterWarrantyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegisterWarranty>
          }
          groupBy: {
            args: Prisma.RegisterWarrantyGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegisterWarrantyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RegisterWarrantyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.RegisterWarrantyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.RegisterWarrantyCountArgs<ExtArgs>
            result: $Utils.Optional<RegisterWarrantyCountAggregateOutputType> | number
          }
        }
      }
      PostDeliveryReport: {
        payload: Prisma.$PostDeliveryReportPayload<ExtArgs>
        fields: Prisma.PostDeliveryReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostDeliveryReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDeliveryReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostDeliveryReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDeliveryReportPayload>
          }
          findFirst: {
            args: Prisma.PostDeliveryReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDeliveryReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostDeliveryReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDeliveryReportPayload>
          }
          findMany: {
            args: Prisma.PostDeliveryReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDeliveryReportPayload>[]
          }
          create: {
            args: Prisma.PostDeliveryReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDeliveryReportPayload>
          }
          createMany: {
            args: Prisma.PostDeliveryReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PostDeliveryReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDeliveryReportPayload>
          }
          update: {
            args: Prisma.PostDeliveryReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDeliveryReportPayload>
          }
          deleteMany: {
            args: Prisma.PostDeliveryReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostDeliveryReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostDeliveryReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDeliveryReportPayload>
          }
          aggregate: {
            args: Prisma.PostDeliveryReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostDeliveryReport>
          }
          groupBy: {
            args: Prisma.PostDeliveryReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostDeliveryReportGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PostDeliveryReportFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PostDeliveryReportAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PostDeliveryReportCountArgs<ExtArgs>
            result: $Utils.Optional<PostDeliveryReportCountAggregateOutputType> | number
          }
        }
      }
      CommissionedWork: {
        payload: Prisma.$CommissionedWorkPayload<ExtArgs>
        fields: Prisma.CommissionedWorkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommissionedWorkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionedWorkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommissionedWorkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionedWorkPayload>
          }
          findFirst: {
            args: Prisma.CommissionedWorkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionedWorkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommissionedWorkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionedWorkPayload>
          }
          findMany: {
            args: Prisma.CommissionedWorkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionedWorkPayload>[]
          }
          create: {
            args: Prisma.CommissionedWorkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionedWorkPayload>
          }
          createMany: {
            args: Prisma.CommissionedWorkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommissionedWorkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionedWorkPayload>
          }
          update: {
            args: Prisma.CommissionedWorkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionedWorkPayload>
          }
          deleteMany: {
            args: Prisma.CommissionedWorkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommissionedWorkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommissionedWorkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionedWorkPayload>
          }
          aggregate: {
            args: Prisma.CommissionedWorkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommissionedWork>
          }
          groupBy: {
            args: Prisma.CommissionedWorkGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommissionedWorkGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CommissionedWorkFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CommissionedWorkAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CommissionedWorkCountArgs<ExtArgs>
            result: $Utils.Optional<CommissionedWorkCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CategoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CategoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>
        fields: Prisma.CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CartFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CartAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      CartItem: {
        payload: Prisma.$CartItemPayload<ExtArgs>
        fields: Prisma.CartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findFirst: {
            args: Prisma.CartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findMany: {
            args: Prisma.CartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          create: {
            args: Prisma.CartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          createMany: {
            args: Prisma.CartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          update: {
            args: Prisma.CartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          deleteMany: {
            args: Prisma.CartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          aggregate: {
            args: Prisma.CartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItem>
          }
          groupBy: {
            args: Prisma.CartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CartItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CartItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CartItemCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemCountAggregateOutputType> | number
          }
        }
      }
      PromoCode: {
        payload: Prisma.$PromoCodePayload<ExtArgs>
        fields: Prisma.PromoCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findFirst: {
            args: Prisma.PromoCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findMany: {
            args: Prisma.PromoCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          create: {
            args: Prisma.PromoCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          createMany: {
            args: Prisma.PromoCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PromoCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          update: {
            args: Prisma.PromoCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          deleteMany: {
            args: Prisma.PromoCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromoCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          aggregate: {
            args: Prisma.PromoCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoCode>
          }
          groupBy: {
            args: Prisma.PromoCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PromoCodeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PromoCodeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PromoCodeCountArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeCountAggregateOutputType> | number
          }
        }
      }
      Audit: {
        payload: Prisma.$AuditPayload<ExtArgs>
        fields: Prisma.AuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          findFirst: {
            args: Prisma.AuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          findMany: {
            args: Prisma.AuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>[]
          }
          create: {
            args: Prisma.AuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          createMany: {
            args: Prisma.AuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          update: {
            args: Prisma.AuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          deleteMany: {
            args: Prisma.AuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          aggregate: {
            args: Prisma.AuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit>
          }
          groupBy: {
            args: Prisma.AuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AuditFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AuditAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AuditCountArgs<ExtArgs>
            result: $Utils.Optional<AuditCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NotificationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NotificationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      FinancialLog: {
        payload: Prisma.$FinancialLogPayload<ExtArgs>
        fields: Prisma.FinancialLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialLogPayload>
          }
          findFirst: {
            args: Prisma.FinancialLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialLogPayload>
          }
          findMany: {
            args: Prisma.FinancialLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialLogPayload>[]
          }
          create: {
            args: Prisma.FinancialLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialLogPayload>
          }
          createMany: {
            args: Prisma.FinancialLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FinancialLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialLogPayload>
          }
          update: {
            args: Prisma.FinancialLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialLogPayload>
          }
          deleteMany: {
            args: Prisma.FinancialLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FinancialLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialLogPayload>
          }
          aggregate: {
            args: Prisma.FinancialLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialLog>
          }
          groupBy: {
            args: Prisma.FinancialLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialLogGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FinancialLogFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FinancialLogAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FinancialLogCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialLogCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TaskFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TaskAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      DamageReport: {
        payload: Prisma.$DamageReportPayload<ExtArgs>
        fields: Prisma.DamageReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DamageReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DamageReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageReportPayload>
          }
          findFirst: {
            args: Prisma.DamageReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DamageReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageReportPayload>
          }
          findMany: {
            args: Prisma.DamageReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageReportPayload>[]
          }
          create: {
            args: Prisma.DamageReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageReportPayload>
          }
          createMany: {
            args: Prisma.DamageReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DamageReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageReportPayload>
          }
          update: {
            args: Prisma.DamageReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageReportPayload>
          }
          deleteMany: {
            args: Prisma.DamageReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DamageReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DamageReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageReportPayload>
          }
          aggregate: {
            args: Prisma.DamageReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDamageReport>
          }
          groupBy: {
            args: Prisma.DamageReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<DamageReportGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DamageReportFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DamageReportAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DamageReportCountArgs<ExtArgs>
            result: $Utils.Optional<DamageReportCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CustomerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CustomerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      CustomerVisit: {
        payload: Prisma.$CustomerVisitPayload<ExtArgs>
        fields: Prisma.CustomerVisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerVisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerVisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerVisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerVisitPayload>
          }
          findFirst: {
            args: Prisma.CustomerVisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerVisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerVisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerVisitPayload>
          }
          findMany: {
            args: Prisma.CustomerVisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerVisitPayload>[]
          }
          create: {
            args: Prisma.CustomerVisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerVisitPayload>
          }
          createMany: {
            args: Prisma.CustomerVisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerVisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerVisitPayload>
          }
          update: {
            args: Prisma.CustomerVisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerVisitPayload>
          }
          deleteMany: {
            args: Prisma.CustomerVisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerVisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerVisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerVisitPayload>
          }
          aggregate: {
            args: Prisma.CustomerVisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerVisit>
          }
          groupBy: {
            args: Prisma.CustomerVisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerVisitGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CustomerVisitFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CustomerVisitAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CustomerVisitCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerVisitCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ChatMessageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ChatMessageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      CapturedImage: {
        payload: Prisma.$CapturedImagePayload<ExtArgs>
        fields: Prisma.CapturedImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CapturedImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturedImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CapturedImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturedImagePayload>
          }
          findFirst: {
            args: Prisma.CapturedImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturedImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CapturedImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturedImagePayload>
          }
          findMany: {
            args: Prisma.CapturedImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturedImagePayload>[]
          }
          create: {
            args: Prisma.CapturedImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturedImagePayload>
          }
          createMany: {
            args: Prisma.CapturedImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CapturedImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturedImagePayload>
          }
          update: {
            args: Prisma.CapturedImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturedImagePayload>
          }
          deleteMany: {
            args: Prisma.CapturedImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CapturedImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CapturedImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturedImagePayload>
          }
          aggregate: {
            args: Prisma.CapturedImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapturedImage>
          }
          groupBy: {
            args: Prisma.CapturedImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CapturedImageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CapturedImageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CapturedImageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CapturedImageCountArgs<ExtArgs>
            result: $Utils.Optional<CapturedImageCountAggregateOutputType> | number
          }
        }
      }
      Signature: {
        payload: Prisma.$SignaturePayload<ExtArgs>
        fields: Prisma.SignatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          findFirst: {
            args: Prisma.SignatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          findMany: {
            args: Prisma.SignatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>[]
          }
          create: {
            args: Prisma.SignatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          createMany: {
            args: Prisma.SignatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SignatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          update: {
            args: Prisma.SignatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          deleteMany: {
            args: Prisma.SignatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SignatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          aggregate: {
            args: Prisma.SignatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignature>
          }
          groupBy: {
            args: Prisma.SignatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignatureGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SignatureFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SignatureAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SignatureCountArgs<ExtArgs>
            result: $Utils.Optional<SignatureCountAggregateOutputType> | number
          }
        }
      }
      OfflineData: {
        payload: Prisma.$OfflineDataPayload<ExtArgs>
        fields: Prisma.OfflineDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfflineDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfflineDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfflineDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfflineDataPayload>
          }
          findFirst: {
            args: Prisma.OfflineDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfflineDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfflineDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfflineDataPayload>
          }
          findMany: {
            args: Prisma.OfflineDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfflineDataPayload>[]
          }
          create: {
            args: Prisma.OfflineDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfflineDataPayload>
          }
          createMany: {
            args: Prisma.OfflineDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OfflineDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfflineDataPayload>
          }
          update: {
            args: Prisma.OfflineDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfflineDataPayload>
          }
          deleteMany: {
            args: Prisma.OfflineDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfflineDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfflineDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfflineDataPayload>
          }
          aggregate: {
            args: Prisma.OfflineDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOfflineData>
          }
          groupBy: {
            args: Prisma.OfflineDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfflineDataGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OfflineDataFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OfflineDataAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OfflineDataCountArgs<ExtArgs>
            result: $Utils.Optional<OfflineDataCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    company?: CompanyOmit
    admin?: AdminOmit
    salesManager?: SalesManagerOmit
    plumber?: PlumberOmit
    plumberAccountProfile?: PlumberAccountProfileOmit
    accountant?: AccountantOmit
    distributor?: DistributorOmit
    fieldExecutive?: FieldExecutiveOmit
    worker?: WorkerOmit
    product?: ProductOmit
    stock?: StockOmit
    warrantyCard?: WarrantyCardOmit
    attendance?: AttendanceOmit
    customerFollowUp?: CustomerFollowUpOmit
    pointTransaction?: PointTransactionOmit
    incentive?: IncentiveOmit
    dVR?: DVROmit
    deliveryReport?: DeliveryReportOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    invoice?: InvoiceOmit
    liveLocation?: LiveLocationOmit
    shiftAlert?: ShiftAlertOmit
    registerWarranty?: RegisterWarrantyOmit
    postDeliveryReport?: PostDeliveryReportOmit
    commissionedWork?: CommissionedWorkOmit
    category?: CategoryOmit
    cart?: CartOmit
    cartItem?: CartItemOmit
    promoCode?: PromoCodeOmit
    audit?: AuditOmit
    notification?: NotificationOmit
    financialLog?: FinancialLogOmit
    task?: TaskOmit
    damageReport?: DamageReportOmit
    customer?: CustomerOmit
    customerVisit?: CustomerVisitOmit
    chatMessage?: ChatMessageOmit
    capturedImage?: CapturedImageOmit
    signature?: SignatureOmit
    offlineData?: OfflineDataOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    attendances: number
    transactions: number
    incentives: number
    deliveryReports: number
    orders: number
    liveLocations: number
    ShiftAlert: number
    registeredWarranties: number
    postDeliveryReports: number
    commissionedWorks: number
    carts: number
    audits: number
    notifications: number
    financialLogs: number
    sentMessages: number
    receivedMessages: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | UserCountOutputTypeCountAttendancesArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    incentives?: boolean | UserCountOutputTypeCountIncentivesArgs
    deliveryReports?: boolean | UserCountOutputTypeCountDeliveryReportsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    liveLocations?: boolean | UserCountOutputTypeCountLiveLocationsArgs
    ShiftAlert?: boolean | UserCountOutputTypeCountShiftAlertArgs
    registeredWarranties?: boolean | UserCountOutputTypeCountRegisteredWarrantiesArgs
    postDeliveryReports?: boolean | UserCountOutputTypeCountPostDeliveryReportsArgs
    commissionedWorks?: boolean | UserCountOutputTypeCountCommissionedWorksArgs
    carts?: boolean | UserCountOutputTypeCountCartsArgs
    audits?: boolean | UserCountOutputTypeCountAuditsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    financialLogs?: boolean | UserCountOutputTypeCountFinancialLogsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIncentivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncentiveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeliveryReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLiveLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiveLocationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShiftAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftAlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRegisteredWarrantiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegisterWarrantyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostDeliveryReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostDeliveryReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommissionedWorksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionedWorkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFinancialLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    admins: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | CompanyCountOutputTypeCountAdminsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }


  /**
   * Count Type FieldExecutiveCountOutputType
   */

  export type FieldExecutiveCountOutputType = {
    followUps: number
    dvrReports: number
  }

  export type FieldExecutiveCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followUps?: boolean | FieldExecutiveCountOutputTypeCountFollowUpsArgs
    dvrReports?: boolean | FieldExecutiveCountOutputTypeCountDvrReportsArgs
  }

  // Custom InputTypes
  /**
   * FieldExecutiveCountOutputType without action
   */
  export type FieldExecutiveCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutiveCountOutputType
     */
    select?: FieldExecutiveCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FieldExecutiveCountOutputType without action
   */
  export type FieldExecutiveCountOutputTypeCountFollowUpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerFollowUpWhereInput
  }

  /**
   * FieldExecutiveCountOutputType without action
   */
  export type FieldExecutiveCountOutputTypeCountDvrReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DVRWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    stocks: number
    warrantyCards: number
    orderItems: number
    registeredWarranties: number
    cartItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | ProductCountOutputTypeCountStocksArgs
    warrantyCards?: boolean | ProductCountOutputTypeCountWarrantyCardsArgs
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    registeredWarranties?: boolean | ProductCountOutputTypeCountRegisteredWarrantiesArgs
    cartItems?: boolean | ProductCountOutputTypeCountCartItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountWarrantyCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarrantyCardWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRegisteredWarrantiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegisterWarrantyWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }


  /**
   * Count Type StockCountOutputType
   */

  export type StockCountOutputType = {
    damageReports: number
  }

  export type StockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    damageReports?: boolean | StockCountOutputTypeCountDamageReportsArgs
  }

  // Custom InputTypes
  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCountOutputType
     */
    select?: StockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeCountDamageReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DamageReportWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    orderItems: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | OrderCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    items: number
  }

  export type CartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CartCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }


  /**
   * Count Type PromoCodeCountOutputType
   */

  export type PromoCodeCountOutputType = {
    orders: number
  }

  export type PromoCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | PromoCodeCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeCountOutputType
     */
    select?: PromoCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    visits: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | CustomerCountOutputTypeCountVisitsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerVisitWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role: $Enums.UserRole | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role: $Enums.UserRole | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    password: number
    role: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    admin?: boolean | User$adminArgs<ExtArgs>
    salesManager?: boolean | User$salesManagerArgs<ExtArgs>
    plumber?: boolean | User$plumberArgs<ExtArgs>
    accountant?: boolean | User$accountantArgs<ExtArgs>
    distributor?: boolean | User$distributorArgs<ExtArgs>
    fieldExecutive?: boolean | User$fieldExecutiveArgs<ExtArgs>
    worker?: boolean | User$workerArgs<ExtArgs>
    accountProfile?: boolean | User$accountProfileArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    incentives?: boolean | User$incentivesArgs<ExtArgs>
    deliveryReports?: boolean | User$deliveryReportsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    liveLocations?: boolean | User$liveLocationsArgs<ExtArgs>
    ShiftAlert?: boolean | User$ShiftAlertArgs<ExtArgs>
    registeredWarranties?: boolean | User$registeredWarrantiesArgs<ExtArgs>
    postDeliveryReports?: boolean | User$postDeliveryReportsArgs<ExtArgs>
    commissionedWorks?: boolean | User$commissionedWorksArgs<ExtArgs>
    carts?: boolean | User$cartsArgs<ExtArgs>
    audits?: boolean | User$auditsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    financialLogs?: boolean | User$financialLogsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "password" | "role", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | User$adminArgs<ExtArgs>
    salesManager?: boolean | User$salesManagerArgs<ExtArgs>
    plumber?: boolean | User$plumberArgs<ExtArgs>
    accountant?: boolean | User$accountantArgs<ExtArgs>
    distributor?: boolean | User$distributorArgs<ExtArgs>
    fieldExecutive?: boolean | User$fieldExecutiveArgs<ExtArgs>
    worker?: boolean | User$workerArgs<ExtArgs>
    accountProfile?: boolean | User$accountProfileArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    incentives?: boolean | User$incentivesArgs<ExtArgs>
    deliveryReports?: boolean | User$deliveryReportsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    liveLocations?: boolean | User$liveLocationsArgs<ExtArgs>
    ShiftAlert?: boolean | User$ShiftAlertArgs<ExtArgs>
    registeredWarranties?: boolean | User$registeredWarrantiesArgs<ExtArgs>
    postDeliveryReports?: boolean | User$postDeliveryReportsArgs<ExtArgs>
    commissionedWorks?: boolean | User$commissionedWorksArgs<ExtArgs>
    carts?: boolean | User$cartsArgs<ExtArgs>
    audits?: boolean | User$auditsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    financialLogs?: boolean | User$financialLogsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
      salesManager: Prisma.$SalesManagerPayload<ExtArgs> | null
      plumber: Prisma.$PlumberPayload<ExtArgs> | null
      accountant: Prisma.$AccountantPayload<ExtArgs> | null
      distributor: Prisma.$DistributorPayload<ExtArgs> | null
      fieldExecutive: Prisma.$FieldExecutivePayload<ExtArgs> | null
      worker: Prisma.$WorkerPayload<ExtArgs> | null
      accountProfile: Prisma.$PlumberAccountProfilePayload<ExtArgs> | null
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      transactions: Prisma.$PointTransactionPayload<ExtArgs>[]
      incentives: Prisma.$IncentivePayload<ExtArgs>[]
      deliveryReports: Prisma.$DeliveryReportPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      liveLocations: Prisma.$LiveLocationPayload<ExtArgs>[]
      ShiftAlert: Prisma.$ShiftAlertPayload<ExtArgs>[]
      registeredWarranties: Prisma.$RegisterWarrantyPayload<ExtArgs>[]
      postDeliveryReports: Prisma.$PostDeliveryReportPayload<ExtArgs>[]
      commissionedWorks: Prisma.$CommissionedWorkPayload<ExtArgs>[]
      carts: Prisma.$CartPayload<ExtArgs>[]
      audits: Prisma.$AuditPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      financialLogs: Prisma.$FinancialLogPayload<ExtArgs>[]
      sentMessages: Prisma.$ChatMessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string
      password: string
      role: $Enums.UserRole
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    salesManager<T extends User$salesManagerArgs<ExtArgs> = {}>(args?: Subset<T, User$salesManagerArgs<ExtArgs>>): Prisma__SalesManagerClient<$Result.GetResult<Prisma.$SalesManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    plumber<T extends User$plumberArgs<ExtArgs> = {}>(args?: Subset<T, User$plumberArgs<ExtArgs>>): Prisma__PlumberClient<$Result.GetResult<Prisma.$PlumberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accountant<T extends User$accountantArgs<ExtArgs> = {}>(args?: Subset<T, User$accountantArgs<ExtArgs>>): Prisma__AccountantClient<$Result.GetResult<Prisma.$AccountantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    distributor<T extends User$distributorArgs<ExtArgs> = {}>(args?: Subset<T, User$distributorArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fieldExecutive<T extends User$fieldExecutiveArgs<ExtArgs> = {}>(args?: Subset<T, User$fieldExecutiveArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    worker<T extends User$workerArgs<ExtArgs> = {}>(args?: Subset<T, User$workerArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accountProfile<T extends User$accountProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$accountProfileArgs<ExtArgs>>): Prisma__PlumberAccountProfileClient<$Result.GetResult<Prisma.$PlumberAccountProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attendances<T extends User$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, User$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incentives<T extends User$incentivesArgs<ExtArgs> = {}>(args?: Subset<T, User$incentivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryReports<T extends User$deliveryReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$deliveryReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    liveLocations<T extends User$liveLocationsArgs<ExtArgs> = {}>(args?: Subset<T, User$liveLocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiveLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ShiftAlert<T extends User$ShiftAlertArgs<ExtArgs> = {}>(args?: Subset<T, User$ShiftAlertArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    registeredWarranties<T extends User$registeredWarrantiesArgs<ExtArgs> = {}>(args?: Subset<T, User$registeredWarrantiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisterWarrantyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postDeliveryReports<T extends User$postDeliveryReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$postDeliveryReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostDeliveryReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commissionedWorks<T extends User$commissionedWorksArgs<ExtArgs> = {}>(args?: Subset<T, User$commissionedWorksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionedWorkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    carts<T extends User$cartsArgs<ExtArgs> = {}>(args?: Subset<T, User$cartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    audits<T extends User$auditsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialLogs<T extends User$financialLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$financialLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.salesManager
   */
  export type User$salesManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesManager
     */
    select?: SalesManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesManager
     */
    omit?: SalesManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesManagerInclude<ExtArgs> | null
    where?: SalesManagerWhereInput
  }

  /**
   * User.plumber
   */
  export type User$plumberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plumber
     */
    select?: PlumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plumber
     */
    omit?: PlumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberInclude<ExtArgs> | null
    where?: PlumberWhereInput
  }

  /**
   * User.accountant
   */
  export type User$accountantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accountant
     */
    select?: AccountantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accountant
     */
    omit?: AccountantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountantInclude<ExtArgs> | null
    where?: AccountantWhereInput
  }

  /**
   * User.distributor
   */
  export type User$distributorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distributor
     */
    omit?: DistributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    where?: DistributorWhereInput
  }

  /**
   * User.fieldExecutive
   */
  export type User$fieldExecutiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    where?: FieldExecutiveWhereInput
  }

  /**
   * User.worker
   */
  export type User$workerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
  }

  /**
   * User.accountProfile
   */
  export type User$accountProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlumberAccountProfile
     */
    select?: PlumberAccountProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlumberAccountProfile
     */
    omit?: PlumberAccountProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberAccountProfileInclude<ExtArgs> | null
    where?: PlumberAccountProfileWhereInput
  }

  /**
   * User.attendances
   */
  export type User$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    where?: PointTransactionWhereInput
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    cursor?: PointTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * User.incentives
   */
  export type User$incentivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incentive
     */
    omit?: IncentiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    where?: IncentiveWhereInput
    orderBy?: IncentiveOrderByWithRelationInput | IncentiveOrderByWithRelationInput[]
    cursor?: IncentiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncentiveScalarFieldEnum | IncentiveScalarFieldEnum[]
  }

  /**
   * User.deliveryReports
   */
  export type User$deliveryReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryReport
     */
    select?: DeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryReport
     */
    omit?: DeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryReportInclude<ExtArgs> | null
    where?: DeliveryReportWhereInput
    orderBy?: DeliveryReportOrderByWithRelationInput | DeliveryReportOrderByWithRelationInput[]
    cursor?: DeliveryReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryReportScalarFieldEnum | DeliveryReportScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.liveLocations
   */
  export type User$liveLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveLocation
     */
    select?: LiveLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveLocation
     */
    omit?: LiveLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveLocationInclude<ExtArgs> | null
    where?: LiveLocationWhereInput
    orderBy?: LiveLocationOrderByWithRelationInput | LiveLocationOrderByWithRelationInput[]
    cursor?: LiveLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiveLocationScalarFieldEnum | LiveLocationScalarFieldEnum[]
  }

  /**
   * User.ShiftAlert
   */
  export type User$ShiftAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAlert
     */
    select?: ShiftAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftAlert
     */
    omit?: ShiftAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAlertInclude<ExtArgs> | null
    where?: ShiftAlertWhereInput
    orderBy?: ShiftAlertOrderByWithRelationInput | ShiftAlertOrderByWithRelationInput[]
    cursor?: ShiftAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftAlertScalarFieldEnum | ShiftAlertScalarFieldEnum[]
  }

  /**
   * User.registeredWarranties
   */
  export type User$registeredWarrantiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterWarranty
     */
    select?: RegisterWarrantySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterWarranty
     */
    omit?: RegisterWarrantyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisterWarrantyInclude<ExtArgs> | null
    where?: RegisterWarrantyWhereInput
    orderBy?: RegisterWarrantyOrderByWithRelationInput | RegisterWarrantyOrderByWithRelationInput[]
    cursor?: RegisterWarrantyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegisterWarrantyScalarFieldEnum | RegisterWarrantyScalarFieldEnum[]
  }

  /**
   * User.postDeliveryReports
   */
  export type User$postDeliveryReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDeliveryReport
     */
    select?: PostDeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDeliveryReport
     */
    omit?: PostDeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDeliveryReportInclude<ExtArgs> | null
    where?: PostDeliveryReportWhereInput
    orderBy?: PostDeliveryReportOrderByWithRelationInput | PostDeliveryReportOrderByWithRelationInput[]
    cursor?: PostDeliveryReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostDeliveryReportScalarFieldEnum | PostDeliveryReportScalarFieldEnum[]
  }

  /**
   * User.commissionedWorks
   */
  export type User$commissionedWorksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionedWork
     */
    select?: CommissionedWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionedWork
     */
    omit?: CommissionedWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionedWorkInclude<ExtArgs> | null
    where?: CommissionedWorkWhereInput
    orderBy?: CommissionedWorkOrderByWithRelationInput | CommissionedWorkOrderByWithRelationInput[]
    cursor?: CommissionedWorkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionedWorkScalarFieldEnum | CommissionedWorkScalarFieldEnum[]
  }

  /**
   * User.carts
   */
  export type User$cartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    cursor?: CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * User.audits
   */
  export type User$auditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    cursor?: AuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.financialLogs
   */
  export type User$financialLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialLog
     */
    select?: FinancialLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialLog
     */
    omit?: FinancialLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialLogInclude<ExtArgs> | null
    where?: FinancialLogWhereInput
    orderBy?: FinancialLogOrderByWithRelationInput | FinancialLogOrderByWithRelationInput[]
    cursor?: FinancialLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialLogScalarFieldEnum | FinancialLogScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    logoUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    logoUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    logoUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    description: string | null
    logoUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admins?: boolean | Company$adminsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>



  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "logoUrl" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | Company$adminsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      admins: Prisma.$AdminPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      logoUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * @param {CompanyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const company = await prisma.company.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CompanyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Company.
     * @param {CompanyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const company = await prisma.company.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CompanyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admins<T extends Company$adminsArgs<ExtArgs> = {}>(args?: Subset<T, Company$adminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly description: FieldRef<"Company", 'String'>
    readonly logoUrl: FieldRef<"Company", 'String'>
    readonly isActive: FieldRef<"Company", 'Boolean'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company findRaw
   */
  export type CompanyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Company aggregateRaw
   */
  export type CompanyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Company.admins
   */
  export type Company$adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    companyId: string | null
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Admin$companyArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>



  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyId", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Admin$companyArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * @param {AdminFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const admin = await prisma.admin.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AdminFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Admin.
     * @param {AdminAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const admin = await prisma.admin.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AdminAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends Admin$companyArgs<ExtArgs> = {}>(args?: Subset<T, Admin$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
    readonly companyId: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin findRaw
   */
  export type AdminFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Admin aggregateRaw
   */
  export type AdminAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Admin.company
   */
  export type Admin$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model SalesManager
   */

  export type AggregateSalesManager = {
    _count: SalesManagerCountAggregateOutputType | null
    _min: SalesManagerMinAggregateOutputType | null
    _max: SalesManagerMaxAggregateOutputType | null
  }

  export type SalesManagerMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type SalesManagerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type SalesManagerCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type SalesManagerMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SalesManagerMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SalesManagerCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type SalesManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesManager to aggregate.
     */
    where?: SalesManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesManagers to fetch.
     */
    orderBy?: SalesManagerOrderByWithRelationInput | SalesManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesManagers
    **/
    _count?: true | SalesManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesManagerMaxAggregateInputType
  }

  export type GetSalesManagerAggregateType<T extends SalesManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesManager[P]>
      : GetScalarType<T[P], AggregateSalesManager[P]>
  }




  export type SalesManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesManagerWhereInput
    orderBy?: SalesManagerOrderByWithAggregationInput | SalesManagerOrderByWithAggregationInput[]
    by: SalesManagerScalarFieldEnum[] | SalesManagerScalarFieldEnum
    having?: SalesManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesManagerCountAggregateInputType | true
    _min?: SalesManagerMinAggregateInputType
    _max?: SalesManagerMaxAggregateInputType
  }

  export type SalesManagerGroupByOutputType = {
    id: string
    userId: string
    _count: SalesManagerCountAggregateOutputType | null
    _min: SalesManagerMinAggregateOutputType | null
    _max: SalesManagerMaxAggregateOutputType | null
  }

  type GetSalesManagerGroupByPayload<T extends SalesManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesManagerGroupByOutputType[P]>
            : GetScalarType<T[P], SalesManagerGroupByOutputType[P]>
        }
      >
    >


  export type SalesManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesManager"]>



  export type SalesManagerSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type SalesManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["salesManager"]>
  export type SalesManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SalesManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesManager"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["salesManager"]>
    composites: {}
  }

  type SalesManagerGetPayload<S extends boolean | null | undefined | SalesManagerDefaultArgs> = $Result.GetResult<Prisma.$SalesManagerPayload, S>

  type SalesManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesManagerCountAggregateInputType | true
    }

  export interface SalesManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesManager'], meta: { name: 'SalesManager' } }
    /**
     * Find zero or one SalesManager that matches the filter.
     * @param {SalesManagerFindUniqueArgs} args - Arguments to find a SalesManager
     * @example
     * // Get one SalesManager
     * const salesManager = await prisma.salesManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesManagerFindUniqueArgs>(args: SelectSubset<T, SalesManagerFindUniqueArgs<ExtArgs>>): Prisma__SalesManagerClient<$Result.GetResult<Prisma.$SalesManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesManagerFindUniqueOrThrowArgs} args - Arguments to find a SalesManager
     * @example
     * // Get one SalesManager
     * const salesManager = await prisma.salesManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesManagerClient<$Result.GetResult<Prisma.$SalesManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesManagerFindFirstArgs} args - Arguments to find a SalesManager
     * @example
     * // Get one SalesManager
     * const salesManager = await prisma.salesManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesManagerFindFirstArgs>(args?: SelectSubset<T, SalesManagerFindFirstArgs<ExtArgs>>): Prisma__SalesManagerClient<$Result.GetResult<Prisma.$SalesManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesManagerFindFirstOrThrowArgs} args - Arguments to find a SalesManager
     * @example
     * // Get one SalesManager
     * const salesManager = await prisma.salesManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesManagerClient<$Result.GetResult<Prisma.$SalesManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesManagers
     * const salesManagers = await prisma.salesManager.findMany()
     * 
     * // Get first 10 SalesManagers
     * const salesManagers = await prisma.salesManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesManagerWithIdOnly = await prisma.salesManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesManagerFindManyArgs>(args?: SelectSubset<T, SalesManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesManager.
     * @param {SalesManagerCreateArgs} args - Arguments to create a SalesManager.
     * @example
     * // Create one SalesManager
     * const SalesManager = await prisma.salesManager.create({
     *   data: {
     *     // ... data to create a SalesManager
     *   }
     * })
     * 
     */
    create<T extends SalesManagerCreateArgs>(args: SelectSubset<T, SalesManagerCreateArgs<ExtArgs>>): Prisma__SalesManagerClient<$Result.GetResult<Prisma.$SalesManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesManagers.
     * @param {SalesManagerCreateManyArgs} args - Arguments to create many SalesManagers.
     * @example
     * // Create many SalesManagers
     * const salesManager = await prisma.salesManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesManagerCreateManyArgs>(args?: SelectSubset<T, SalesManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SalesManager.
     * @param {SalesManagerDeleteArgs} args - Arguments to delete one SalesManager.
     * @example
     * // Delete one SalesManager
     * const SalesManager = await prisma.salesManager.delete({
     *   where: {
     *     // ... filter to delete one SalesManager
     *   }
     * })
     * 
     */
    delete<T extends SalesManagerDeleteArgs>(args: SelectSubset<T, SalesManagerDeleteArgs<ExtArgs>>): Prisma__SalesManagerClient<$Result.GetResult<Prisma.$SalesManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesManager.
     * @param {SalesManagerUpdateArgs} args - Arguments to update one SalesManager.
     * @example
     * // Update one SalesManager
     * const salesManager = await prisma.salesManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesManagerUpdateArgs>(args: SelectSubset<T, SalesManagerUpdateArgs<ExtArgs>>): Prisma__SalesManagerClient<$Result.GetResult<Prisma.$SalesManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesManagers.
     * @param {SalesManagerDeleteManyArgs} args - Arguments to filter SalesManagers to delete.
     * @example
     * // Delete a few SalesManagers
     * const { count } = await prisma.salesManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesManagerDeleteManyArgs>(args?: SelectSubset<T, SalesManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesManagers
     * const salesManager = await prisma.salesManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesManagerUpdateManyArgs>(args: SelectSubset<T, SalesManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesManager.
     * @param {SalesManagerUpsertArgs} args - Arguments to update or create a SalesManager.
     * @example
     * // Update or create a SalesManager
     * const salesManager = await prisma.salesManager.upsert({
     *   create: {
     *     // ... data to create a SalesManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesManager we want to update
     *   }
     * })
     */
    upsert<T extends SalesManagerUpsertArgs>(args: SelectSubset<T, SalesManagerUpsertArgs<ExtArgs>>): Prisma__SalesManagerClient<$Result.GetResult<Prisma.$SalesManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesManagers that matches the filter.
     * @param {SalesManagerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const salesManager = await prisma.salesManager.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SalesManagerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SalesManager.
     * @param {SalesManagerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const salesManager = await prisma.salesManager.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SalesManagerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SalesManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesManagerCountArgs} args - Arguments to filter SalesManagers to count.
     * @example
     * // Count the number of SalesManagers
     * const count = await prisma.salesManager.count({
     *   where: {
     *     // ... the filter for the SalesManagers we want to count
     *   }
     * })
    **/
    count<T extends SalesManagerCountArgs>(
      args?: Subset<T, SalesManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesManagerAggregateArgs>(args: Subset<T, SalesManagerAggregateArgs>): Prisma.PrismaPromise<GetSalesManagerAggregateType<T>>

    /**
     * Group by SalesManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesManagerGroupByArgs['orderBy'] }
        : { orderBy?: SalesManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesManager model
   */
  readonly fields: SalesManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesManager model
   */
  interface SalesManagerFieldRefs {
    readonly id: FieldRef<"SalesManager", 'String'>
    readonly userId: FieldRef<"SalesManager", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SalesManager findUnique
   */
  export type SalesManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesManager
     */
    select?: SalesManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesManager
     */
    omit?: SalesManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesManagerInclude<ExtArgs> | null
    /**
     * Filter, which SalesManager to fetch.
     */
    where: SalesManagerWhereUniqueInput
  }

  /**
   * SalesManager findUniqueOrThrow
   */
  export type SalesManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesManager
     */
    select?: SalesManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesManager
     */
    omit?: SalesManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesManagerInclude<ExtArgs> | null
    /**
     * Filter, which SalesManager to fetch.
     */
    where: SalesManagerWhereUniqueInput
  }

  /**
   * SalesManager findFirst
   */
  export type SalesManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesManager
     */
    select?: SalesManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesManager
     */
    omit?: SalesManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesManagerInclude<ExtArgs> | null
    /**
     * Filter, which SalesManager to fetch.
     */
    where?: SalesManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesManagers to fetch.
     */
    orderBy?: SalesManagerOrderByWithRelationInput | SalesManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesManagers.
     */
    cursor?: SalesManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesManagers.
     */
    distinct?: SalesManagerScalarFieldEnum | SalesManagerScalarFieldEnum[]
  }

  /**
   * SalesManager findFirstOrThrow
   */
  export type SalesManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesManager
     */
    select?: SalesManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesManager
     */
    omit?: SalesManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesManagerInclude<ExtArgs> | null
    /**
     * Filter, which SalesManager to fetch.
     */
    where?: SalesManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesManagers to fetch.
     */
    orderBy?: SalesManagerOrderByWithRelationInput | SalesManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesManagers.
     */
    cursor?: SalesManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesManagers.
     */
    distinct?: SalesManagerScalarFieldEnum | SalesManagerScalarFieldEnum[]
  }

  /**
   * SalesManager findMany
   */
  export type SalesManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesManager
     */
    select?: SalesManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesManager
     */
    omit?: SalesManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesManagerInclude<ExtArgs> | null
    /**
     * Filter, which SalesManagers to fetch.
     */
    where?: SalesManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesManagers to fetch.
     */
    orderBy?: SalesManagerOrderByWithRelationInput | SalesManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesManagers.
     */
    cursor?: SalesManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesManagers.
     */
    skip?: number
    distinct?: SalesManagerScalarFieldEnum | SalesManagerScalarFieldEnum[]
  }

  /**
   * SalesManager create
   */
  export type SalesManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesManager
     */
    select?: SalesManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesManager
     */
    omit?: SalesManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesManager.
     */
    data: XOR<SalesManagerCreateInput, SalesManagerUncheckedCreateInput>
  }

  /**
   * SalesManager createMany
   */
  export type SalesManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesManagers.
     */
    data: SalesManagerCreateManyInput | SalesManagerCreateManyInput[]
  }

  /**
   * SalesManager update
   */
  export type SalesManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesManager
     */
    select?: SalesManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesManager
     */
    omit?: SalesManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesManager.
     */
    data: XOR<SalesManagerUpdateInput, SalesManagerUncheckedUpdateInput>
    /**
     * Choose, which SalesManager to update.
     */
    where: SalesManagerWhereUniqueInput
  }

  /**
   * SalesManager updateMany
   */
  export type SalesManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesManagers.
     */
    data: XOR<SalesManagerUpdateManyMutationInput, SalesManagerUncheckedUpdateManyInput>
    /**
     * Filter which SalesManagers to update
     */
    where?: SalesManagerWhereInput
    /**
     * Limit how many SalesManagers to update.
     */
    limit?: number
  }

  /**
   * SalesManager upsert
   */
  export type SalesManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesManager
     */
    select?: SalesManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesManager
     */
    omit?: SalesManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesManager to update in case it exists.
     */
    where: SalesManagerWhereUniqueInput
    /**
     * In case the SalesManager found by the `where` argument doesn't exist, create a new SalesManager with this data.
     */
    create: XOR<SalesManagerCreateInput, SalesManagerUncheckedCreateInput>
    /**
     * In case the SalesManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesManagerUpdateInput, SalesManagerUncheckedUpdateInput>
  }

  /**
   * SalesManager delete
   */
  export type SalesManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesManager
     */
    select?: SalesManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesManager
     */
    omit?: SalesManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesManagerInclude<ExtArgs> | null
    /**
     * Filter which SalesManager to delete.
     */
    where: SalesManagerWhereUniqueInput
  }

  /**
   * SalesManager deleteMany
   */
  export type SalesManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesManagers to delete
     */
    where?: SalesManagerWhereInput
    /**
     * Limit how many SalesManagers to delete.
     */
    limit?: number
  }

  /**
   * SalesManager findRaw
   */
  export type SalesManagerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SalesManager aggregateRaw
   */
  export type SalesManagerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SalesManager without action
   */
  export type SalesManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesManager
     */
    select?: SalesManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesManager
     */
    omit?: SalesManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesManagerInclude<ExtArgs> | null
  }


  /**
   * Model Plumber
   */

  export type AggregatePlumber = {
    _count: PlumberCountAggregateOutputType | null
    _min: PlumberMinAggregateOutputType | null
    _max: PlumberMaxAggregateOutputType | null
  }

  export type PlumberMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type PlumberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type PlumberCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type PlumberMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PlumberMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PlumberCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type PlumberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plumber to aggregate.
     */
    where?: PlumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plumbers to fetch.
     */
    orderBy?: PlumberOrderByWithRelationInput | PlumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plumbers
    **/
    _count?: true | PlumberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlumberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlumberMaxAggregateInputType
  }

  export type GetPlumberAggregateType<T extends PlumberAggregateArgs> = {
        [P in keyof T & keyof AggregatePlumber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlumber[P]>
      : GetScalarType<T[P], AggregatePlumber[P]>
  }




  export type PlumberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlumberWhereInput
    orderBy?: PlumberOrderByWithAggregationInput | PlumberOrderByWithAggregationInput[]
    by: PlumberScalarFieldEnum[] | PlumberScalarFieldEnum
    having?: PlumberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlumberCountAggregateInputType | true
    _min?: PlumberMinAggregateInputType
    _max?: PlumberMaxAggregateInputType
  }

  export type PlumberGroupByOutputType = {
    id: string
    userId: string
    _count: PlumberCountAggregateOutputType | null
    _min: PlumberMinAggregateOutputType | null
    _max: PlumberMaxAggregateOutputType | null
  }

  type GetPlumberGroupByPayload<T extends PlumberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlumberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlumberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlumberGroupByOutputType[P]>
            : GetScalarType<T[P], PlumberGroupByOutputType[P]>
        }
      >
    >


  export type PlumberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plumber"]>



  export type PlumberSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type PlumberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["plumber"]>
  export type PlumberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlumberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plumber"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["plumber"]>
    composites: {}
  }

  type PlumberGetPayload<S extends boolean | null | undefined | PlumberDefaultArgs> = $Result.GetResult<Prisma.$PlumberPayload, S>

  type PlumberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlumberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlumberCountAggregateInputType | true
    }

  export interface PlumberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plumber'], meta: { name: 'Plumber' } }
    /**
     * Find zero or one Plumber that matches the filter.
     * @param {PlumberFindUniqueArgs} args - Arguments to find a Plumber
     * @example
     * // Get one Plumber
     * const plumber = await prisma.plumber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlumberFindUniqueArgs>(args: SelectSubset<T, PlumberFindUniqueArgs<ExtArgs>>): Prisma__PlumberClient<$Result.GetResult<Prisma.$PlumberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plumber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlumberFindUniqueOrThrowArgs} args - Arguments to find a Plumber
     * @example
     * // Get one Plumber
     * const plumber = await prisma.plumber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlumberFindUniqueOrThrowArgs>(args: SelectSubset<T, PlumberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlumberClient<$Result.GetResult<Prisma.$PlumberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plumber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberFindFirstArgs} args - Arguments to find a Plumber
     * @example
     * // Get one Plumber
     * const plumber = await prisma.plumber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlumberFindFirstArgs>(args?: SelectSubset<T, PlumberFindFirstArgs<ExtArgs>>): Prisma__PlumberClient<$Result.GetResult<Prisma.$PlumberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plumber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberFindFirstOrThrowArgs} args - Arguments to find a Plumber
     * @example
     * // Get one Plumber
     * const plumber = await prisma.plumber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlumberFindFirstOrThrowArgs>(args?: SelectSubset<T, PlumberFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlumberClient<$Result.GetResult<Prisma.$PlumberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plumbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plumbers
     * const plumbers = await prisma.plumber.findMany()
     * 
     * // Get first 10 Plumbers
     * const plumbers = await prisma.plumber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plumberWithIdOnly = await prisma.plumber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlumberFindManyArgs>(args?: SelectSubset<T, PlumberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plumber.
     * @param {PlumberCreateArgs} args - Arguments to create a Plumber.
     * @example
     * // Create one Plumber
     * const Plumber = await prisma.plumber.create({
     *   data: {
     *     // ... data to create a Plumber
     *   }
     * })
     * 
     */
    create<T extends PlumberCreateArgs>(args: SelectSubset<T, PlumberCreateArgs<ExtArgs>>): Prisma__PlumberClient<$Result.GetResult<Prisma.$PlumberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plumbers.
     * @param {PlumberCreateManyArgs} args - Arguments to create many Plumbers.
     * @example
     * // Create many Plumbers
     * const plumber = await prisma.plumber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlumberCreateManyArgs>(args?: SelectSubset<T, PlumberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plumber.
     * @param {PlumberDeleteArgs} args - Arguments to delete one Plumber.
     * @example
     * // Delete one Plumber
     * const Plumber = await prisma.plumber.delete({
     *   where: {
     *     // ... filter to delete one Plumber
     *   }
     * })
     * 
     */
    delete<T extends PlumberDeleteArgs>(args: SelectSubset<T, PlumberDeleteArgs<ExtArgs>>): Prisma__PlumberClient<$Result.GetResult<Prisma.$PlumberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plumber.
     * @param {PlumberUpdateArgs} args - Arguments to update one Plumber.
     * @example
     * // Update one Plumber
     * const plumber = await prisma.plumber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlumberUpdateArgs>(args: SelectSubset<T, PlumberUpdateArgs<ExtArgs>>): Prisma__PlumberClient<$Result.GetResult<Prisma.$PlumberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plumbers.
     * @param {PlumberDeleteManyArgs} args - Arguments to filter Plumbers to delete.
     * @example
     * // Delete a few Plumbers
     * const { count } = await prisma.plumber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlumberDeleteManyArgs>(args?: SelectSubset<T, PlumberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plumbers
     * const plumber = await prisma.plumber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlumberUpdateManyArgs>(args: SelectSubset<T, PlumberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plumber.
     * @param {PlumberUpsertArgs} args - Arguments to update or create a Plumber.
     * @example
     * // Update or create a Plumber
     * const plumber = await prisma.plumber.upsert({
     *   create: {
     *     // ... data to create a Plumber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plumber we want to update
     *   }
     * })
     */
    upsert<T extends PlumberUpsertArgs>(args: SelectSubset<T, PlumberUpsertArgs<ExtArgs>>): Prisma__PlumberClient<$Result.GetResult<Prisma.$PlumberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plumbers that matches the filter.
     * @param {PlumberFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const plumber = await prisma.plumber.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PlumberFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Plumber.
     * @param {PlumberAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const plumber = await prisma.plumber.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PlumberAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Plumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberCountArgs} args - Arguments to filter Plumbers to count.
     * @example
     * // Count the number of Plumbers
     * const count = await prisma.plumber.count({
     *   where: {
     *     // ... the filter for the Plumbers we want to count
     *   }
     * })
    **/
    count<T extends PlumberCountArgs>(
      args?: Subset<T, PlumberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlumberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlumberAggregateArgs>(args: Subset<T, PlumberAggregateArgs>): Prisma.PrismaPromise<GetPlumberAggregateType<T>>

    /**
     * Group by Plumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlumberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlumberGroupByArgs['orderBy'] }
        : { orderBy?: PlumberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlumberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlumberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plumber model
   */
  readonly fields: PlumberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plumber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlumberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plumber model
   */
  interface PlumberFieldRefs {
    readonly id: FieldRef<"Plumber", 'String'>
    readonly userId: FieldRef<"Plumber", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Plumber findUnique
   */
  export type PlumberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plumber
     */
    select?: PlumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plumber
     */
    omit?: PlumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberInclude<ExtArgs> | null
    /**
     * Filter, which Plumber to fetch.
     */
    where: PlumberWhereUniqueInput
  }

  /**
   * Plumber findUniqueOrThrow
   */
  export type PlumberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plumber
     */
    select?: PlumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plumber
     */
    omit?: PlumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberInclude<ExtArgs> | null
    /**
     * Filter, which Plumber to fetch.
     */
    where: PlumberWhereUniqueInput
  }

  /**
   * Plumber findFirst
   */
  export type PlumberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plumber
     */
    select?: PlumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plumber
     */
    omit?: PlumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberInclude<ExtArgs> | null
    /**
     * Filter, which Plumber to fetch.
     */
    where?: PlumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plumbers to fetch.
     */
    orderBy?: PlumberOrderByWithRelationInput | PlumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plumbers.
     */
    cursor?: PlumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plumbers.
     */
    distinct?: PlumberScalarFieldEnum | PlumberScalarFieldEnum[]
  }

  /**
   * Plumber findFirstOrThrow
   */
  export type PlumberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plumber
     */
    select?: PlumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plumber
     */
    omit?: PlumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberInclude<ExtArgs> | null
    /**
     * Filter, which Plumber to fetch.
     */
    where?: PlumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plumbers to fetch.
     */
    orderBy?: PlumberOrderByWithRelationInput | PlumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plumbers.
     */
    cursor?: PlumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plumbers.
     */
    distinct?: PlumberScalarFieldEnum | PlumberScalarFieldEnum[]
  }

  /**
   * Plumber findMany
   */
  export type PlumberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plumber
     */
    select?: PlumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plumber
     */
    omit?: PlumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberInclude<ExtArgs> | null
    /**
     * Filter, which Plumbers to fetch.
     */
    where?: PlumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plumbers to fetch.
     */
    orderBy?: PlumberOrderByWithRelationInput | PlumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plumbers.
     */
    cursor?: PlumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plumbers.
     */
    skip?: number
    distinct?: PlumberScalarFieldEnum | PlumberScalarFieldEnum[]
  }

  /**
   * Plumber create
   */
  export type PlumberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plumber
     */
    select?: PlumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plumber
     */
    omit?: PlumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberInclude<ExtArgs> | null
    /**
     * The data needed to create a Plumber.
     */
    data: XOR<PlumberCreateInput, PlumberUncheckedCreateInput>
  }

  /**
   * Plumber createMany
   */
  export type PlumberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plumbers.
     */
    data: PlumberCreateManyInput | PlumberCreateManyInput[]
  }

  /**
   * Plumber update
   */
  export type PlumberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plumber
     */
    select?: PlumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plumber
     */
    omit?: PlumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberInclude<ExtArgs> | null
    /**
     * The data needed to update a Plumber.
     */
    data: XOR<PlumberUpdateInput, PlumberUncheckedUpdateInput>
    /**
     * Choose, which Plumber to update.
     */
    where: PlumberWhereUniqueInput
  }

  /**
   * Plumber updateMany
   */
  export type PlumberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plumbers.
     */
    data: XOR<PlumberUpdateManyMutationInput, PlumberUncheckedUpdateManyInput>
    /**
     * Filter which Plumbers to update
     */
    where?: PlumberWhereInput
    /**
     * Limit how many Plumbers to update.
     */
    limit?: number
  }

  /**
   * Plumber upsert
   */
  export type PlumberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plumber
     */
    select?: PlumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plumber
     */
    omit?: PlumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberInclude<ExtArgs> | null
    /**
     * The filter to search for the Plumber to update in case it exists.
     */
    where: PlumberWhereUniqueInput
    /**
     * In case the Plumber found by the `where` argument doesn't exist, create a new Plumber with this data.
     */
    create: XOR<PlumberCreateInput, PlumberUncheckedCreateInput>
    /**
     * In case the Plumber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlumberUpdateInput, PlumberUncheckedUpdateInput>
  }

  /**
   * Plumber delete
   */
  export type PlumberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plumber
     */
    select?: PlumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plumber
     */
    omit?: PlumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberInclude<ExtArgs> | null
    /**
     * Filter which Plumber to delete.
     */
    where: PlumberWhereUniqueInput
  }

  /**
   * Plumber deleteMany
   */
  export type PlumberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plumbers to delete
     */
    where?: PlumberWhereInput
    /**
     * Limit how many Plumbers to delete.
     */
    limit?: number
  }

  /**
   * Plumber findRaw
   */
  export type PlumberFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Plumber aggregateRaw
   */
  export type PlumberAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Plumber without action
   */
  export type PlumberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plumber
     */
    select?: PlumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plumber
     */
    omit?: PlumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberInclude<ExtArgs> | null
  }


  /**
   * Model PlumberAccountProfile
   */

  export type AggregatePlumberAccountProfile = {
    _count: PlumberAccountProfileCountAggregateOutputType | null
    _min: PlumberAccountProfileMinAggregateOutputType | null
    _max: PlumberAccountProfileMaxAggregateOutputType | null
  }

  export type PlumberAccountProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    contactNumber: string | null
    upiId: string | null
    upiQrUrl: string | null
    email: string | null
    bankName: string | null
    accountNumber: string | null
    accountHolderName: string | null
    ifscCode: string | null
    branchName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlumberAccountProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    contactNumber: string | null
    upiId: string | null
    upiQrUrl: string | null
    email: string | null
    bankName: string | null
    accountNumber: string | null
    accountHolderName: string | null
    ifscCode: string | null
    branchName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlumberAccountProfileCountAggregateOutputType = {
    id: number
    userId: number
    fullName: number
    contactNumber: number
    upiId: number
    upiQrUrl: number
    email: number
    bankName: number
    accountNumber: number
    accountHolderName: number
    ifscCode: number
    branchName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlumberAccountProfileMinAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    contactNumber?: true
    upiId?: true
    upiQrUrl?: true
    email?: true
    bankName?: true
    accountNumber?: true
    accountHolderName?: true
    ifscCode?: true
    branchName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlumberAccountProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    contactNumber?: true
    upiId?: true
    upiQrUrl?: true
    email?: true
    bankName?: true
    accountNumber?: true
    accountHolderName?: true
    ifscCode?: true
    branchName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlumberAccountProfileCountAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    contactNumber?: true
    upiId?: true
    upiQrUrl?: true
    email?: true
    bankName?: true
    accountNumber?: true
    accountHolderName?: true
    ifscCode?: true
    branchName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlumberAccountProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlumberAccountProfile to aggregate.
     */
    where?: PlumberAccountProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlumberAccountProfiles to fetch.
     */
    orderBy?: PlumberAccountProfileOrderByWithRelationInput | PlumberAccountProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlumberAccountProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlumberAccountProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlumberAccountProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlumberAccountProfiles
    **/
    _count?: true | PlumberAccountProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlumberAccountProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlumberAccountProfileMaxAggregateInputType
  }

  export type GetPlumberAccountProfileAggregateType<T extends PlumberAccountProfileAggregateArgs> = {
        [P in keyof T & keyof AggregatePlumberAccountProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlumberAccountProfile[P]>
      : GetScalarType<T[P], AggregatePlumberAccountProfile[P]>
  }




  export type PlumberAccountProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlumberAccountProfileWhereInput
    orderBy?: PlumberAccountProfileOrderByWithAggregationInput | PlumberAccountProfileOrderByWithAggregationInput[]
    by: PlumberAccountProfileScalarFieldEnum[] | PlumberAccountProfileScalarFieldEnum
    having?: PlumberAccountProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlumberAccountProfileCountAggregateInputType | true
    _min?: PlumberAccountProfileMinAggregateInputType
    _max?: PlumberAccountProfileMaxAggregateInputType
  }

  export type PlumberAccountProfileGroupByOutputType = {
    id: string
    userId: string
    fullName: string
    contactNumber: string
    upiId: string | null
    upiQrUrl: string | null
    email: string | null
    bankName: string | null
    accountNumber: string | null
    accountHolderName: string | null
    ifscCode: string | null
    branchName: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlumberAccountProfileCountAggregateOutputType | null
    _min: PlumberAccountProfileMinAggregateOutputType | null
    _max: PlumberAccountProfileMaxAggregateOutputType | null
  }

  type GetPlumberAccountProfileGroupByPayload<T extends PlumberAccountProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlumberAccountProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlumberAccountProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlumberAccountProfileGroupByOutputType[P]>
            : GetScalarType<T[P], PlumberAccountProfileGroupByOutputType[P]>
        }
      >
    >


  export type PlumberAccountProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    contactNumber?: boolean
    upiId?: boolean
    upiQrUrl?: boolean
    email?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountHolderName?: boolean
    ifscCode?: boolean
    branchName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plumberAccountProfile"]>



  export type PlumberAccountProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    fullName?: boolean
    contactNumber?: boolean
    upiId?: boolean
    upiQrUrl?: boolean
    email?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountHolderName?: boolean
    ifscCode?: boolean
    branchName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlumberAccountProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "fullName" | "contactNumber" | "upiId" | "upiQrUrl" | "email" | "bankName" | "accountNumber" | "accountHolderName" | "ifscCode" | "branchName" | "createdAt" | "updatedAt", ExtArgs["result"]["plumberAccountProfile"]>
  export type PlumberAccountProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlumberAccountProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlumberAccountProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      fullName: string
      contactNumber: string
      upiId: string | null
      upiQrUrl: string | null
      email: string | null
      bankName: string | null
      accountNumber: string | null
      accountHolderName: string | null
      ifscCode: string | null
      branchName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plumberAccountProfile"]>
    composites: {}
  }

  type PlumberAccountProfileGetPayload<S extends boolean | null | undefined | PlumberAccountProfileDefaultArgs> = $Result.GetResult<Prisma.$PlumberAccountProfilePayload, S>

  type PlumberAccountProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlumberAccountProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlumberAccountProfileCountAggregateInputType | true
    }

  export interface PlumberAccountProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlumberAccountProfile'], meta: { name: 'PlumberAccountProfile' } }
    /**
     * Find zero or one PlumberAccountProfile that matches the filter.
     * @param {PlumberAccountProfileFindUniqueArgs} args - Arguments to find a PlumberAccountProfile
     * @example
     * // Get one PlumberAccountProfile
     * const plumberAccountProfile = await prisma.plumberAccountProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlumberAccountProfileFindUniqueArgs>(args: SelectSubset<T, PlumberAccountProfileFindUniqueArgs<ExtArgs>>): Prisma__PlumberAccountProfileClient<$Result.GetResult<Prisma.$PlumberAccountProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlumberAccountProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlumberAccountProfileFindUniqueOrThrowArgs} args - Arguments to find a PlumberAccountProfile
     * @example
     * // Get one PlumberAccountProfile
     * const plumberAccountProfile = await prisma.plumberAccountProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlumberAccountProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, PlumberAccountProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlumberAccountProfileClient<$Result.GetResult<Prisma.$PlumberAccountProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlumberAccountProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberAccountProfileFindFirstArgs} args - Arguments to find a PlumberAccountProfile
     * @example
     * // Get one PlumberAccountProfile
     * const plumberAccountProfile = await prisma.plumberAccountProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlumberAccountProfileFindFirstArgs>(args?: SelectSubset<T, PlumberAccountProfileFindFirstArgs<ExtArgs>>): Prisma__PlumberAccountProfileClient<$Result.GetResult<Prisma.$PlumberAccountProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlumberAccountProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberAccountProfileFindFirstOrThrowArgs} args - Arguments to find a PlumberAccountProfile
     * @example
     * // Get one PlumberAccountProfile
     * const plumberAccountProfile = await prisma.plumberAccountProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlumberAccountProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, PlumberAccountProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlumberAccountProfileClient<$Result.GetResult<Prisma.$PlumberAccountProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlumberAccountProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberAccountProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlumberAccountProfiles
     * const plumberAccountProfiles = await prisma.plumberAccountProfile.findMany()
     * 
     * // Get first 10 PlumberAccountProfiles
     * const plumberAccountProfiles = await prisma.plumberAccountProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plumberAccountProfileWithIdOnly = await prisma.plumberAccountProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlumberAccountProfileFindManyArgs>(args?: SelectSubset<T, PlumberAccountProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlumberAccountProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlumberAccountProfile.
     * @param {PlumberAccountProfileCreateArgs} args - Arguments to create a PlumberAccountProfile.
     * @example
     * // Create one PlumberAccountProfile
     * const PlumberAccountProfile = await prisma.plumberAccountProfile.create({
     *   data: {
     *     // ... data to create a PlumberAccountProfile
     *   }
     * })
     * 
     */
    create<T extends PlumberAccountProfileCreateArgs>(args: SelectSubset<T, PlumberAccountProfileCreateArgs<ExtArgs>>): Prisma__PlumberAccountProfileClient<$Result.GetResult<Prisma.$PlumberAccountProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlumberAccountProfiles.
     * @param {PlumberAccountProfileCreateManyArgs} args - Arguments to create many PlumberAccountProfiles.
     * @example
     * // Create many PlumberAccountProfiles
     * const plumberAccountProfile = await prisma.plumberAccountProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlumberAccountProfileCreateManyArgs>(args?: SelectSubset<T, PlumberAccountProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlumberAccountProfile.
     * @param {PlumberAccountProfileDeleteArgs} args - Arguments to delete one PlumberAccountProfile.
     * @example
     * // Delete one PlumberAccountProfile
     * const PlumberAccountProfile = await prisma.plumberAccountProfile.delete({
     *   where: {
     *     // ... filter to delete one PlumberAccountProfile
     *   }
     * })
     * 
     */
    delete<T extends PlumberAccountProfileDeleteArgs>(args: SelectSubset<T, PlumberAccountProfileDeleteArgs<ExtArgs>>): Prisma__PlumberAccountProfileClient<$Result.GetResult<Prisma.$PlumberAccountProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlumberAccountProfile.
     * @param {PlumberAccountProfileUpdateArgs} args - Arguments to update one PlumberAccountProfile.
     * @example
     * // Update one PlumberAccountProfile
     * const plumberAccountProfile = await prisma.plumberAccountProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlumberAccountProfileUpdateArgs>(args: SelectSubset<T, PlumberAccountProfileUpdateArgs<ExtArgs>>): Prisma__PlumberAccountProfileClient<$Result.GetResult<Prisma.$PlumberAccountProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlumberAccountProfiles.
     * @param {PlumberAccountProfileDeleteManyArgs} args - Arguments to filter PlumberAccountProfiles to delete.
     * @example
     * // Delete a few PlumberAccountProfiles
     * const { count } = await prisma.plumberAccountProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlumberAccountProfileDeleteManyArgs>(args?: SelectSubset<T, PlumberAccountProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlumberAccountProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberAccountProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlumberAccountProfiles
     * const plumberAccountProfile = await prisma.plumberAccountProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlumberAccountProfileUpdateManyArgs>(args: SelectSubset<T, PlumberAccountProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlumberAccountProfile.
     * @param {PlumberAccountProfileUpsertArgs} args - Arguments to update or create a PlumberAccountProfile.
     * @example
     * // Update or create a PlumberAccountProfile
     * const plumberAccountProfile = await prisma.plumberAccountProfile.upsert({
     *   create: {
     *     // ... data to create a PlumberAccountProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlumberAccountProfile we want to update
     *   }
     * })
     */
    upsert<T extends PlumberAccountProfileUpsertArgs>(args: SelectSubset<T, PlumberAccountProfileUpsertArgs<ExtArgs>>): Prisma__PlumberAccountProfileClient<$Result.GetResult<Prisma.$PlumberAccountProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlumberAccountProfiles that matches the filter.
     * @param {PlumberAccountProfileFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const plumberAccountProfile = await prisma.plumberAccountProfile.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PlumberAccountProfileFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PlumberAccountProfile.
     * @param {PlumberAccountProfileAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const plumberAccountProfile = await prisma.plumberAccountProfile.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PlumberAccountProfileAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PlumberAccountProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberAccountProfileCountArgs} args - Arguments to filter PlumberAccountProfiles to count.
     * @example
     * // Count the number of PlumberAccountProfiles
     * const count = await prisma.plumberAccountProfile.count({
     *   where: {
     *     // ... the filter for the PlumberAccountProfiles we want to count
     *   }
     * })
    **/
    count<T extends PlumberAccountProfileCountArgs>(
      args?: Subset<T, PlumberAccountProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlumberAccountProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlumberAccountProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberAccountProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlumberAccountProfileAggregateArgs>(args: Subset<T, PlumberAccountProfileAggregateArgs>): Prisma.PrismaPromise<GetPlumberAccountProfileAggregateType<T>>

    /**
     * Group by PlumberAccountProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlumberAccountProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlumberAccountProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlumberAccountProfileGroupByArgs['orderBy'] }
        : { orderBy?: PlumberAccountProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlumberAccountProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlumberAccountProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlumberAccountProfile model
   */
  readonly fields: PlumberAccountProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlumberAccountProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlumberAccountProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlumberAccountProfile model
   */
  interface PlumberAccountProfileFieldRefs {
    readonly id: FieldRef<"PlumberAccountProfile", 'String'>
    readonly userId: FieldRef<"PlumberAccountProfile", 'String'>
    readonly fullName: FieldRef<"PlumberAccountProfile", 'String'>
    readonly contactNumber: FieldRef<"PlumberAccountProfile", 'String'>
    readonly upiId: FieldRef<"PlumberAccountProfile", 'String'>
    readonly upiQrUrl: FieldRef<"PlumberAccountProfile", 'String'>
    readonly email: FieldRef<"PlumberAccountProfile", 'String'>
    readonly bankName: FieldRef<"PlumberAccountProfile", 'String'>
    readonly accountNumber: FieldRef<"PlumberAccountProfile", 'String'>
    readonly accountHolderName: FieldRef<"PlumberAccountProfile", 'String'>
    readonly ifscCode: FieldRef<"PlumberAccountProfile", 'String'>
    readonly branchName: FieldRef<"PlumberAccountProfile", 'String'>
    readonly createdAt: FieldRef<"PlumberAccountProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"PlumberAccountProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlumberAccountProfile findUnique
   */
  export type PlumberAccountProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlumberAccountProfile
     */
    select?: PlumberAccountProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlumberAccountProfile
     */
    omit?: PlumberAccountProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberAccountProfileInclude<ExtArgs> | null
    /**
     * Filter, which PlumberAccountProfile to fetch.
     */
    where: PlumberAccountProfileWhereUniqueInput
  }

  /**
   * PlumberAccountProfile findUniqueOrThrow
   */
  export type PlumberAccountProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlumberAccountProfile
     */
    select?: PlumberAccountProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlumberAccountProfile
     */
    omit?: PlumberAccountProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberAccountProfileInclude<ExtArgs> | null
    /**
     * Filter, which PlumberAccountProfile to fetch.
     */
    where: PlumberAccountProfileWhereUniqueInput
  }

  /**
   * PlumberAccountProfile findFirst
   */
  export type PlumberAccountProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlumberAccountProfile
     */
    select?: PlumberAccountProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlumberAccountProfile
     */
    omit?: PlumberAccountProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberAccountProfileInclude<ExtArgs> | null
    /**
     * Filter, which PlumberAccountProfile to fetch.
     */
    where?: PlumberAccountProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlumberAccountProfiles to fetch.
     */
    orderBy?: PlumberAccountProfileOrderByWithRelationInput | PlumberAccountProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlumberAccountProfiles.
     */
    cursor?: PlumberAccountProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlumberAccountProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlumberAccountProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlumberAccountProfiles.
     */
    distinct?: PlumberAccountProfileScalarFieldEnum | PlumberAccountProfileScalarFieldEnum[]
  }

  /**
   * PlumberAccountProfile findFirstOrThrow
   */
  export type PlumberAccountProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlumberAccountProfile
     */
    select?: PlumberAccountProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlumberAccountProfile
     */
    omit?: PlumberAccountProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberAccountProfileInclude<ExtArgs> | null
    /**
     * Filter, which PlumberAccountProfile to fetch.
     */
    where?: PlumberAccountProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlumberAccountProfiles to fetch.
     */
    orderBy?: PlumberAccountProfileOrderByWithRelationInput | PlumberAccountProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlumberAccountProfiles.
     */
    cursor?: PlumberAccountProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlumberAccountProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlumberAccountProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlumberAccountProfiles.
     */
    distinct?: PlumberAccountProfileScalarFieldEnum | PlumberAccountProfileScalarFieldEnum[]
  }

  /**
   * PlumberAccountProfile findMany
   */
  export type PlumberAccountProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlumberAccountProfile
     */
    select?: PlumberAccountProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlumberAccountProfile
     */
    omit?: PlumberAccountProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberAccountProfileInclude<ExtArgs> | null
    /**
     * Filter, which PlumberAccountProfiles to fetch.
     */
    where?: PlumberAccountProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlumberAccountProfiles to fetch.
     */
    orderBy?: PlumberAccountProfileOrderByWithRelationInput | PlumberAccountProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlumberAccountProfiles.
     */
    cursor?: PlumberAccountProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlumberAccountProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlumberAccountProfiles.
     */
    skip?: number
    distinct?: PlumberAccountProfileScalarFieldEnum | PlumberAccountProfileScalarFieldEnum[]
  }

  /**
   * PlumberAccountProfile create
   */
  export type PlumberAccountProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlumberAccountProfile
     */
    select?: PlumberAccountProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlumberAccountProfile
     */
    omit?: PlumberAccountProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberAccountProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a PlumberAccountProfile.
     */
    data: XOR<PlumberAccountProfileCreateInput, PlumberAccountProfileUncheckedCreateInput>
  }

  /**
   * PlumberAccountProfile createMany
   */
  export type PlumberAccountProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlumberAccountProfiles.
     */
    data: PlumberAccountProfileCreateManyInput | PlumberAccountProfileCreateManyInput[]
  }

  /**
   * PlumberAccountProfile update
   */
  export type PlumberAccountProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlumberAccountProfile
     */
    select?: PlumberAccountProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlumberAccountProfile
     */
    omit?: PlumberAccountProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberAccountProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a PlumberAccountProfile.
     */
    data: XOR<PlumberAccountProfileUpdateInput, PlumberAccountProfileUncheckedUpdateInput>
    /**
     * Choose, which PlumberAccountProfile to update.
     */
    where: PlumberAccountProfileWhereUniqueInput
  }

  /**
   * PlumberAccountProfile updateMany
   */
  export type PlumberAccountProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlumberAccountProfiles.
     */
    data: XOR<PlumberAccountProfileUpdateManyMutationInput, PlumberAccountProfileUncheckedUpdateManyInput>
    /**
     * Filter which PlumberAccountProfiles to update
     */
    where?: PlumberAccountProfileWhereInput
    /**
     * Limit how many PlumberAccountProfiles to update.
     */
    limit?: number
  }

  /**
   * PlumberAccountProfile upsert
   */
  export type PlumberAccountProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlumberAccountProfile
     */
    select?: PlumberAccountProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlumberAccountProfile
     */
    omit?: PlumberAccountProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberAccountProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the PlumberAccountProfile to update in case it exists.
     */
    where: PlumberAccountProfileWhereUniqueInput
    /**
     * In case the PlumberAccountProfile found by the `where` argument doesn't exist, create a new PlumberAccountProfile with this data.
     */
    create: XOR<PlumberAccountProfileCreateInput, PlumberAccountProfileUncheckedCreateInput>
    /**
     * In case the PlumberAccountProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlumberAccountProfileUpdateInput, PlumberAccountProfileUncheckedUpdateInput>
  }

  /**
   * PlumberAccountProfile delete
   */
  export type PlumberAccountProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlumberAccountProfile
     */
    select?: PlumberAccountProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlumberAccountProfile
     */
    omit?: PlumberAccountProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberAccountProfileInclude<ExtArgs> | null
    /**
     * Filter which PlumberAccountProfile to delete.
     */
    where: PlumberAccountProfileWhereUniqueInput
  }

  /**
   * PlumberAccountProfile deleteMany
   */
  export type PlumberAccountProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlumberAccountProfiles to delete
     */
    where?: PlumberAccountProfileWhereInput
    /**
     * Limit how many PlumberAccountProfiles to delete.
     */
    limit?: number
  }

  /**
   * PlumberAccountProfile findRaw
   */
  export type PlumberAccountProfileFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PlumberAccountProfile aggregateRaw
   */
  export type PlumberAccountProfileAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PlumberAccountProfile without action
   */
  export type PlumberAccountProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlumberAccountProfile
     */
    select?: PlumberAccountProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlumberAccountProfile
     */
    omit?: PlumberAccountProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlumberAccountProfileInclude<ExtArgs> | null
  }


  /**
   * Model Accountant
   */

  export type AggregateAccountant = {
    _count: AccountantCountAggregateOutputType | null
    _min: AccountantMinAggregateOutputType | null
    _max: AccountantMaxAggregateOutputType | null
  }

  export type AccountantMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type AccountantMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type AccountantCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type AccountantMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AccountantMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AccountantCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type AccountantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accountant to aggregate.
     */
    where?: AccountantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accountants to fetch.
     */
    orderBy?: AccountantOrderByWithRelationInput | AccountantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accountants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accountants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accountants
    **/
    _count?: true | AccountantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountantMaxAggregateInputType
  }

  export type GetAccountantAggregateType<T extends AccountantAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountant[P]>
      : GetScalarType<T[P], AggregateAccountant[P]>
  }




  export type AccountantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountantWhereInput
    orderBy?: AccountantOrderByWithAggregationInput | AccountantOrderByWithAggregationInput[]
    by: AccountantScalarFieldEnum[] | AccountantScalarFieldEnum
    having?: AccountantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountantCountAggregateInputType | true
    _min?: AccountantMinAggregateInputType
    _max?: AccountantMaxAggregateInputType
  }

  export type AccountantGroupByOutputType = {
    id: string
    userId: string
    _count: AccountantCountAggregateOutputType | null
    _min: AccountantMinAggregateOutputType | null
    _max: AccountantMaxAggregateOutputType | null
  }

  type GetAccountantGroupByPayload<T extends AccountantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountantGroupByOutputType[P]>
            : GetScalarType<T[P], AccountantGroupByOutputType[P]>
        }
      >
    >


  export type AccountantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountant"]>



  export type AccountantSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type AccountantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["accountant"]>
  export type AccountantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Accountant"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["accountant"]>
    composites: {}
  }

  type AccountantGetPayload<S extends boolean | null | undefined | AccountantDefaultArgs> = $Result.GetResult<Prisma.$AccountantPayload, S>

  type AccountantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountantCountAggregateInputType | true
    }

  export interface AccountantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Accountant'], meta: { name: 'Accountant' } }
    /**
     * Find zero or one Accountant that matches the filter.
     * @param {AccountantFindUniqueArgs} args - Arguments to find a Accountant
     * @example
     * // Get one Accountant
     * const accountant = await prisma.accountant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountantFindUniqueArgs>(args: SelectSubset<T, AccountantFindUniqueArgs<ExtArgs>>): Prisma__AccountantClient<$Result.GetResult<Prisma.$AccountantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Accountant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountantFindUniqueOrThrowArgs} args - Arguments to find a Accountant
     * @example
     * // Get one Accountant
     * const accountant = await prisma.accountant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountantFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountantClient<$Result.GetResult<Prisma.$AccountantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accountant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountantFindFirstArgs} args - Arguments to find a Accountant
     * @example
     * // Get one Accountant
     * const accountant = await prisma.accountant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountantFindFirstArgs>(args?: SelectSubset<T, AccountantFindFirstArgs<ExtArgs>>): Prisma__AccountantClient<$Result.GetResult<Prisma.$AccountantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accountant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountantFindFirstOrThrowArgs} args - Arguments to find a Accountant
     * @example
     * // Get one Accountant
     * const accountant = await prisma.accountant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountantFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountantFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountantClient<$Result.GetResult<Prisma.$AccountantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accountants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accountants
     * const accountants = await prisma.accountant.findMany()
     * 
     * // Get first 10 Accountants
     * const accountants = await prisma.accountant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountantWithIdOnly = await prisma.accountant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountantFindManyArgs>(args?: SelectSubset<T, AccountantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Accountant.
     * @param {AccountantCreateArgs} args - Arguments to create a Accountant.
     * @example
     * // Create one Accountant
     * const Accountant = await prisma.accountant.create({
     *   data: {
     *     // ... data to create a Accountant
     *   }
     * })
     * 
     */
    create<T extends AccountantCreateArgs>(args: SelectSubset<T, AccountantCreateArgs<ExtArgs>>): Prisma__AccountantClient<$Result.GetResult<Prisma.$AccountantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accountants.
     * @param {AccountantCreateManyArgs} args - Arguments to create many Accountants.
     * @example
     * // Create many Accountants
     * const accountant = await prisma.accountant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountantCreateManyArgs>(args?: SelectSubset<T, AccountantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Accountant.
     * @param {AccountantDeleteArgs} args - Arguments to delete one Accountant.
     * @example
     * // Delete one Accountant
     * const Accountant = await prisma.accountant.delete({
     *   where: {
     *     // ... filter to delete one Accountant
     *   }
     * })
     * 
     */
    delete<T extends AccountantDeleteArgs>(args: SelectSubset<T, AccountantDeleteArgs<ExtArgs>>): Prisma__AccountantClient<$Result.GetResult<Prisma.$AccountantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Accountant.
     * @param {AccountantUpdateArgs} args - Arguments to update one Accountant.
     * @example
     * // Update one Accountant
     * const accountant = await prisma.accountant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountantUpdateArgs>(args: SelectSubset<T, AccountantUpdateArgs<ExtArgs>>): Prisma__AccountantClient<$Result.GetResult<Prisma.$AccountantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accountants.
     * @param {AccountantDeleteManyArgs} args - Arguments to filter Accountants to delete.
     * @example
     * // Delete a few Accountants
     * const { count } = await prisma.accountant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountantDeleteManyArgs>(args?: SelectSubset<T, AccountantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accountants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accountants
     * const accountant = await prisma.accountant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountantUpdateManyArgs>(args: SelectSubset<T, AccountantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accountant.
     * @param {AccountantUpsertArgs} args - Arguments to update or create a Accountant.
     * @example
     * // Update or create a Accountant
     * const accountant = await prisma.accountant.upsert({
     *   create: {
     *     // ... data to create a Accountant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accountant we want to update
     *   }
     * })
     */
    upsert<T extends AccountantUpsertArgs>(args: SelectSubset<T, AccountantUpsertArgs<ExtArgs>>): Prisma__AccountantClient<$Result.GetResult<Prisma.$AccountantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accountants that matches the filter.
     * @param {AccountantFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const accountant = await prisma.accountant.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AccountantFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Accountant.
     * @param {AccountantAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const accountant = await prisma.accountant.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AccountantAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Accountants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountantCountArgs} args - Arguments to filter Accountants to count.
     * @example
     * // Count the number of Accountants
     * const count = await prisma.accountant.count({
     *   where: {
     *     // ... the filter for the Accountants we want to count
     *   }
     * })
    **/
    count<T extends AccountantCountArgs>(
      args?: Subset<T, AccountantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accountant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountantAggregateArgs>(args: Subset<T, AccountantAggregateArgs>): Prisma.PrismaPromise<GetAccountantAggregateType<T>>

    /**
     * Group by Accountant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountantGroupByArgs['orderBy'] }
        : { orderBy?: AccountantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Accountant model
   */
  readonly fields: AccountantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Accountant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Accountant model
   */
  interface AccountantFieldRefs {
    readonly id: FieldRef<"Accountant", 'String'>
    readonly userId: FieldRef<"Accountant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Accountant findUnique
   */
  export type AccountantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accountant
     */
    select?: AccountantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accountant
     */
    omit?: AccountantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountantInclude<ExtArgs> | null
    /**
     * Filter, which Accountant to fetch.
     */
    where: AccountantWhereUniqueInput
  }

  /**
   * Accountant findUniqueOrThrow
   */
  export type AccountantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accountant
     */
    select?: AccountantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accountant
     */
    omit?: AccountantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountantInclude<ExtArgs> | null
    /**
     * Filter, which Accountant to fetch.
     */
    where: AccountantWhereUniqueInput
  }

  /**
   * Accountant findFirst
   */
  export type AccountantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accountant
     */
    select?: AccountantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accountant
     */
    omit?: AccountantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountantInclude<ExtArgs> | null
    /**
     * Filter, which Accountant to fetch.
     */
    where?: AccountantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accountants to fetch.
     */
    orderBy?: AccountantOrderByWithRelationInput | AccountantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accountants.
     */
    cursor?: AccountantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accountants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accountants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accountants.
     */
    distinct?: AccountantScalarFieldEnum | AccountantScalarFieldEnum[]
  }

  /**
   * Accountant findFirstOrThrow
   */
  export type AccountantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accountant
     */
    select?: AccountantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accountant
     */
    omit?: AccountantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountantInclude<ExtArgs> | null
    /**
     * Filter, which Accountant to fetch.
     */
    where?: AccountantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accountants to fetch.
     */
    orderBy?: AccountantOrderByWithRelationInput | AccountantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accountants.
     */
    cursor?: AccountantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accountants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accountants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accountants.
     */
    distinct?: AccountantScalarFieldEnum | AccountantScalarFieldEnum[]
  }

  /**
   * Accountant findMany
   */
  export type AccountantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accountant
     */
    select?: AccountantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accountant
     */
    omit?: AccountantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountantInclude<ExtArgs> | null
    /**
     * Filter, which Accountants to fetch.
     */
    where?: AccountantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accountants to fetch.
     */
    orderBy?: AccountantOrderByWithRelationInput | AccountantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accountants.
     */
    cursor?: AccountantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accountants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accountants.
     */
    skip?: number
    distinct?: AccountantScalarFieldEnum | AccountantScalarFieldEnum[]
  }

  /**
   * Accountant create
   */
  export type AccountantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accountant
     */
    select?: AccountantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accountant
     */
    omit?: AccountantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountantInclude<ExtArgs> | null
    /**
     * The data needed to create a Accountant.
     */
    data: XOR<AccountantCreateInput, AccountantUncheckedCreateInput>
  }

  /**
   * Accountant createMany
   */
  export type AccountantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accountants.
     */
    data: AccountantCreateManyInput | AccountantCreateManyInput[]
  }

  /**
   * Accountant update
   */
  export type AccountantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accountant
     */
    select?: AccountantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accountant
     */
    omit?: AccountantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountantInclude<ExtArgs> | null
    /**
     * The data needed to update a Accountant.
     */
    data: XOR<AccountantUpdateInput, AccountantUncheckedUpdateInput>
    /**
     * Choose, which Accountant to update.
     */
    where: AccountantWhereUniqueInput
  }

  /**
   * Accountant updateMany
   */
  export type AccountantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accountants.
     */
    data: XOR<AccountantUpdateManyMutationInput, AccountantUncheckedUpdateManyInput>
    /**
     * Filter which Accountants to update
     */
    where?: AccountantWhereInput
    /**
     * Limit how many Accountants to update.
     */
    limit?: number
  }

  /**
   * Accountant upsert
   */
  export type AccountantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accountant
     */
    select?: AccountantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accountant
     */
    omit?: AccountantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountantInclude<ExtArgs> | null
    /**
     * The filter to search for the Accountant to update in case it exists.
     */
    where: AccountantWhereUniqueInput
    /**
     * In case the Accountant found by the `where` argument doesn't exist, create a new Accountant with this data.
     */
    create: XOR<AccountantCreateInput, AccountantUncheckedCreateInput>
    /**
     * In case the Accountant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountantUpdateInput, AccountantUncheckedUpdateInput>
  }

  /**
   * Accountant delete
   */
  export type AccountantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accountant
     */
    select?: AccountantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accountant
     */
    omit?: AccountantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountantInclude<ExtArgs> | null
    /**
     * Filter which Accountant to delete.
     */
    where: AccountantWhereUniqueInput
  }

  /**
   * Accountant deleteMany
   */
  export type AccountantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accountants to delete
     */
    where?: AccountantWhereInput
    /**
     * Limit how many Accountants to delete.
     */
    limit?: number
  }

  /**
   * Accountant findRaw
   */
  export type AccountantFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Accountant aggregateRaw
   */
  export type AccountantAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Accountant without action
   */
  export type AccountantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accountant
     */
    select?: AccountantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accountant
     */
    omit?: AccountantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountantInclude<ExtArgs> | null
  }


  /**
   * Model Distributor
   */

  export type AggregateDistributor = {
    _count: DistributorCountAggregateOutputType | null
    _min: DistributorMinAggregateOutputType | null
    _max: DistributorMaxAggregateOutputType | null
  }

  export type DistributorMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type DistributorMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type DistributorCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type DistributorMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DistributorMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DistributorCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type DistributorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Distributor to aggregate.
     */
    where?: DistributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distributors to fetch.
     */
    orderBy?: DistributorOrderByWithRelationInput | DistributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Distributors
    **/
    _count?: true | DistributorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistributorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistributorMaxAggregateInputType
  }

  export type GetDistributorAggregateType<T extends DistributorAggregateArgs> = {
        [P in keyof T & keyof AggregateDistributor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistributor[P]>
      : GetScalarType<T[P], AggregateDistributor[P]>
  }




  export type DistributorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistributorWhereInput
    orderBy?: DistributorOrderByWithAggregationInput | DistributorOrderByWithAggregationInput[]
    by: DistributorScalarFieldEnum[] | DistributorScalarFieldEnum
    having?: DistributorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistributorCountAggregateInputType | true
    _min?: DistributorMinAggregateInputType
    _max?: DistributorMaxAggregateInputType
  }

  export type DistributorGroupByOutputType = {
    id: string
    userId: string
    _count: DistributorCountAggregateOutputType | null
    _min: DistributorMinAggregateOutputType | null
    _max: DistributorMaxAggregateOutputType | null
  }

  type GetDistributorGroupByPayload<T extends DistributorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistributorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistributorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistributorGroupByOutputType[P]>
            : GetScalarType<T[P], DistributorGroupByOutputType[P]>
        }
      >
    >


  export type DistributorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["distributor"]>



  export type DistributorSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type DistributorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["distributor"]>
  export type DistributorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DistributorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Distributor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["distributor"]>
    composites: {}
  }

  type DistributorGetPayload<S extends boolean | null | undefined | DistributorDefaultArgs> = $Result.GetResult<Prisma.$DistributorPayload, S>

  type DistributorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DistributorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DistributorCountAggregateInputType | true
    }

  export interface DistributorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Distributor'], meta: { name: 'Distributor' } }
    /**
     * Find zero or one Distributor that matches the filter.
     * @param {DistributorFindUniqueArgs} args - Arguments to find a Distributor
     * @example
     * // Get one Distributor
     * const distributor = await prisma.distributor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistributorFindUniqueArgs>(args: SelectSubset<T, DistributorFindUniqueArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Distributor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DistributorFindUniqueOrThrowArgs} args - Arguments to find a Distributor
     * @example
     * // Get one Distributor
     * const distributor = await prisma.distributor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistributorFindUniqueOrThrowArgs>(args: SelectSubset<T, DistributorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Distributor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorFindFirstArgs} args - Arguments to find a Distributor
     * @example
     * // Get one Distributor
     * const distributor = await prisma.distributor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistributorFindFirstArgs>(args?: SelectSubset<T, DistributorFindFirstArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Distributor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorFindFirstOrThrowArgs} args - Arguments to find a Distributor
     * @example
     * // Get one Distributor
     * const distributor = await prisma.distributor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistributorFindFirstOrThrowArgs>(args?: SelectSubset<T, DistributorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Distributors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Distributors
     * const distributors = await prisma.distributor.findMany()
     * 
     * // Get first 10 Distributors
     * const distributors = await prisma.distributor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const distributorWithIdOnly = await prisma.distributor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DistributorFindManyArgs>(args?: SelectSubset<T, DistributorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Distributor.
     * @param {DistributorCreateArgs} args - Arguments to create a Distributor.
     * @example
     * // Create one Distributor
     * const Distributor = await prisma.distributor.create({
     *   data: {
     *     // ... data to create a Distributor
     *   }
     * })
     * 
     */
    create<T extends DistributorCreateArgs>(args: SelectSubset<T, DistributorCreateArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Distributors.
     * @param {DistributorCreateManyArgs} args - Arguments to create many Distributors.
     * @example
     * // Create many Distributors
     * const distributor = await prisma.distributor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistributorCreateManyArgs>(args?: SelectSubset<T, DistributorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Distributor.
     * @param {DistributorDeleteArgs} args - Arguments to delete one Distributor.
     * @example
     * // Delete one Distributor
     * const Distributor = await prisma.distributor.delete({
     *   where: {
     *     // ... filter to delete one Distributor
     *   }
     * })
     * 
     */
    delete<T extends DistributorDeleteArgs>(args: SelectSubset<T, DistributorDeleteArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Distributor.
     * @param {DistributorUpdateArgs} args - Arguments to update one Distributor.
     * @example
     * // Update one Distributor
     * const distributor = await prisma.distributor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistributorUpdateArgs>(args: SelectSubset<T, DistributorUpdateArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Distributors.
     * @param {DistributorDeleteManyArgs} args - Arguments to filter Distributors to delete.
     * @example
     * // Delete a few Distributors
     * const { count } = await prisma.distributor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistributorDeleteManyArgs>(args?: SelectSubset<T, DistributorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Distributors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Distributors
     * const distributor = await prisma.distributor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistributorUpdateManyArgs>(args: SelectSubset<T, DistributorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Distributor.
     * @param {DistributorUpsertArgs} args - Arguments to update or create a Distributor.
     * @example
     * // Update or create a Distributor
     * const distributor = await prisma.distributor.upsert({
     *   create: {
     *     // ... data to create a Distributor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Distributor we want to update
     *   }
     * })
     */
    upsert<T extends DistributorUpsertArgs>(args: SelectSubset<T, DistributorUpsertArgs<ExtArgs>>): Prisma__DistributorClient<$Result.GetResult<Prisma.$DistributorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Distributors that matches the filter.
     * @param {DistributorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const distributor = await prisma.distributor.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DistributorFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Distributor.
     * @param {DistributorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const distributor = await prisma.distributor.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DistributorAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Distributors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorCountArgs} args - Arguments to filter Distributors to count.
     * @example
     * // Count the number of Distributors
     * const count = await prisma.distributor.count({
     *   where: {
     *     // ... the filter for the Distributors we want to count
     *   }
     * })
    **/
    count<T extends DistributorCountArgs>(
      args?: Subset<T, DistributorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistributorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Distributor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistributorAggregateArgs>(args: Subset<T, DistributorAggregateArgs>): Prisma.PrismaPromise<GetDistributorAggregateType<T>>

    /**
     * Group by Distributor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistributorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistributorGroupByArgs['orderBy'] }
        : { orderBy?: DistributorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistributorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistributorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Distributor model
   */
  readonly fields: DistributorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Distributor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistributorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Distributor model
   */
  interface DistributorFieldRefs {
    readonly id: FieldRef<"Distributor", 'String'>
    readonly userId: FieldRef<"Distributor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Distributor findUnique
   */
  export type DistributorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distributor
     */
    omit?: DistributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributor to fetch.
     */
    where: DistributorWhereUniqueInput
  }

  /**
   * Distributor findUniqueOrThrow
   */
  export type DistributorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distributor
     */
    omit?: DistributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributor to fetch.
     */
    where: DistributorWhereUniqueInput
  }

  /**
   * Distributor findFirst
   */
  export type DistributorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distributor
     */
    omit?: DistributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributor to fetch.
     */
    where?: DistributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distributors to fetch.
     */
    orderBy?: DistributorOrderByWithRelationInput | DistributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Distributors.
     */
    cursor?: DistributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Distributors.
     */
    distinct?: DistributorScalarFieldEnum | DistributorScalarFieldEnum[]
  }

  /**
   * Distributor findFirstOrThrow
   */
  export type DistributorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distributor
     */
    omit?: DistributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributor to fetch.
     */
    where?: DistributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distributors to fetch.
     */
    orderBy?: DistributorOrderByWithRelationInput | DistributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Distributors.
     */
    cursor?: DistributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Distributors.
     */
    distinct?: DistributorScalarFieldEnum | DistributorScalarFieldEnum[]
  }

  /**
   * Distributor findMany
   */
  export type DistributorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distributor
     */
    omit?: DistributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributors to fetch.
     */
    where?: DistributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distributors to fetch.
     */
    orderBy?: DistributorOrderByWithRelationInput | DistributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Distributors.
     */
    cursor?: DistributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distributors.
     */
    skip?: number
    distinct?: DistributorScalarFieldEnum | DistributorScalarFieldEnum[]
  }

  /**
   * Distributor create
   */
  export type DistributorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distributor
     */
    omit?: DistributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * The data needed to create a Distributor.
     */
    data: XOR<DistributorCreateInput, DistributorUncheckedCreateInput>
  }

  /**
   * Distributor createMany
   */
  export type DistributorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Distributors.
     */
    data: DistributorCreateManyInput | DistributorCreateManyInput[]
  }

  /**
   * Distributor update
   */
  export type DistributorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distributor
     */
    omit?: DistributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * The data needed to update a Distributor.
     */
    data: XOR<DistributorUpdateInput, DistributorUncheckedUpdateInput>
    /**
     * Choose, which Distributor to update.
     */
    where: DistributorWhereUniqueInput
  }

  /**
   * Distributor updateMany
   */
  export type DistributorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Distributors.
     */
    data: XOR<DistributorUpdateManyMutationInput, DistributorUncheckedUpdateManyInput>
    /**
     * Filter which Distributors to update
     */
    where?: DistributorWhereInput
    /**
     * Limit how many Distributors to update.
     */
    limit?: number
  }

  /**
   * Distributor upsert
   */
  export type DistributorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distributor
     */
    omit?: DistributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * The filter to search for the Distributor to update in case it exists.
     */
    where: DistributorWhereUniqueInput
    /**
     * In case the Distributor found by the `where` argument doesn't exist, create a new Distributor with this data.
     */
    create: XOR<DistributorCreateInput, DistributorUncheckedCreateInput>
    /**
     * In case the Distributor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistributorUpdateInput, DistributorUncheckedUpdateInput>
  }

  /**
   * Distributor delete
   */
  export type DistributorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distributor
     */
    omit?: DistributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter which Distributor to delete.
     */
    where: DistributorWhereUniqueInput
  }

  /**
   * Distributor deleteMany
   */
  export type DistributorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Distributors to delete
     */
    where?: DistributorWhereInput
    /**
     * Limit how many Distributors to delete.
     */
    limit?: number
  }

  /**
   * Distributor findRaw
   */
  export type DistributorFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Distributor aggregateRaw
   */
  export type DistributorAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Distributor without action
   */
  export type DistributorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distributor
     */
    omit?: DistributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributorInclude<ExtArgs> | null
  }


  /**
   * Model FieldExecutive
   */

  export type AggregateFieldExecutive = {
    _count: FieldExecutiveCountAggregateOutputType | null
    _min: FieldExecutiveMinAggregateOutputType | null
    _max: FieldExecutiveMaxAggregateOutputType | null
  }

  export type FieldExecutiveMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type FieldExecutiveMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type FieldExecutiveCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type FieldExecutiveMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FieldExecutiveMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FieldExecutiveCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type FieldExecutiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldExecutive to aggregate.
     */
    where?: FieldExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldExecutives to fetch.
     */
    orderBy?: FieldExecutiveOrderByWithRelationInput | FieldExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldExecutives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldExecutives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FieldExecutives
    **/
    _count?: true | FieldExecutiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldExecutiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldExecutiveMaxAggregateInputType
  }

  export type GetFieldExecutiveAggregateType<T extends FieldExecutiveAggregateArgs> = {
        [P in keyof T & keyof AggregateFieldExecutive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFieldExecutive[P]>
      : GetScalarType<T[P], AggregateFieldExecutive[P]>
  }




  export type FieldExecutiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldExecutiveWhereInput
    orderBy?: FieldExecutiveOrderByWithAggregationInput | FieldExecutiveOrderByWithAggregationInput[]
    by: FieldExecutiveScalarFieldEnum[] | FieldExecutiveScalarFieldEnum
    having?: FieldExecutiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldExecutiveCountAggregateInputType | true
    _min?: FieldExecutiveMinAggregateInputType
    _max?: FieldExecutiveMaxAggregateInputType
  }

  export type FieldExecutiveGroupByOutputType = {
    id: string
    userId: string
    _count: FieldExecutiveCountAggregateOutputType | null
    _min: FieldExecutiveMinAggregateOutputType | null
    _max: FieldExecutiveMaxAggregateOutputType | null
  }

  type GetFieldExecutiveGroupByPayload<T extends FieldExecutiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldExecutiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldExecutiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldExecutiveGroupByOutputType[P]>
            : GetScalarType<T[P], FieldExecutiveGroupByOutputType[P]>
        }
      >
    >


  export type FieldExecutiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    followUps?: boolean | FieldExecutive$followUpsArgs<ExtArgs>
    dvrReports?: boolean | FieldExecutive$dvrReportsArgs<ExtArgs>
    _count?: boolean | FieldExecutiveCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldExecutive"]>



  export type FieldExecutiveSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type FieldExecutiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["fieldExecutive"]>
  export type FieldExecutiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    followUps?: boolean | FieldExecutive$followUpsArgs<ExtArgs>
    dvrReports?: boolean | FieldExecutive$dvrReportsArgs<ExtArgs>
    _count?: boolean | FieldExecutiveCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FieldExecutivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FieldExecutive"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      followUps: Prisma.$CustomerFollowUpPayload<ExtArgs>[]
      dvrReports: Prisma.$DVRPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["fieldExecutive"]>
    composites: {}
  }

  type FieldExecutiveGetPayload<S extends boolean | null | undefined | FieldExecutiveDefaultArgs> = $Result.GetResult<Prisma.$FieldExecutivePayload, S>

  type FieldExecutiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldExecutiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldExecutiveCountAggregateInputType | true
    }

  export interface FieldExecutiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FieldExecutive'], meta: { name: 'FieldExecutive' } }
    /**
     * Find zero or one FieldExecutive that matches the filter.
     * @param {FieldExecutiveFindUniqueArgs} args - Arguments to find a FieldExecutive
     * @example
     * // Get one FieldExecutive
     * const fieldExecutive = await prisma.fieldExecutive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldExecutiveFindUniqueArgs>(args: SelectSubset<T, FieldExecutiveFindUniqueArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FieldExecutive that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldExecutiveFindUniqueOrThrowArgs} args - Arguments to find a FieldExecutive
     * @example
     * // Get one FieldExecutive
     * const fieldExecutive = await prisma.fieldExecutive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldExecutiveFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldExecutiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldExecutive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveFindFirstArgs} args - Arguments to find a FieldExecutive
     * @example
     * // Get one FieldExecutive
     * const fieldExecutive = await prisma.fieldExecutive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldExecutiveFindFirstArgs>(args?: SelectSubset<T, FieldExecutiveFindFirstArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldExecutive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveFindFirstOrThrowArgs} args - Arguments to find a FieldExecutive
     * @example
     * // Get one FieldExecutive
     * const fieldExecutive = await prisma.fieldExecutive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldExecutiveFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldExecutiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldExecutives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FieldExecutives
     * const fieldExecutives = await prisma.fieldExecutive.findMany()
     * 
     * // Get first 10 FieldExecutives
     * const fieldExecutives = await prisma.fieldExecutive.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldExecutiveWithIdOnly = await prisma.fieldExecutive.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FieldExecutiveFindManyArgs>(args?: SelectSubset<T, FieldExecutiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FieldExecutive.
     * @param {FieldExecutiveCreateArgs} args - Arguments to create a FieldExecutive.
     * @example
     * // Create one FieldExecutive
     * const FieldExecutive = await prisma.fieldExecutive.create({
     *   data: {
     *     // ... data to create a FieldExecutive
     *   }
     * })
     * 
     */
    create<T extends FieldExecutiveCreateArgs>(args: SelectSubset<T, FieldExecutiveCreateArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FieldExecutives.
     * @param {FieldExecutiveCreateManyArgs} args - Arguments to create many FieldExecutives.
     * @example
     * // Create many FieldExecutives
     * const fieldExecutive = await prisma.fieldExecutive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldExecutiveCreateManyArgs>(args?: SelectSubset<T, FieldExecutiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FieldExecutive.
     * @param {FieldExecutiveDeleteArgs} args - Arguments to delete one FieldExecutive.
     * @example
     * // Delete one FieldExecutive
     * const FieldExecutive = await prisma.fieldExecutive.delete({
     *   where: {
     *     // ... filter to delete one FieldExecutive
     *   }
     * })
     * 
     */
    delete<T extends FieldExecutiveDeleteArgs>(args: SelectSubset<T, FieldExecutiveDeleteArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FieldExecutive.
     * @param {FieldExecutiveUpdateArgs} args - Arguments to update one FieldExecutive.
     * @example
     * // Update one FieldExecutive
     * const fieldExecutive = await prisma.fieldExecutive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldExecutiveUpdateArgs>(args: SelectSubset<T, FieldExecutiveUpdateArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FieldExecutives.
     * @param {FieldExecutiveDeleteManyArgs} args - Arguments to filter FieldExecutives to delete.
     * @example
     * // Delete a few FieldExecutives
     * const { count } = await prisma.fieldExecutive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldExecutiveDeleteManyArgs>(args?: SelectSubset<T, FieldExecutiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldExecutives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FieldExecutives
     * const fieldExecutive = await prisma.fieldExecutive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldExecutiveUpdateManyArgs>(args: SelectSubset<T, FieldExecutiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FieldExecutive.
     * @param {FieldExecutiveUpsertArgs} args - Arguments to update or create a FieldExecutive.
     * @example
     * // Update or create a FieldExecutive
     * const fieldExecutive = await prisma.fieldExecutive.upsert({
     *   create: {
     *     // ... data to create a FieldExecutive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FieldExecutive we want to update
     *   }
     * })
     */
    upsert<T extends FieldExecutiveUpsertArgs>(args: SelectSubset<T, FieldExecutiveUpsertArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldExecutives that matches the filter.
     * @param {FieldExecutiveFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const fieldExecutive = await prisma.fieldExecutive.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FieldExecutiveFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FieldExecutive.
     * @param {FieldExecutiveAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const fieldExecutive = await prisma.fieldExecutive.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FieldExecutiveAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FieldExecutives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveCountArgs} args - Arguments to filter FieldExecutives to count.
     * @example
     * // Count the number of FieldExecutives
     * const count = await prisma.fieldExecutive.count({
     *   where: {
     *     // ... the filter for the FieldExecutives we want to count
     *   }
     * })
    **/
    count<T extends FieldExecutiveCountArgs>(
      args?: Subset<T, FieldExecutiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldExecutiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FieldExecutive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldExecutiveAggregateArgs>(args: Subset<T, FieldExecutiveAggregateArgs>): Prisma.PrismaPromise<GetFieldExecutiveAggregateType<T>>

    /**
     * Group by FieldExecutive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldExecutiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldExecutiveGroupByArgs['orderBy'] }
        : { orderBy?: FieldExecutiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldExecutiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldExecutiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FieldExecutive model
   */
  readonly fields: FieldExecutiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FieldExecutive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldExecutiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    followUps<T extends FieldExecutive$followUpsArgs<ExtArgs> = {}>(args?: Subset<T, FieldExecutive$followUpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerFollowUpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dvrReports<T extends FieldExecutive$dvrReportsArgs<ExtArgs> = {}>(args?: Subset<T, FieldExecutive$dvrReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DVRPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FieldExecutive model
   */
  interface FieldExecutiveFieldRefs {
    readonly id: FieldRef<"FieldExecutive", 'String'>
    readonly userId: FieldRef<"FieldExecutive", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FieldExecutive findUnique
   */
  export type FieldExecutiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which FieldExecutive to fetch.
     */
    where: FieldExecutiveWhereUniqueInput
  }

  /**
   * FieldExecutive findUniqueOrThrow
   */
  export type FieldExecutiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which FieldExecutive to fetch.
     */
    where: FieldExecutiveWhereUniqueInput
  }

  /**
   * FieldExecutive findFirst
   */
  export type FieldExecutiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which FieldExecutive to fetch.
     */
    where?: FieldExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldExecutives to fetch.
     */
    orderBy?: FieldExecutiveOrderByWithRelationInput | FieldExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldExecutives.
     */
    cursor?: FieldExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldExecutives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldExecutives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldExecutives.
     */
    distinct?: FieldExecutiveScalarFieldEnum | FieldExecutiveScalarFieldEnum[]
  }

  /**
   * FieldExecutive findFirstOrThrow
   */
  export type FieldExecutiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which FieldExecutive to fetch.
     */
    where?: FieldExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldExecutives to fetch.
     */
    orderBy?: FieldExecutiveOrderByWithRelationInput | FieldExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldExecutives.
     */
    cursor?: FieldExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldExecutives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldExecutives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldExecutives.
     */
    distinct?: FieldExecutiveScalarFieldEnum | FieldExecutiveScalarFieldEnum[]
  }

  /**
   * FieldExecutive findMany
   */
  export type FieldExecutiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which FieldExecutives to fetch.
     */
    where?: FieldExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldExecutives to fetch.
     */
    orderBy?: FieldExecutiveOrderByWithRelationInput | FieldExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FieldExecutives.
     */
    cursor?: FieldExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldExecutives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldExecutives.
     */
    skip?: number
    distinct?: FieldExecutiveScalarFieldEnum | FieldExecutiveScalarFieldEnum[]
  }

  /**
   * FieldExecutive create
   */
  export type FieldExecutiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * The data needed to create a FieldExecutive.
     */
    data: XOR<FieldExecutiveCreateInput, FieldExecutiveUncheckedCreateInput>
  }

  /**
   * FieldExecutive createMany
   */
  export type FieldExecutiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FieldExecutives.
     */
    data: FieldExecutiveCreateManyInput | FieldExecutiveCreateManyInput[]
  }

  /**
   * FieldExecutive update
   */
  export type FieldExecutiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * The data needed to update a FieldExecutive.
     */
    data: XOR<FieldExecutiveUpdateInput, FieldExecutiveUncheckedUpdateInput>
    /**
     * Choose, which FieldExecutive to update.
     */
    where: FieldExecutiveWhereUniqueInput
  }

  /**
   * FieldExecutive updateMany
   */
  export type FieldExecutiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FieldExecutives.
     */
    data: XOR<FieldExecutiveUpdateManyMutationInput, FieldExecutiveUncheckedUpdateManyInput>
    /**
     * Filter which FieldExecutives to update
     */
    where?: FieldExecutiveWhereInput
    /**
     * Limit how many FieldExecutives to update.
     */
    limit?: number
  }

  /**
   * FieldExecutive upsert
   */
  export type FieldExecutiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * The filter to search for the FieldExecutive to update in case it exists.
     */
    where: FieldExecutiveWhereUniqueInput
    /**
     * In case the FieldExecutive found by the `where` argument doesn't exist, create a new FieldExecutive with this data.
     */
    create: XOR<FieldExecutiveCreateInput, FieldExecutiveUncheckedCreateInput>
    /**
     * In case the FieldExecutive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldExecutiveUpdateInput, FieldExecutiveUncheckedUpdateInput>
  }

  /**
   * FieldExecutive delete
   */
  export type FieldExecutiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * Filter which FieldExecutive to delete.
     */
    where: FieldExecutiveWhereUniqueInput
  }

  /**
   * FieldExecutive deleteMany
   */
  export type FieldExecutiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldExecutives to delete
     */
    where?: FieldExecutiveWhereInput
    /**
     * Limit how many FieldExecutives to delete.
     */
    limit?: number
  }

  /**
   * FieldExecutive findRaw
   */
  export type FieldExecutiveFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FieldExecutive aggregateRaw
   */
  export type FieldExecutiveAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FieldExecutive.followUps
   */
  export type FieldExecutive$followUpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFollowUp
     */
    select?: CustomerFollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFollowUp
     */
    omit?: CustomerFollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFollowUpInclude<ExtArgs> | null
    where?: CustomerFollowUpWhereInput
    orderBy?: CustomerFollowUpOrderByWithRelationInput | CustomerFollowUpOrderByWithRelationInput[]
    cursor?: CustomerFollowUpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerFollowUpScalarFieldEnum | CustomerFollowUpScalarFieldEnum[]
  }

  /**
   * FieldExecutive.dvrReports
   */
  export type FieldExecutive$dvrReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DVR
     */
    select?: DVRSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DVR
     */
    omit?: DVROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DVRInclude<ExtArgs> | null
    where?: DVRWhereInput
    orderBy?: DVROrderByWithRelationInput | DVROrderByWithRelationInput[]
    cursor?: DVRWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DVRScalarFieldEnum | DVRScalarFieldEnum[]
  }

  /**
   * FieldExecutive without action
   */
  export type FieldExecutiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
  }


  /**
   * Model Worker
   */

  export type AggregateWorker = {
    _count: WorkerCountAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  export type WorkerMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type WorkerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type WorkerCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type WorkerMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type WorkerMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type WorkerCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type WorkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Worker to aggregate.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workers
    **/
    _count?: true | WorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerMaxAggregateInputType
  }

  export type GetWorkerAggregateType<T extends WorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorker[P]>
      : GetScalarType<T[P], AggregateWorker[P]>
  }




  export type WorkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithAggregationInput | WorkerOrderByWithAggregationInput[]
    by: WorkerScalarFieldEnum[] | WorkerScalarFieldEnum
    having?: WorkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerCountAggregateInputType | true
    _min?: WorkerMinAggregateInputType
    _max?: WorkerMaxAggregateInputType
  }

  export type WorkerGroupByOutputType = {
    id: string
    userId: string
    _count: WorkerCountAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  type GetWorkerGroupByPayload<T extends WorkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerGroupByOutputType[P]>
        }
      >
    >


  export type WorkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>



  export type WorkerSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type WorkerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["worker"]>
  export type WorkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Worker"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["worker"]>
    composites: {}
  }

  type WorkerGetPayload<S extends boolean | null | undefined | WorkerDefaultArgs> = $Result.GetResult<Prisma.$WorkerPayload, S>

  type WorkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkerCountAggregateInputType | true
    }

  export interface WorkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Worker'], meta: { name: 'Worker' } }
    /**
     * Find zero or one Worker that matches the filter.
     * @param {WorkerFindUniqueArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerFindUniqueArgs>(args: SelectSubset<T, WorkerFindUniqueArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Worker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkerFindUniqueOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Worker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerFindFirstArgs>(args?: SelectSubset<T, WorkerFindFirstArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Worker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workers
     * const workers = await prisma.worker.findMany()
     * 
     * // Get first 10 Workers
     * const workers = await prisma.worker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerWithIdOnly = await prisma.worker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerFindManyArgs>(args?: SelectSubset<T, WorkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Worker.
     * @param {WorkerCreateArgs} args - Arguments to create a Worker.
     * @example
     * // Create one Worker
     * const Worker = await prisma.worker.create({
     *   data: {
     *     // ... data to create a Worker
     *   }
     * })
     * 
     */
    create<T extends WorkerCreateArgs>(args: SelectSubset<T, WorkerCreateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workers.
     * @param {WorkerCreateManyArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerCreateManyArgs>(args?: SelectSubset<T, WorkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Worker.
     * @param {WorkerDeleteArgs} args - Arguments to delete one Worker.
     * @example
     * // Delete one Worker
     * const Worker = await prisma.worker.delete({
     *   where: {
     *     // ... filter to delete one Worker
     *   }
     * })
     * 
     */
    delete<T extends WorkerDeleteArgs>(args: SelectSubset<T, WorkerDeleteArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Worker.
     * @param {WorkerUpdateArgs} args - Arguments to update one Worker.
     * @example
     * // Update one Worker
     * const worker = await prisma.worker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerUpdateArgs>(args: SelectSubset<T, WorkerUpdateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workers.
     * @param {WorkerDeleteManyArgs} args - Arguments to filter Workers to delete.
     * @example
     * // Delete a few Workers
     * const { count } = await prisma.worker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerDeleteManyArgs>(args?: SelectSubset<T, WorkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workers
     * const worker = await prisma.worker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerUpdateManyArgs>(args: SelectSubset<T, WorkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Worker.
     * @param {WorkerUpsertArgs} args - Arguments to update or create a Worker.
     * @example
     * // Update or create a Worker
     * const worker = await prisma.worker.upsert({
     *   create: {
     *     // ... data to create a Worker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Worker we want to update
     *   }
     * })
     */
    upsert<T extends WorkerUpsertArgs>(args: SelectSubset<T, WorkerUpsertArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workers that matches the filter.
     * @param {WorkerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const worker = await prisma.worker.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: WorkerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Worker.
     * @param {WorkerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const worker = await prisma.worker.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: WorkerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerCountArgs} args - Arguments to filter Workers to count.
     * @example
     * // Count the number of Workers
     * const count = await prisma.worker.count({
     *   where: {
     *     // ... the filter for the Workers we want to count
     *   }
     * })
    **/
    count<T extends WorkerCountArgs>(
      args?: Subset<T, WorkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerAggregateArgs>(args: Subset<T, WorkerAggregateArgs>): Prisma.PrismaPromise<GetWorkerAggregateType<T>>

    /**
     * Group by Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerGroupByArgs['orderBy'] }
        : { orderBy?: WorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Worker model
   */
  readonly fields: WorkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Worker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Worker model
   */
  interface WorkerFieldRefs {
    readonly id: FieldRef<"Worker", 'String'>
    readonly userId: FieldRef<"Worker", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Worker findUnique
   */
  export type WorkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findUniqueOrThrow
   */
  export type WorkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findFirst
   */
  export type WorkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findFirstOrThrow
   */
  export type WorkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findMany
   */
  export type WorkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Workers to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker create
   */
  export type WorkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to create a Worker.
     */
    data: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
  }

  /**
   * Worker createMany
   */
  export type WorkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
  }

  /**
   * Worker update
   */
  export type WorkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to update a Worker.
     */
    data: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
    /**
     * Choose, which Worker to update.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker updateMany
   */
  export type WorkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workers.
     */
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyInput>
    /**
     * Filter which Workers to update
     */
    where?: WorkerWhereInput
    /**
     * Limit how many Workers to update.
     */
    limit?: number
  }

  /**
   * Worker upsert
   */
  export type WorkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The filter to search for the Worker to update in case it exists.
     */
    where: WorkerWhereUniqueInput
    /**
     * In case the Worker found by the `where` argument doesn't exist, create a new Worker with this data.
     */
    create: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
    /**
     * In case the Worker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
  }

  /**
   * Worker delete
   */
  export type WorkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter which Worker to delete.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker deleteMany
   */
  export type WorkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workers to delete
     */
    where?: WorkerWhereInput
    /**
     * Limit how many Workers to delete.
     */
    limit?: number
  }

  /**
   * Worker findRaw
   */
  export type WorkerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Worker aggregateRaw
   */
  export type WorkerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Worker without action
   */
  export type WorkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
    stockQuantity: number | null
    warrantyPeriodInMonths: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
    stockQuantity: number | null
    warrantyPeriodInMonths: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    stockQuantity: number | null
    warrantyPeriodInMonths: number | null
    categoryId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    stockQuantity: number | null
    warrantyPeriodInMonths: number | null
    categoryId: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    categoryId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    stockQuantity?: true
    warrantyPeriodInMonths?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    stockQuantity?: true
    warrantyPeriodInMonths?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    stockQuantity?: true
    warrantyPeriodInMonths?: true
    categoryId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    stockQuantity?: true
    warrantyPeriodInMonths?: true
    categoryId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    stockQuantity?: true
    warrantyPeriodInMonths?: true
    categoryId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    categoryId: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    stockQuantity?: boolean
    warrantyPeriodInMonths?: boolean
    categoryId?: boolean
    stocks?: boolean | Product$stocksArgs<ExtArgs>
    warrantyCards?: boolean | Product$warrantyCardsArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    registeredWarranties?: boolean | Product$registeredWarrantiesArgs<ExtArgs>
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>



  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    stockQuantity?: boolean
    warrantyPeriodInMonths?: boolean
    categoryId?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "stockQuantity" | "warrantyPeriodInMonths" | "categoryId", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | Product$stocksArgs<ExtArgs>
    warrantyCards?: boolean | Product$warrantyCardsArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    registeredWarranties?: boolean | Product$registeredWarrantiesArgs<ExtArgs>
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      stocks: Prisma.$StockPayload<ExtArgs>[]
      warrantyCards: Prisma.$WarrantyCardPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      registeredWarranties: Prisma.$RegisterWarrantyPayload<ExtArgs>[]
      cartItems: Prisma.$CartItemPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: number
      stockQuantity: number
      warrantyPeriodInMonths: number
      categoryId: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * @param {ProductFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const product = await prisma.product.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProductFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Product.
     * @param {ProductAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const product = await prisma.product.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProductAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stocks<T extends Product$stocksArgs<ExtArgs> = {}>(args?: Subset<T, Product$stocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warrantyCards<T extends Product$warrantyCardsArgs<ExtArgs> = {}>(args?: Subset<T, Product$warrantyCardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarrantyCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    registeredWarranties<T extends Product$registeredWarrantiesArgs<ExtArgs> = {}>(args?: Subset<T, Product$registeredWarrantiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisterWarrantyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cartItems<T extends Product$cartItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$cartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly stockQuantity: FieldRef<"Product", 'Int'>
    readonly warrantyPeriodInMonths: FieldRef<"Product", 'Int'>
    readonly categoryId: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product findRaw
   */
  export type ProductFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Product aggregateRaw
   */
  export type ProductAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Product.stocks
   */
  export type Product$stocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    cursor?: StockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Product.warrantyCards
   */
  export type Product$warrantyCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarrantyCard
     */
    select?: WarrantyCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarrantyCard
     */
    omit?: WarrantyCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarrantyCardInclude<ExtArgs> | null
    where?: WarrantyCardWhereInput
    orderBy?: WarrantyCardOrderByWithRelationInput | WarrantyCardOrderByWithRelationInput[]
    cursor?: WarrantyCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarrantyCardScalarFieldEnum | WarrantyCardScalarFieldEnum[]
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.registeredWarranties
   */
  export type Product$registeredWarrantiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterWarranty
     */
    select?: RegisterWarrantySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterWarranty
     */
    omit?: RegisterWarrantyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisterWarrantyInclude<ExtArgs> | null
    where?: RegisterWarrantyWhereInput
    orderBy?: RegisterWarrantyOrderByWithRelationInput | RegisterWarrantyOrderByWithRelationInput[]
    cursor?: RegisterWarrantyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegisterWarrantyScalarFieldEnum | RegisterWarrantyScalarFieldEnum[]
  }

  /**
   * Product.cartItems
   */
  export type Product$cartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Stock
   */

  export type AggregateStock = {
    _count: StockCountAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  export type StockMinAggregateOutputType = {
    id: string | null
    productId: string | null
    status: $Enums.StockStatus | null
    location: string | null
  }

  export type StockMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    status: $Enums.StockStatus | null
    location: string | null
  }

  export type StockCountAggregateOutputType = {
    id: number
    productId: number
    status: number
    location: number
    _all: number
  }


  export type StockMinAggregateInputType = {
    id?: true
    productId?: true
    status?: true
    location?: true
  }

  export type StockMaxAggregateInputType = {
    id?: true
    productId?: true
    status?: true
    location?: true
  }

  export type StockCountAggregateInputType = {
    id?: true
    productId?: true
    status?: true
    location?: true
    _all?: true
  }

  export type StockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stock to aggregate.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stocks
    **/
    _count?: true | StockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMaxAggregateInputType
  }

  export type GetStockAggregateType<T extends StockAggregateArgs> = {
        [P in keyof T & keyof AggregateStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock[P]>
      : GetScalarType<T[P], AggregateStock[P]>
  }




  export type StockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
    orderBy?: StockOrderByWithAggregationInput | StockOrderByWithAggregationInput[]
    by: StockScalarFieldEnum[] | StockScalarFieldEnum
    having?: StockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockCountAggregateInputType | true
    _min?: StockMinAggregateInputType
    _max?: StockMaxAggregateInputType
  }

  export type StockGroupByOutputType = {
    id: string
    productId: string
    status: $Enums.StockStatus
    location: string
    _count: StockCountAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  type GetStockGroupByPayload<T extends StockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockGroupByOutputType[P]>
            : GetScalarType<T[P], StockGroupByOutputType[P]>
        }
      >
    >


  export type StockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    status?: boolean
    location?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    damageReports?: boolean | Stock$damageReportsArgs<ExtArgs>
    _count?: boolean | StockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>



  export type StockSelectScalar = {
    id?: boolean
    productId?: boolean
    status?: boolean
    location?: boolean
  }

  export type StockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "status" | "location", ExtArgs["result"]["stock"]>
  export type StockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    damageReports?: boolean | Stock$damageReportsArgs<ExtArgs>
    _count?: boolean | StockCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stock"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      damageReports: Prisma.$DamageReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      status: $Enums.StockStatus
      location: string
    }, ExtArgs["result"]["stock"]>
    composites: {}
  }

  type StockGetPayload<S extends boolean | null | undefined | StockDefaultArgs> = $Result.GetResult<Prisma.$StockPayload, S>

  type StockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockCountAggregateInputType | true
    }

  export interface StockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stock'], meta: { name: 'Stock' } }
    /**
     * Find zero or one Stock that matches the filter.
     * @param {StockFindUniqueArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockFindUniqueArgs>(args: SelectSubset<T, StockFindUniqueArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockFindUniqueOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockFindUniqueOrThrowArgs>(args: SelectSubset<T, StockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockFindFirstArgs>(args?: SelectSubset<T, StockFindFirstArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockFindFirstOrThrowArgs>(args?: SelectSubset<T, StockFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stocks
     * const stocks = await prisma.stock.findMany()
     * 
     * // Get first 10 Stocks
     * const stocks = await prisma.stock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockWithIdOnly = await prisma.stock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockFindManyArgs>(args?: SelectSubset<T, StockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stock.
     * @param {StockCreateArgs} args - Arguments to create a Stock.
     * @example
     * // Create one Stock
     * const Stock = await prisma.stock.create({
     *   data: {
     *     // ... data to create a Stock
     *   }
     * })
     * 
     */
    create<T extends StockCreateArgs>(args: SelectSubset<T, StockCreateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stocks.
     * @param {StockCreateManyArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockCreateManyArgs>(args?: SelectSubset<T, StockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stock.
     * @param {StockDeleteArgs} args - Arguments to delete one Stock.
     * @example
     * // Delete one Stock
     * const Stock = await prisma.stock.delete({
     *   where: {
     *     // ... filter to delete one Stock
     *   }
     * })
     * 
     */
    delete<T extends StockDeleteArgs>(args: SelectSubset<T, StockDeleteArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stock.
     * @param {StockUpdateArgs} args - Arguments to update one Stock.
     * @example
     * // Update one Stock
     * const stock = await prisma.stock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockUpdateArgs>(args: SelectSubset<T, StockUpdateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stocks.
     * @param {StockDeleteManyArgs} args - Arguments to filter Stocks to delete.
     * @example
     * // Delete a few Stocks
     * const { count } = await prisma.stock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockDeleteManyArgs>(args?: SelectSubset<T, StockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockUpdateManyArgs>(args: SelectSubset<T, StockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stock.
     * @param {StockUpsertArgs} args - Arguments to update or create a Stock.
     * @example
     * // Update or create a Stock
     * const stock = await prisma.stock.upsert({
     *   create: {
     *     // ... data to create a Stock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock we want to update
     *   }
     * })
     */
    upsert<T extends StockUpsertArgs>(args: SelectSubset<T, StockUpsertArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stocks that matches the filter.
     * @param {StockFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const stock = await prisma.stock.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: StockFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Stock.
     * @param {StockAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const stock = await prisma.stock.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: StockAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCountArgs} args - Arguments to filter Stocks to count.
     * @example
     * // Count the number of Stocks
     * const count = await prisma.stock.count({
     *   where: {
     *     // ... the filter for the Stocks we want to count
     *   }
     * })
    **/
    count<T extends StockCountArgs>(
      args?: Subset<T, StockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAggregateArgs>(args: Subset<T, StockAggregateArgs>): Prisma.PrismaPromise<GetStockAggregateType<T>>

    /**
     * Group by Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockGroupByArgs['orderBy'] }
        : { orderBy?: StockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stock model
   */
  readonly fields: StockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    damageReports<T extends Stock$damageReportsArgs<ExtArgs> = {}>(args?: Subset<T, Stock$damageReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stock model
   */
  interface StockFieldRefs {
    readonly id: FieldRef<"Stock", 'String'>
    readonly productId: FieldRef<"Stock", 'String'>
    readonly status: FieldRef<"Stock", 'StockStatus'>
    readonly location: FieldRef<"Stock", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Stock findUnique
   */
  export type StockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findUniqueOrThrow
   */
  export type StockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findFirst
   */
  export type StockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findFirstOrThrow
   */
  export type StockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findMany
   */
  export type StockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock create
   */
  export type StockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to create a Stock.
     */
    data: XOR<StockCreateInput, StockUncheckedCreateInput>
  }

  /**
   * Stock createMany
   */
  export type StockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
  }

  /**
   * Stock update
   */
  export type StockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to update a Stock.
     */
    data: XOR<StockUpdateInput, StockUncheckedUpdateInput>
    /**
     * Choose, which Stock to update.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock updateMany
   */
  export type StockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to update.
     */
    limit?: number
  }

  /**
   * Stock upsert
   */
  export type StockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The filter to search for the Stock to update in case it exists.
     */
    where: StockWhereUniqueInput
    /**
     * In case the Stock found by the `where` argument doesn't exist, create a new Stock with this data.
     */
    create: XOR<StockCreateInput, StockUncheckedCreateInput>
    /**
     * In case the Stock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockUpdateInput, StockUncheckedUpdateInput>
  }

  /**
   * Stock delete
   */
  export type StockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter which Stock to delete.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock deleteMany
   */
  export type StockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stocks to delete
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to delete.
     */
    limit?: number
  }

  /**
   * Stock findRaw
   */
  export type StockFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Stock aggregateRaw
   */
  export type StockAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Stock.damageReports
   */
  export type Stock$damageReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageReport
     */
    select?: DamageReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageReport
     */
    omit?: DamageReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageReportInclude<ExtArgs> | null
    where?: DamageReportWhereInput
    orderBy?: DamageReportOrderByWithRelationInput | DamageReportOrderByWithRelationInput[]
    cursor?: DamageReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DamageReportScalarFieldEnum | DamageReportScalarFieldEnum[]
  }

  /**
   * Stock without action
   */
  export type StockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
  }


  /**
   * Model WarrantyCard
   */

  export type AggregateWarrantyCard = {
    _count: WarrantyCardCountAggregateOutputType | null
    _min: WarrantyCardMinAggregateOutputType | null
    _max: WarrantyCardMaxAggregateOutputType | null
  }

  export type WarrantyCardMinAggregateOutputType = {
    id: string | null
    productId: string | null
    serialNumber: string | null
    purchaseDate: Date | null
    expiryDate: Date | null
    scanQR: string | null
    validViaWarranIQ: string | null
  }

  export type WarrantyCardMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    serialNumber: string | null
    purchaseDate: Date | null
    expiryDate: Date | null
    scanQR: string | null
    validViaWarranIQ: string | null
  }

  export type WarrantyCardCountAggregateOutputType = {
    id: number
    productId: number
    serialNumber: number
    purchaseDate: number
    expiryDate: number
    scanQR: number
    validViaWarranIQ: number
    _all: number
  }


  export type WarrantyCardMinAggregateInputType = {
    id?: true
    productId?: true
    serialNumber?: true
    purchaseDate?: true
    expiryDate?: true
    scanQR?: true
    validViaWarranIQ?: true
  }

  export type WarrantyCardMaxAggregateInputType = {
    id?: true
    productId?: true
    serialNumber?: true
    purchaseDate?: true
    expiryDate?: true
    scanQR?: true
    validViaWarranIQ?: true
  }

  export type WarrantyCardCountAggregateInputType = {
    id?: true
    productId?: true
    serialNumber?: true
    purchaseDate?: true
    expiryDate?: true
    scanQR?: true
    validViaWarranIQ?: true
    _all?: true
  }

  export type WarrantyCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarrantyCard to aggregate.
     */
    where?: WarrantyCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarrantyCards to fetch.
     */
    orderBy?: WarrantyCardOrderByWithRelationInput | WarrantyCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarrantyCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarrantyCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarrantyCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarrantyCards
    **/
    _count?: true | WarrantyCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarrantyCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarrantyCardMaxAggregateInputType
  }

  export type GetWarrantyCardAggregateType<T extends WarrantyCardAggregateArgs> = {
        [P in keyof T & keyof AggregateWarrantyCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarrantyCard[P]>
      : GetScalarType<T[P], AggregateWarrantyCard[P]>
  }




  export type WarrantyCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarrantyCardWhereInput
    orderBy?: WarrantyCardOrderByWithAggregationInput | WarrantyCardOrderByWithAggregationInput[]
    by: WarrantyCardScalarFieldEnum[] | WarrantyCardScalarFieldEnum
    having?: WarrantyCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarrantyCardCountAggregateInputType | true
    _min?: WarrantyCardMinAggregateInputType
    _max?: WarrantyCardMaxAggregateInputType
  }

  export type WarrantyCardGroupByOutputType = {
    id: string
    productId: string
    serialNumber: string
    purchaseDate: Date
    expiryDate: Date
    scanQR: string
    validViaWarranIQ: string
    _count: WarrantyCardCountAggregateOutputType | null
    _min: WarrantyCardMinAggregateOutputType | null
    _max: WarrantyCardMaxAggregateOutputType | null
  }

  type GetWarrantyCardGroupByPayload<T extends WarrantyCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarrantyCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarrantyCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarrantyCardGroupByOutputType[P]>
            : GetScalarType<T[P], WarrantyCardGroupByOutputType[P]>
        }
      >
    >


  export type WarrantyCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    serialNumber?: boolean
    purchaseDate?: boolean
    expiryDate?: boolean
    scanQR?: boolean
    validViaWarranIQ?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warrantyCard"]>



  export type WarrantyCardSelectScalar = {
    id?: boolean
    productId?: boolean
    serialNumber?: boolean
    purchaseDate?: boolean
    expiryDate?: boolean
    scanQR?: boolean
    validViaWarranIQ?: boolean
  }

  export type WarrantyCardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "serialNumber" | "purchaseDate" | "expiryDate" | "scanQR" | "validViaWarranIQ", ExtArgs["result"]["warrantyCard"]>
  export type WarrantyCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $WarrantyCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarrantyCard"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      serialNumber: string
      purchaseDate: Date
      expiryDate: Date
      scanQR: string
      validViaWarranIQ: string
    }, ExtArgs["result"]["warrantyCard"]>
    composites: {}
  }

  type WarrantyCardGetPayload<S extends boolean | null | undefined | WarrantyCardDefaultArgs> = $Result.GetResult<Prisma.$WarrantyCardPayload, S>

  type WarrantyCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarrantyCardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarrantyCardCountAggregateInputType | true
    }

  export interface WarrantyCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarrantyCard'], meta: { name: 'WarrantyCard' } }
    /**
     * Find zero or one WarrantyCard that matches the filter.
     * @param {WarrantyCardFindUniqueArgs} args - Arguments to find a WarrantyCard
     * @example
     * // Get one WarrantyCard
     * const warrantyCard = await prisma.warrantyCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarrantyCardFindUniqueArgs>(args: SelectSubset<T, WarrantyCardFindUniqueArgs<ExtArgs>>): Prisma__WarrantyCardClient<$Result.GetResult<Prisma.$WarrantyCardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WarrantyCard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarrantyCardFindUniqueOrThrowArgs} args - Arguments to find a WarrantyCard
     * @example
     * // Get one WarrantyCard
     * const warrantyCard = await prisma.warrantyCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarrantyCardFindUniqueOrThrowArgs>(args: SelectSubset<T, WarrantyCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarrantyCardClient<$Result.GetResult<Prisma.$WarrantyCardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarrantyCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyCardFindFirstArgs} args - Arguments to find a WarrantyCard
     * @example
     * // Get one WarrantyCard
     * const warrantyCard = await prisma.warrantyCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarrantyCardFindFirstArgs>(args?: SelectSubset<T, WarrantyCardFindFirstArgs<ExtArgs>>): Prisma__WarrantyCardClient<$Result.GetResult<Prisma.$WarrantyCardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarrantyCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyCardFindFirstOrThrowArgs} args - Arguments to find a WarrantyCard
     * @example
     * // Get one WarrantyCard
     * const warrantyCard = await prisma.warrantyCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarrantyCardFindFirstOrThrowArgs>(args?: SelectSubset<T, WarrantyCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarrantyCardClient<$Result.GetResult<Prisma.$WarrantyCardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WarrantyCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarrantyCards
     * const warrantyCards = await prisma.warrantyCard.findMany()
     * 
     * // Get first 10 WarrantyCards
     * const warrantyCards = await prisma.warrantyCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warrantyCardWithIdOnly = await prisma.warrantyCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarrantyCardFindManyArgs>(args?: SelectSubset<T, WarrantyCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarrantyCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WarrantyCard.
     * @param {WarrantyCardCreateArgs} args - Arguments to create a WarrantyCard.
     * @example
     * // Create one WarrantyCard
     * const WarrantyCard = await prisma.warrantyCard.create({
     *   data: {
     *     // ... data to create a WarrantyCard
     *   }
     * })
     * 
     */
    create<T extends WarrantyCardCreateArgs>(args: SelectSubset<T, WarrantyCardCreateArgs<ExtArgs>>): Prisma__WarrantyCardClient<$Result.GetResult<Prisma.$WarrantyCardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WarrantyCards.
     * @param {WarrantyCardCreateManyArgs} args - Arguments to create many WarrantyCards.
     * @example
     * // Create many WarrantyCards
     * const warrantyCard = await prisma.warrantyCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarrantyCardCreateManyArgs>(args?: SelectSubset<T, WarrantyCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WarrantyCard.
     * @param {WarrantyCardDeleteArgs} args - Arguments to delete one WarrantyCard.
     * @example
     * // Delete one WarrantyCard
     * const WarrantyCard = await prisma.warrantyCard.delete({
     *   where: {
     *     // ... filter to delete one WarrantyCard
     *   }
     * })
     * 
     */
    delete<T extends WarrantyCardDeleteArgs>(args: SelectSubset<T, WarrantyCardDeleteArgs<ExtArgs>>): Prisma__WarrantyCardClient<$Result.GetResult<Prisma.$WarrantyCardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WarrantyCard.
     * @param {WarrantyCardUpdateArgs} args - Arguments to update one WarrantyCard.
     * @example
     * // Update one WarrantyCard
     * const warrantyCard = await prisma.warrantyCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarrantyCardUpdateArgs>(args: SelectSubset<T, WarrantyCardUpdateArgs<ExtArgs>>): Prisma__WarrantyCardClient<$Result.GetResult<Prisma.$WarrantyCardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WarrantyCards.
     * @param {WarrantyCardDeleteManyArgs} args - Arguments to filter WarrantyCards to delete.
     * @example
     * // Delete a few WarrantyCards
     * const { count } = await prisma.warrantyCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarrantyCardDeleteManyArgs>(args?: SelectSubset<T, WarrantyCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarrantyCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarrantyCards
     * const warrantyCard = await prisma.warrantyCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarrantyCardUpdateManyArgs>(args: SelectSubset<T, WarrantyCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WarrantyCard.
     * @param {WarrantyCardUpsertArgs} args - Arguments to update or create a WarrantyCard.
     * @example
     * // Update or create a WarrantyCard
     * const warrantyCard = await prisma.warrantyCard.upsert({
     *   create: {
     *     // ... data to create a WarrantyCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarrantyCard we want to update
     *   }
     * })
     */
    upsert<T extends WarrantyCardUpsertArgs>(args: SelectSubset<T, WarrantyCardUpsertArgs<ExtArgs>>): Prisma__WarrantyCardClient<$Result.GetResult<Prisma.$WarrantyCardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WarrantyCards that matches the filter.
     * @param {WarrantyCardFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const warrantyCard = await prisma.warrantyCard.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: WarrantyCardFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a WarrantyCard.
     * @param {WarrantyCardAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const warrantyCard = await prisma.warrantyCard.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: WarrantyCardAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of WarrantyCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyCardCountArgs} args - Arguments to filter WarrantyCards to count.
     * @example
     * // Count the number of WarrantyCards
     * const count = await prisma.warrantyCard.count({
     *   where: {
     *     // ... the filter for the WarrantyCards we want to count
     *   }
     * })
    **/
    count<T extends WarrantyCardCountArgs>(
      args?: Subset<T, WarrantyCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarrantyCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarrantyCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarrantyCardAggregateArgs>(args: Subset<T, WarrantyCardAggregateArgs>): Prisma.PrismaPromise<GetWarrantyCardAggregateType<T>>

    /**
     * Group by WarrantyCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarrantyCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarrantyCardGroupByArgs['orderBy'] }
        : { orderBy?: WarrantyCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarrantyCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarrantyCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarrantyCard model
   */
  readonly fields: WarrantyCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarrantyCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarrantyCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarrantyCard model
   */
  interface WarrantyCardFieldRefs {
    readonly id: FieldRef<"WarrantyCard", 'String'>
    readonly productId: FieldRef<"WarrantyCard", 'String'>
    readonly serialNumber: FieldRef<"WarrantyCard", 'String'>
    readonly purchaseDate: FieldRef<"WarrantyCard", 'DateTime'>
    readonly expiryDate: FieldRef<"WarrantyCard", 'DateTime'>
    readonly scanQR: FieldRef<"WarrantyCard", 'String'>
    readonly validViaWarranIQ: FieldRef<"WarrantyCard", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WarrantyCard findUnique
   */
  export type WarrantyCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarrantyCard
     */
    select?: WarrantyCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarrantyCard
     */
    omit?: WarrantyCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarrantyCardInclude<ExtArgs> | null
    /**
     * Filter, which WarrantyCard to fetch.
     */
    where: WarrantyCardWhereUniqueInput
  }

  /**
   * WarrantyCard findUniqueOrThrow
   */
  export type WarrantyCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarrantyCard
     */
    select?: WarrantyCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarrantyCard
     */
    omit?: WarrantyCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarrantyCardInclude<ExtArgs> | null
    /**
     * Filter, which WarrantyCard to fetch.
     */
    where: WarrantyCardWhereUniqueInput
  }

  /**
   * WarrantyCard findFirst
   */
  export type WarrantyCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarrantyCard
     */
    select?: WarrantyCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarrantyCard
     */
    omit?: WarrantyCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarrantyCardInclude<ExtArgs> | null
    /**
     * Filter, which WarrantyCard to fetch.
     */
    where?: WarrantyCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarrantyCards to fetch.
     */
    orderBy?: WarrantyCardOrderByWithRelationInput | WarrantyCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarrantyCards.
     */
    cursor?: WarrantyCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarrantyCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarrantyCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarrantyCards.
     */
    distinct?: WarrantyCardScalarFieldEnum | WarrantyCardScalarFieldEnum[]
  }

  /**
   * WarrantyCard findFirstOrThrow
   */
  export type WarrantyCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarrantyCard
     */
    select?: WarrantyCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarrantyCard
     */
    omit?: WarrantyCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarrantyCardInclude<ExtArgs> | null
    /**
     * Filter, which WarrantyCard to fetch.
     */
    where?: WarrantyCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarrantyCards to fetch.
     */
    orderBy?: WarrantyCardOrderByWithRelationInput | WarrantyCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarrantyCards.
     */
    cursor?: WarrantyCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarrantyCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarrantyCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarrantyCards.
     */
    distinct?: WarrantyCardScalarFieldEnum | WarrantyCardScalarFieldEnum[]
  }

  /**
   * WarrantyCard findMany
   */
  export type WarrantyCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarrantyCard
     */
    select?: WarrantyCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarrantyCard
     */
    omit?: WarrantyCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarrantyCardInclude<ExtArgs> | null
    /**
     * Filter, which WarrantyCards to fetch.
     */
    where?: WarrantyCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarrantyCards to fetch.
     */
    orderBy?: WarrantyCardOrderByWithRelationInput | WarrantyCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarrantyCards.
     */
    cursor?: WarrantyCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarrantyCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarrantyCards.
     */
    skip?: number
    distinct?: WarrantyCardScalarFieldEnum | WarrantyCardScalarFieldEnum[]
  }

  /**
   * WarrantyCard create
   */
  export type WarrantyCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarrantyCard
     */
    select?: WarrantyCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarrantyCard
     */
    omit?: WarrantyCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarrantyCardInclude<ExtArgs> | null
    /**
     * The data needed to create a WarrantyCard.
     */
    data: XOR<WarrantyCardCreateInput, WarrantyCardUncheckedCreateInput>
  }

  /**
   * WarrantyCard createMany
   */
  export type WarrantyCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarrantyCards.
     */
    data: WarrantyCardCreateManyInput | WarrantyCardCreateManyInput[]
  }

  /**
   * WarrantyCard update
   */
  export type WarrantyCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarrantyCard
     */
    select?: WarrantyCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarrantyCard
     */
    omit?: WarrantyCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarrantyCardInclude<ExtArgs> | null
    /**
     * The data needed to update a WarrantyCard.
     */
    data: XOR<WarrantyCardUpdateInput, WarrantyCardUncheckedUpdateInput>
    /**
     * Choose, which WarrantyCard to update.
     */
    where: WarrantyCardWhereUniqueInput
  }

  /**
   * WarrantyCard updateMany
   */
  export type WarrantyCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarrantyCards.
     */
    data: XOR<WarrantyCardUpdateManyMutationInput, WarrantyCardUncheckedUpdateManyInput>
    /**
     * Filter which WarrantyCards to update
     */
    where?: WarrantyCardWhereInput
    /**
     * Limit how many WarrantyCards to update.
     */
    limit?: number
  }

  /**
   * WarrantyCard upsert
   */
  export type WarrantyCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarrantyCard
     */
    select?: WarrantyCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarrantyCard
     */
    omit?: WarrantyCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarrantyCardInclude<ExtArgs> | null
    /**
     * The filter to search for the WarrantyCard to update in case it exists.
     */
    where: WarrantyCardWhereUniqueInput
    /**
     * In case the WarrantyCard found by the `where` argument doesn't exist, create a new WarrantyCard with this data.
     */
    create: XOR<WarrantyCardCreateInput, WarrantyCardUncheckedCreateInput>
    /**
     * In case the WarrantyCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarrantyCardUpdateInput, WarrantyCardUncheckedUpdateInput>
  }

  /**
   * WarrantyCard delete
   */
  export type WarrantyCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarrantyCard
     */
    select?: WarrantyCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarrantyCard
     */
    omit?: WarrantyCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarrantyCardInclude<ExtArgs> | null
    /**
     * Filter which WarrantyCard to delete.
     */
    where: WarrantyCardWhereUniqueInput
  }

  /**
   * WarrantyCard deleteMany
   */
  export type WarrantyCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarrantyCards to delete
     */
    where?: WarrantyCardWhereInput
    /**
     * Limit how many WarrantyCards to delete.
     */
    limit?: number
  }

  /**
   * WarrantyCard findRaw
   */
  export type WarrantyCardFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WarrantyCard aggregateRaw
   */
  export type WarrantyCardAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WarrantyCard without action
   */
  export type WarrantyCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarrantyCard
     */
    select?: WarrantyCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarrantyCard
     */
    omit?: WarrantyCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarrantyCardInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    checkIn: Date | null
    checkOut: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    checkIn: Date | null
    checkOut: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    checkIn: number
    checkOut: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    checkIn?: true
    checkOut?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    checkIn?: true
    checkOut?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    checkIn?: true
    checkOut?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    userId: string
    date: Date
    checkIn: Date
    checkOut: Date | null
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    checkIn?: boolean
    checkOut?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>



  export type AttendanceSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    checkIn?: boolean
    checkOut?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "checkIn" | "checkOut", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      checkIn: Date
      checkOut: Date | null
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * @param {AttendanceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const attendance = await prisma.attendance.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AttendanceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Attendance.
     * @param {AttendanceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const attendance = await prisma.attendance.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AttendanceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly userId: FieldRef<"Attendance", 'String'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly checkIn: FieldRef<"Attendance", 'DateTime'>
    readonly checkOut: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance findRaw
   */
  export type AttendanceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Attendance aggregateRaw
   */
  export type AttendanceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model CustomerFollowUp
   */

  export type AggregateCustomerFollowUp = {
    _count: CustomerFollowUpCountAggregateOutputType | null
    _min: CustomerFollowUpMinAggregateOutputType | null
    _max: CustomerFollowUpMaxAggregateOutputType | null
  }

  export type CustomerFollowUpMinAggregateOutputType = {
    id: string | null
    executiveId: string | null
    customerName: string | null
    contactDetails: string | null
    feedback: string | null
    status: $Enums.FollowUpStatus | null
    nextFollowUpDate: Date | null
  }

  export type CustomerFollowUpMaxAggregateOutputType = {
    id: string | null
    executiveId: string | null
    customerName: string | null
    contactDetails: string | null
    feedback: string | null
    status: $Enums.FollowUpStatus | null
    nextFollowUpDate: Date | null
  }

  export type CustomerFollowUpCountAggregateOutputType = {
    id: number
    executiveId: number
    customerName: number
    contactDetails: number
    feedback: number
    status: number
    nextFollowUpDate: number
    _all: number
  }


  export type CustomerFollowUpMinAggregateInputType = {
    id?: true
    executiveId?: true
    customerName?: true
    contactDetails?: true
    feedback?: true
    status?: true
    nextFollowUpDate?: true
  }

  export type CustomerFollowUpMaxAggregateInputType = {
    id?: true
    executiveId?: true
    customerName?: true
    contactDetails?: true
    feedback?: true
    status?: true
    nextFollowUpDate?: true
  }

  export type CustomerFollowUpCountAggregateInputType = {
    id?: true
    executiveId?: true
    customerName?: true
    contactDetails?: true
    feedback?: true
    status?: true
    nextFollowUpDate?: true
    _all?: true
  }

  export type CustomerFollowUpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerFollowUp to aggregate.
     */
    where?: CustomerFollowUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerFollowUps to fetch.
     */
    orderBy?: CustomerFollowUpOrderByWithRelationInput | CustomerFollowUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerFollowUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerFollowUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerFollowUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerFollowUps
    **/
    _count?: true | CustomerFollowUpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerFollowUpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerFollowUpMaxAggregateInputType
  }

  export type GetCustomerFollowUpAggregateType<T extends CustomerFollowUpAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerFollowUp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerFollowUp[P]>
      : GetScalarType<T[P], AggregateCustomerFollowUp[P]>
  }




  export type CustomerFollowUpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerFollowUpWhereInput
    orderBy?: CustomerFollowUpOrderByWithAggregationInput | CustomerFollowUpOrderByWithAggregationInput[]
    by: CustomerFollowUpScalarFieldEnum[] | CustomerFollowUpScalarFieldEnum
    having?: CustomerFollowUpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerFollowUpCountAggregateInputType | true
    _min?: CustomerFollowUpMinAggregateInputType
    _max?: CustomerFollowUpMaxAggregateInputType
  }

  export type CustomerFollowUpGroupByOutputType = {
    id: string
    executiveId: string
    customerName: string
    contactDetails: string
    feedback: string
    status: $Enums.FollowUpStatus
    nextFollowUpDate: Date
    _count: CustomerFollowUpCountAggregateOutputType | null
    _min: CustomerFollowUpMinAggregateOutputType | null
    _max: CustomerFollowUpMaxAggregateOutputType | null
  }

  type GetCustomerFollowUpGroupByPayload<T extends CustomerFollowUpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerFollowUpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerFollowUpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerFollowUpGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerFollowUpGroupByOutputType[P]>
        }
      >
    >


  export type CustomerFollowUpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executiveId?: boolean
    customerName?: boolean
    contactDetails?: boolean
    feedback?: boolean
    status?: boolean
    nextFollowUpDate?: boolean
    executive?: boolean | FieldExecutiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerFollowUp"]>



  export type CustomerFollowUpSelectScalar = {
    id?: boolean
    executiveId?: boolean
    customerName?: boolean
    contactDetails?: boolean
    feedback?: boolean
    status?: boolean
    nextFollowUpDate?: boolean
  }

  export type CustomerFollowUpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "executiveId" | "customerName" | "contactDetails" | "feedback" | "status" | "nextFollowUpDate", ExtArgs["result"]["customerFollowUp"]>
  export type CustomerFollowUpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executive?: boolean | FieldExecutiveDefaultArgs<ExtArgs>
  }

  export type $CustomerFollowUpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerFollowUp"
    objects: {
      executive: Prisma.$FieldExecutivePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executiveId: string
      customerName: string
      contactDetails: string
      feedback: string
      status: $Enums.FollowUpStatus
      nextFollowUpDate: Date
    }, ExtArgs["result"]["customerFollowUp"]>
    composites: {}
  }

  type CustomerFollowUpGetPayload<S extends boolean | null | undefined | CustomerFollowUpDefaultArgs> = $Result.GetResult<Prisma.$CustomerFollowUpPayload, S>

  type CustomerFollowUpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFollowUpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerFollowUpCountAggregateInputType | true
    }

  export interface CustomerFollowUpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerFollowUp'], meta: { name: 'CustomerFollowUp' } }
    /**
     * Find zero or one CustomerFollowUp that matches the filter.
     * @param {CustomerFollowUpFindUniqueArgs} args - Arguments to find a CustomerFollowUp
     * @example
     * // Get one CustomerFollowUp
     * const customerFollowUp = await prisma.customerFollowUp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFollowUpFindUniqueArgs>(args: SelectSubset<T, CustomerFollowUpFindUniqueArgs<ExtArgs>>): Prisma__CustomerFollowUpClient<$Result.GetResult<Prisma.$CustomerFollowUpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerFollowUp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFollowUpFindUniqueOrThrowArgs} args - Arguments to find a CustomerFollowUp
     * @example
     * // Get one CustomerFollowUp
     * const customerFollowUp = await prisma.customerFollowUp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFollowUpFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFollowUpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerFollowUpClient<$Result.GetResult<Prisma.$CustomerFollowUpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerFollowUp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFollowUpFindFirstArgs} args - Arguments to find a CustomerFollowUp
     * @example
     * // Get one CustomerFollowUp
     * const customerFollowUp = await prisma.customerFollowUp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFollowUpFindFirstArgs>(args?: SelectSubset<T, CustomerFollowUpFindFirstArgs<ExtArgs>>): Prisma__CustomerFollowUpClient<$Result.GetResult<Prisma.$CustomerFollowUpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerFollowUp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFollowUpFindFirstOrThrowArgs} args - Arguments to find a CustomerFollowUp
     * @example
     * // Get one CustomerFollowUp
     * const customerFollowUp = await prisma.customerFollowUp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFollowUpFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFollowUpFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerFollowUpClient<$Result.GetResult<Prisma.$CustomerFollowUpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerFollowUps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFollowUpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerFollowUps
     * const customerFollowUps = await prisma.customerFollowUp.findMany()
     * 
     * // Get first 10 CustomerFollowUps
     * const customerFollowUps = await prisma.customerFollowUp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerFollowUpWithIdOnly = await prisma.customerFollowUp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFollowUpFindManyArgs>(args?: SelectSubset<T, CustomerFollowUpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerFollowUpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerFollowUp.
     * @param {CustomerFollowUpCreateArgs} args - Arguments to create a CustomerFollowUp.
     * @example
     * // Create one CustomerFollowUp
     * const CustomerFollowUp = await prisma.customerFollowUp.create({
     *   data: {
     *     // ... data to create a CustomerFollowUp
     *   }
     * })
     * 
     */
    create<T extends CustomerFollowUpCreateArgs>(args: SelectSubset<T, CustomerFollowUpCreateArgs<ExtArgs>>): Prisma__CustomerFollowUpClient<$Result.GetResult<Prisma.$CustomerFollowUpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerFollowUps.
     * @param {CustomerFollowUpCreateManyArgs} args - Arguments to create many CustomerFollowUps.
     * @example
     * // Create many CustomerFollowUps
     * const customerFollowUp = await prisma.customerFollowUp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerFollowUpCreateManyArgs>(args?: SelectSubset<T, CustomerFollowUpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerFollowUp.
     * @param {CustomerFollowUpDeleteArgs} args - Arguments to delete one CustomerFollowUp.
     * @example
     * // Delete one CustomerFollowUp
     * const CustomerFollowUp = await prisma.customerFollowUp.delete({
     *   where: {
     *     // ... filter to delete one CustomerFollowUp
     *   }
     * })
     * 
     */
    delete<T extends CustomerFollowUpDeleteArgs>(args: SelectSubset<T, CustomerFollowUpDeleteArgs<ExtArgs>>): Prisma__CustomerFollowUpClient<$Result.GetResult<Prisma.$CustomerFollowUpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerFollowUp.
     * @param {CustomerFollowUpUpdateArgs} args - Arguments to update one CustomerFollowUp.
     * @example
     * // Update one CustomerFollowUp
     * const customerFollowUp = await prisma.customerFollowUp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerFollowUpUpdateArgs>(args: SelectSubset<T, CustomerFollowUpUpdateArgs<ExtArgs>>): Prisma__CustomerFollowUpClient<$Result.GetResult<Prisma.$CustomerFollowUpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerFollowUps.
     * @param {CustomerFollowUpDeleteManyArgs} args - Arguments to filter CustomerFollowUps to delete.
     * @example
     * // Delete a few CustomerFollowUps
     * const { count } = await prisma.customerFollowUp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerFollowUpDeleteManyArgs>(args?: SelectSubset<T, CustomerFollowUpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerFollowUps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFollowUpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerFollowUps
     * const customerFollowUp = await prisma.customerFollowUp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerFollowUpUpdateManyArgs>(args: SelectSubset<T, CustomerFollowUpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerFollowUp.
     * @param {CustomerFollowUpUpsertArgs} args - Arguments to update or create a CustomerFollowUp.
     * @example
     * // Update or create a CustomerFollowUp
     * const customerFollowUp = await prisma.customerFollowUp.upsert({
     *   create: {
     *     // ... data to create a CustomerFollowUp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerFollowUp we want to update
     *   }
     * })
     */
    upsert<T extends CustomerFollowUpUpsertArgs>(args: SelectSubset<T, CustomerFollowUpUpsertArgs<ExtArgs>>): Prisma__CustomerFollowUpClient<$Result.GetResult<Prisma.$CustomerFollowUpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerFollowUps that matches the filter.
     * @param {CustomerFollowUpFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const customerFollowUp = await prisma.customerFollowUp.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CustomerFollowUpFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CustomerFollowUp.
     * @param {CustomerFollowUpAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const customerFollowUp = await prisma.customerFollowUp.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CustomerFollowUpAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CustomerFollowUps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFollowUpCountArgs} args - Arguments to filter CustomerFollowUps to count.
     * @example
     * // Count the number of CustomerFollowUps
     * const count = await prisma.customerFollowUp.count({
     *   where: {
     *     // ... the filter for the CustomerFollowUps we want to count
     *   }
     * })
    **/
    count<T extends CustomerFollowUpCountArgs>(
      args?: Subset<T, CustomerFollowUpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerFollowUpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerFollowUp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFollowUpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerFollowUpAggregateArgs>(args: Subset<T, CustomerFollowUpAggregateArgs>): Prisma.PrismaPromise<GetCustomerFollowUpAggregateType<T>>

    /**
     * Group by CustomerFollowUp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFollowUpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerFollowUpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerFollowUpGroupByArgs['orderBy'] }
        : { orderBy?: CustomerFollowUpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerFollowUpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerFollowUpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerFollowUp model
   */
  readonly fields: CustomerFollowUpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerFollowUp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerFollowUpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    executive<T extends FieldExecutiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldExecutiveDefaultArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerFollowUp model
   */
  interface CustomerFollowUpFieldRefs {
    readonly id: FieldRef<"CustomerFollowUp", 'String'>
    readonly executiveId: FieldRef<"CustomerFollowUp", 'String'>
    readonly customerName: FieldRef<"CustomerFollowUp", 'String'>
    readonly contactDetails: FieldRef<"CustomerFollowUp", 'String'>
    readonly feedback: FieldRef<"CustomerFollowUp", 'String'>
    readonly status: FieldRef<"CustomerFollowUp", 'FollowUpStatus'>
    readonly nextFollowUpDate: FieldRef<"CustomerFollowUp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerFollowUp findUnique
   */
  export type CustomerFollowUpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFollowUp
     */
    select?: CustomerFollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFollowUp
     */
    omit?: CustomerFollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFollowUpInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFollowUp to fetch.
     */
    where: CustomerFollowUpWhereUniqueInput
  }

  /**
   * CustomerFollowUp findUniqueOrThrow
   */
  export type CustomerFollowUpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFollowUp
     */
    select?: CustomerFollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFollowUp
     */
    omit?: CustomerFollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFollowUpInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFollowUp to fetch.
     */
    where: CustomerFollowUpWhereUniqueInput
  }

  /**
   * CustomerFollowUp findFirst
   */
  export type CustomerFollowUpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFollowUp
     */
    select?: CustomerFollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFollowUp
     */
    omit?: CustomerFollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFollowUpInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFollowUp to fetch.
     */
    where?: CustomerFollowUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerFollowUps to fetch.
     */
    orderBy?: CustomerFollowUpOrderByWithRelationInput | CustomerFollowUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerFollowUps.
     */
    cursor?: CustomerFollowUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerFollowUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerFollowUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerFollowUps.
     */
    distinct?: CustomerFollowUpScalarFieldEnum | CustomerFollowUpScalarFieldEnum[]
  }

  /**
   * CustomerFollowUp findFirstOrThrow
   */
  export type CustomerFollowUpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFollowUp
     */
    select?: CustomerFollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFollowUp
     */
    omit?: CustomerFollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFollowUpInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFollowUp to fetch.
     */
    where?: CustomerFollowUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerFollowUps to fetch.
     */
    orderBy?: CustomerFollowUpOrderByWithRelationInput | CustomerFollowUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerFollowUps.
     */
    cursor?: CustomerFollowUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerFollowUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerFollowUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerFollowUps.
     */
    distinct?: CustomerFollowUpScalarFieldEnum | CustomerFollowUpScalarFieldEnum[]
  }

  /**
   * CustomerFollowUp findMany
   */
  export type CustomerFollowUpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFollowUp
     */
    select?: CustomerFollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFollowUp
     */
    omit?: CustomerFollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFollowUpInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFollowUps to fetch.
     */
    where?: CustomerFollowUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerFollowUps to fetch.
     */
    orderBy?: CustomerFollowUpOrderByWithRelationInput | CustomerFollowUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerFollowUps.
     */
    cursor?: CustomerFollowUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerFollowUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerFollowUps.
     */
    skip?: number
    distinct?: CustomerFollowUpScalarFieldEnum | CustomerFollowUpScalarFieldEnum[]
  }

  /**
   * CustomerFollowUp create
   */
  export type CustomerFollowUpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFollowUp
     */
    select?: CustomerFollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFollowUp
     */
    omit?: CustomerFollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFollowUpInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerFollowUp.
     */
    data: XOR<CustomerFollowUpCreateInput, CustomerFollowUpUncheckedCreateInput>
  }

  /**
   * CustomerFollowUp createMany
   */
  export type CustomerFollowUpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerFollowUps.
     */
    data: CustomerFollowUpCreateManyInput | CustomerFollowUpCreateManyInput[]
  }

  /**
   * CustomerFollowUp update
   */
  export type CustomerFollowUpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFollowUp
     */
    select?: CustomerFollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFollowUp
     */
    omit?: CustomerFollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFollowUpInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerFollowUp.
     */
    data: XOR<CustomerFollowUpUpdateInput, CustomerFollowUpUncheckedUpdateInput>
    /**
     * Choose, which CustomerFollowUp to update.
     */
    where: CustomerFollowUpWhereUniqueInput
  }

  /**
   * CustomerFollowUp updateMany
   */
  export type CustomerFollowUpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerFollowUps.
     */
    data: XOR<CustomerFollowUpUpdateManyMutationInput, CustomerFollowUpUncheckedUpdateManyInput>
    /**
     * Filter which CustomerFollowUps to update
     */
    where?: CustomerFollowUpWhereInput
    /**
     * Limit how many CustomerFollowUps to update.
     */
    limit?: number
  }

  /**
   * CustomerFollowUp upsert
   */
  export type CustomerFollowUpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFollowUp
     */
    select?: CustomerFollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFollowUp
     */
    omit?: CustomerFollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFollowUpInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerFollowUp to update in case it exists.
     */
    where: CustomerFollowUpWhereUniqueInput
    /**
     * In case the CustomerFollowUp found by the `where` argument doesn't exist, create a new CustomerFollowUp with this data.
     */
    create: XOR<CustomerFollowUpCreateInput, CustomerFollowUpUncheckedCreateInput>
    /**
     * In case the CustomerFollowUp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerFollowUpUpdateInput, CustomerFollowUpUncheckedUpdateInput>
  }

  /**
   * CustomerFollowUp delete
   */
  export type CustomerFollowUpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFollowUp
     */
    select?: CustomerFollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFollowUp
     */
    omit?: CustomerFollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFollowUpInclude<ExtArgs> | null
    /**
     * Filter which CustomerFollowUp to delete.
     */
    where: CustomerFollowUpWhereUniqueInput
  }

  /**
   * CustomerFollowUp deleteMany
   */
  export type CustomerFollowUpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerFollowUps to delete
     */
    where?: CustomerFollowUpWhereInput
    /**
     * Limit how many CustomerFollowUps to delete.
     */
    limit?: number
  }

  /**
   * CustomerFollowUp findRaw
   */
  export type CustomerFollowUpFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CustomerFollowUp aggregateRaw
   */
  export type CustomerFollowUpAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CustomerFollowUp without action
   */
  export type CustomerFollowUpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFollowUp
     */
    select?: CustomerFollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerFollowUp
     */
    omit?: CustomerFollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFollowUpInclude<ExtArgs> | null
  }


  /**
   * Model PointTransaction
   */

  export type AggregatePointTransaction = {
    _count: PointTransactionCountAggregateOutputType | null
    _avg: PointTransactionAvgAggregateOutputType | null
    _sum: PointTransactionSumAggregateOutputType | null
    _min: PointTransactionMinAggregateOutputType | null
    _max: PointTransactionMaxAggregateOutputType | null
  }

  export type PointTransactionAvgAggregateOutputType = {
    points: number | null
    creditAmount: number | null
  }

  export type PointTransactionSumAggregateOutputType = {
    points: number | null
    creditAmount: number | null
  }

  export type PointTransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    points: number | null
    creditAmount: number | null
    date: Date | null
    reason: string | null
    type: $Enums.TransactionType | null
  }

  export type PointTransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    points: number | null
    creditAmount: number | null
    date: Date | null
    reason: string | null
    type: $Enums.TransactionType | null
  }

  export type PointTransactionCountAggregateOutputType = {
    id: number
    userId: number
    points: number
    creditAmount: number
    date: number
    reason: number
    type: number
    _all: number
  }


  export type PointTransactionAvgAggregateInputType = {
    points?: true
    creditAmount?: true
  }

  export type PointTransactionSumAggregateInputType = {
    points?: true
    creditAmount?: true
  }

  export type PointTransactionMinAggregateInputType = {
    id?: true
    userId?: true
    points?: true
    creditAmount?: true
    date?: true
    reason?: true
    type?: true
  }

  export type PointTransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    points?: true
    creditAmount?: true
    date?: true
    reason?: true
    type?: true
  }

  export type PointTransactionCountAggregateInputType = {
    id?: true
    userId?: true
    points?: true
    creditAmount?: true
    date?: true
    reason?: true
    type?: true
    _all?: true
  }

  export type PointTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointTransaction to aggregate.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointTransactions
    **/
    _count?: true | PointTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointTransactionMaxAggregateInputType
  }

  export type GetPointTransactionAggregateType<T extends PointTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePointTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointTransaction[P]>
      : GetScalarType<T[P], AggregatePointTransaction[P]>
  }




  export type PointTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointTransactionWhereInput
    orderBy?: PointTransactionOrderByWithAggregationInput | PointTransactionOrderByWithAggregationInput[]
    by: PointTransactionScalarFieldEnum[] | PointTransactionScalarFieldEnum
    having?: PointTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointTransactionCountAggregateInputType | true
    _avg?: PointTransactionAvgAggregateInputType
    _sum?: PointTransactionSumAggregateInputType
    _min?: PointTransactionMinAggregateInputType
    _max?: PointTransactionMaxAggregateInputType
  }

  export type PointTransactionGroupByOutputType = {
    id: string
    userId: string
    points: number
    creditAmount: number
    date: Date
    reason: string
    type: $Enums.TransactionType
    _count: PointTransactionCountAggregateOutputType | null
    _avg: PointTransactionAvgAggregateOutputType | null
    _sum: PointTransactionSumAggregateOutputType | null
    _min: PointTransactionMinAggregateOutputType | null
    _max: PointTransactionMaxAggregateOutputType | null
  }

  type GetPointTransactionGroupByPayload<T extends PointTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], PointTransactionGroupByOutputType[P]>
        }
      >
    >


  export type PointTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    points?: boolean
    creditAmount?: boolean
    date?: boolean
    reason?: boolean
    type?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointTransaction"]>



  export type PointTransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    points?: boolean
    creditAmount?: boolean
    date?: boolean
    reason?: boolean
    type?: boolean
  }

  export type PointTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "points" | "creditAmount" | "date" | "reason" | "type", ExtArgs["result"]["pointTransaction"]>
  export type PointTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PointTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointTransaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      points: number
      creditAmount: number
      date: Date
      reason: string
      type: $Enums.TransactionType
    }, ExtArgs["result"]["pointTransaction"]>
    composites: {}
  }

  type PointTransactionGetPayload<S extends boolean | null | undefined | PointTransactionDefaultArgs> = $Result.GetResult<Prisma.$PointTransactionPayload, S>

  type PointTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PointTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PointTransactionCountAggregateInputType | true
    }

  export interface PointTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointTransaction'], meta: { name: 'PointTransaction' } }
    /**
     * Find zero or one PointTransaction that matches the filter.
     * @param {PointTransactionFindUniqueArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointTransactionFindUniqueArgs>(args: SelectSubset<T, PointTransactionFindUniqueArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PointTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PointTransactionFindUniqueOrThrowArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, PointTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionFindFirstArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointTransactionFindFirstArgs>(args?: SelectSubset<T, PointTransactionFindFirstArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionFindFirstOrThrowArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, PointTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PointTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointTransactions
     * const pointTransactions = await prisma.pointTransaction.findMany()
     * 
     * // Get first 10 PointTransactions
     * const pointTransactions = await prisma.pointTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointTransactionWithIdOnly = await prisma.pointTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointTransactionFindManyArgs>(args?: SelectSubset<T, PointTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PointTransaction.
     * @param {PointTransactionCreateArgs} args - Arguments to create a PointTransaction.
     * @example
     * // Create one PointTransaction
     * const PointTransaction = await prisma.pointTransaction.create({
     *   data: {
     *     // ... data to create a PointTransaction
     *   }
     * })
     * 
     */
    create<T extends PointTransactionCreateArgs>(args: SelectSubset<T, PointTransactionCreateArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PointTransactions.
     * @param {PointTransactionCreateManyArgs} args - Arguments to create many PointTransactions.
     * @example
     * // Create many PointTransactions
     * const pointTransaction = await prisma.pointTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointTransactionCreateManyArgs>(args?: SelectSubset<T, PointTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PointTransaction.
     * @param {PointTransactionDeleteArgs} args - Arguments to delete one PointTransaction.
     * @example
     * // Delete one PointTransaction
     * const PointTransaction = await prisma.pointTransaction.delete({
     *   where: {
     *     // ... filter to delete one PointTransaction
     *   }
     * })
     * 
     */
    delete<T extends PointTransactionDeleteArgs>(args: SelectSubset<T, PointTransactionDeleteArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PointTransaction.
     * @param {PointTransactionUpdateArgs} args - Arguments to update one PointTransaction.
     * @example
     * // Update one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointTransactionUpdateArgs>(args: SelectSubset<T, PointTransactionUpdateArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PointTransactions.
     * @param {PointTransactionDeleteManyArgs} args - Arguments to filter PointTransactions to delete.
     * @example
     * // Delete a few PointTransactions
     * const { count } = await prisma.pointTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointTransactionDeleteManyArgs>(args?: SelectSubset<T, PointTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointTransactions
     * const pointTransaction = await prisma.pointTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointTransactionUpdateManyArgs>(args: SelectSubset<T, PointTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PointTransaction.
     * @param {PointTransactionUpsertArgs} args - Arguments to update or create a PointTransaction.
     * @example
     * // Update or create a PointTransaction
     * const pointTransaction = await prisma.pointTransaction.upsert({
     *   create: {
     *     // ... data to create a PointTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointTransaction we want to update
     *   }
     * })
     */
    upsert<T extends PointTransactionUpsertArgs>(args: SelectSubset<T, PointTransactionUpsertArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PointTransactions that matches the filter.
     * @param {PointTransactionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const pointTransaction = await prisma.pointTransaction.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PointTransactionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PointTransaction.
     * @param {PointTransactionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const pointTransaction = await prisma.pointTransaction.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PointTransactionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PointTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionCountArgs} args - Arguments to filter PointTransactions to count.
     * @example
     * // Count the number of PointTransactions
     * const count = await prisma.pointTransaction.count({
     *   where: {
     *     // ... the filter for the PointTransactions we want to count
     *   }
     * })
    **/
    count<T extends PointTransactionCountArgs>(
      args?: Subset<T, PointTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointTransactionAggregateArgs>(args: Subset<T, PointTransactionAggregateArgs>): Prisma.PrismaPromise<GetPointTransactionAggregateType<T>>

    /**
     * Group by PointTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointTransactionGroupByArgs['orderBy'] }
        : { orderBy?: PointTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointTransaction model
   */
  readonly fields: PointTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointTransaction model
   */
  interface PointTransactionFieldRefs {
    readonly id: FieldRef<"PointTransaction", 'String'>
    readonly userId: FieldRef<"PointTransaction", 'String'>
    readonly points: FieldRef<"PointTransaction", 'Int'>
    readonly creditAmount: FieldRef<"PointTransaction", 'Float'>
    readonly date: FieldRef<"PointTransaction", 'DateTime'>
    readonly reason: FieldRef<"PointTransaction", 'String'>
    readonly type: FieldRef<"PointTransaction", 'TransactionType'>
  }
    

  // Custom InputTypes
  /**
   * PointTransaction findUnique
   */
  export type PointTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction findUniqueOrThrow
   */
  export type PointTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction findFirst
   */
  export type PointTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointTransactions.
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointTransactions.
     */
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * PointTransaction findFirstOrThrow
   */
  export type PointTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointTransactions.
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointTransactions.
     */
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * PointTransaction findMany
   */
  export type PointTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransactions to fetch.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointTransactions.
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * PointTransaction create
   */
  export type PointTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a PointTransaction.
     */
    data: XOR<PointTransactionCreateInput, PointTransactionUncheckedCreateInput>
  }

  /**
   * PointTransaction createMany
   */
  export type PointTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointTransactions.
     */
    data: PointTransactionCreateManyInput | PointTransactionCreateManyInput[]
  }

  /**
   * PointTransaction update
   */
  export type PointTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a PointTransaction.
     */
    data: XOR<PointTransactionUpdateInput, PointTransactionUncheckedUpdateInput>
    /**
     * Choose, which PointTransaction to update.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction updateMany
   */
  export type PointTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointTransactions.
     */
    data: XOR<PointTransactionUpdateManyMutationInput, PointTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PointTransactions to update
     */
    where?: PointTransactionWhereInput
    /**
     * Limit how many PointTransactions to update.
     */
    limit?: number
  }

  /**
   * PointTransaction upsert
   */
  export type PointTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the PointTransaction to update in case it exists.
     */
    where: PointTransactionWhereUniqueInput
    /**
     * In case the PointTransaction found by the `where` argument doesn't exist, create a new PointTransaction with this data.
     */
    create: XOR<PointTransactionCreateInput, PointTransactionUncheckedCreateInput>
    /**
     * In case the PointTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointTransactionUpdateInput, PointTransactionUncheckedUpdateInput>
  }

  /**
   * PointTransaction delete
   */
  export type PointTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter which PointTransaction to delete.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction deleteMany
   */
  export type PointTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointTransactions to delete
     */
    where?: PointTransactionWhereInput
    /**
     * Limit how many PointTransactions to delete.
     */
    limit?: number
  }

  /**
   * PointTransaction findRaw
   */
  export type PointTransactionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PointTransaction aggregateRaw
   */
  export type PointTransactionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PointTransaction without action
   */
  export type PointTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Incentive
   */

  export type AggregateIncentive = {
    _count: IncentiveCountAggregateOutputType | null
    _avg: IncentiveAvgAggregateOutputType | null
    _sum: IncentiveSumAggregateOutputType | null
    _min: IncentiveMinAggregateOutputType | null
    _max: IncentiveMaxAggregateOutputType | null
  }

  export type IncentiveAvgAggregateOutputType = {
    points: number | null
  }

  export type IncentiveSumAggregateOutputType = {
    points: number | null
  }

  export type IncentiveMinAggregateOutputType = {
    id: string | null
    description: string | null
    points: number | null
    assignedId: string | null
    assignedAt: Date | null
  }

  export type IncentiveMaxAggregateOutputType = {
    id: string | null
    description: string | null
    points: number | null
    assignedId: string | null
    assignedAt: Date | null
  }

  export type IncentiveCountAggregateOutputType = {
    id: number
    description: number
    points: number
    assignedId: number
    assignedAt: number
    _all: number
  }


  export type IncentiveAvgAggregateInputType = {
    points?: true
  }

  export type IncentiveSumAggregateInputType = {
    points?: true
  }

  export type IncentiveMinAggregateInputType = {
    id?: true
    description?: true
    points?: true
    assignedId?: true
    assignedAt?: true
  }

  export type IncentiveMaxAggregateInputType = {
    id?: true
    description?: true
    points?: true
    assignedId?: true
    assignedAt?: true
  }

  export type IncentiveCountAggregateInputType = {
    id?: true
    description?: true
    points?: true
    assignedId?: true
    assignedAt?: true
    _all?: true
  }

  export type IncentiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incentive to aggregate.
     */
    where?: IncentiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incentives to fetch.
     */
    orderBy?: IncentiveOrderByWithRelationInput | IncentiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncentiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incentives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incentives
    **/
    _count?: true | IncentiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncentiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncentiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncentiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncentiveMaxAggregateInputType
  }

  export type GetIncentiveAggregateType<T extends IncentiveAggregateArgs> = {
        [P in keyof T & keyof AggregateIncentive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncentive[P]>
      : GetScalarType<T[P], AggregateIncentive[P]>
  }




  export type IncentiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncentiveWhereInput
    orderBy?: IncentiveOrderByWithAggregationInput | IncentiveOrderByWithAggregationInput[]
    by: IncentiveScalarFieldEnum[] | IncentiveScalarFieldEnum
    having?: IncentiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncentiveCountAggregateInputType | true
    _avg?: IncentiveAvgAggregateInputType
    _sum?: IncentiveSumAggregateInputType
    _min?: IncentiveMinAggregateInputType
    _max?: IncentiveMaxAggregateInputType
  }

  export type IncentiveGroupByOutputType = {
    id: string
    description: string
    points: number
    assignedId: string
    assignedAt: Date
    _count: IncentiveCountAggregateOutputType | null
    _avg: IncentiveAvgAggregateOutputType | null
    _sum: IncentiveSumAggregateOutputType | null
    _min: IncentiveMinAggregateOutputType | null
    _max: IncentiveMaxAggregateOutputType | null
  }

  type GetIncentiveGroupByPayload<T extends IncentiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncentiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncentiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncentiveGroupByOutputType[P]>
            : GetScalarType<T[P], IncentiveGroupByOutputType[P]>
        }
      >
    >


  export type IncentiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    points?: boolean
    assignedId?: boolean
    assignedAt?: boolean
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incentive"]>



  export type IncentiveSelectScalar = {
    id?: boolean
    description?: boolean
    points?: boolean
    assignedId?: boolean
    assignedAt?: boolean
  }

  export type IncentiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "points" | "assignedId" | "assignedAt", ExtArgs["result"]["incentive"]>
  export type IncentiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IncentivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Incentive"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      points: number
      assignedId: string
      assignedAt: Date
    }, ExtArgs["result"]["incentive"]>
    composites: {}
  }

  type IncentiveGetPayload<S extends boolean | null | undefined | IncentiveDefaultArgs> = $Result.GetResult<Prisma.$IncentivePayload, S>

  type IncentiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncentiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncentiveCountAggregateInputType | true
    }

  export interface IncentiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Incentive'], meta: { name: 'Incentive' } }
    /**
     * Find zero or one Incentive that matches the filter.
     * @param {IncentiveFindUniqueArgs} args - Arguments to find a Incentive
     * @example
     * // Get one Incentive
     * const incentive = await prisma.incentive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncentiveFindUniqueArgs>(args: SelectSubset<T, IncentiveFindUniqueArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Incentive that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncentiveFindUniqueOrThrowArgs} args - Arguments to find a Incentive
     * @example
     * // Get one Incentive
     * const incentive = await prisma.incentive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncentiveFindUniqueOrThrowArgs>(args: SelectSubset<T, IncentiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Incentive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveFindFirstArgs} args - Arguments to find a Incentive
     * @example
     * // Get one Incentive
     * const incentive = await prisma.incentive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncentiveFindFirstArgs>(args?: SelectSubset<T, IncentiveFindFirstArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Incentive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveFindFirstOrThrowArgs} args - Arguments to find a Incentive
     * @example
     * // Get one Incentive
     * const incentive = await prisma.incentive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncentiveFindFirstOrThrowArgs>(args?: SelectSubset<T, IncentiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Incentives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incentives
     * const incentives = await prisma.incentive.findMany()
     * 
     * // Get first 10 Incentives
     * const incentives = await prisma.incentive.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incentiveWithIdOnly = await prisma.incentive.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncentiveFindManyArgs>(args?: SelectSubset<T, IncentiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Incentive.
     * @param {IncentiveCreateArgs} args - Arguments to create a Incentive.
     * @example
     * // Create one Incentive
     * const Incentive = await prisma.incentive.create({
     *   data: {
     *     // ... data to create a Incentive
     *   }
     * })
     * 
     */
    create<T extends IncentiveCreateArgs>(args: SelectSubset<T, IncentiveCreateArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Incentives.
     * @param {IncentiveCreateManyArgs} args - Arguments to create many Incentives.
     * @example
     * // Create many Incentives
     * const incentive = await prisma.incentive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncentiveCreateManyArgs>(args?: SelectSubset<T, IncentiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Incentive.
     * @param {IncentiveDeleteArgs} args - Arguments to delete one Incentive.
     * @example
     * // Delete one Incentive
     * const Incentive = await prisma.incentive.delete({
     *   where: {
     *     // ... filter to delete one Incentive
     *   }
     * })
     * 
     */
    delete<T extends IncentiveDeleteArgs>(args: SelectSubset<T, IncentiveDeleteArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Incentive.
     * @param {IncentiveUpdateArgs} args - Arguments to update one Incentive.
     * @example
     * // Update one Incentive
     * const incentive = await prisma.incentive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncentiveUpdateArgs>(args: SelectSubset<T, IncentiveUpdateArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Incentives.
     * @param {IncentiveDeleteManyArgs} args - Arguments to filter Incentives to delete.
     * @example
     * // Delete a few Incentives
     * const { count } = await prisma.incentive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncentiveDeleteManyArgs>(args?: SelectSubset<T, IncentiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incentives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incentives
     * const incentive = await prisma.incentive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncentiveUpdateManyArgs>(args: SelectSubset<T, IncentiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Incentive.
     * @param {IncentiveUpsertArgs} args - Arguments to update or create a Incentive.
     * @example
     * // Update or create a Incentive
     * const incentive = await prisma.incentive.upsert({
     *   create: {
     *     // ... data to create a Incentive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incentive we want to update
     *   }
     * })
     */
    upsert<T extends IncentiveUpsertArgs>(args: SelectSubset<T, IncentiveUpsertArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Incentives that matches the filter.
     * @param {IncentiveFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const incentive = await prisma.incentive.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: IncentiveFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Incentive.
     * @param {IncentiveAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const incentive = await prisma.incentive.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: IncentiveAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Incentives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveCountArgs} args - Arguments to filter Incentives to count.
     * @example
     * // Count the number of Incentives
     * const count = await prisma.incentive.count({
     *   where: {
     *     // ... the filter for the Incentives we want to count
     *   }
     * })
    **/
    count<T extends IncentiveCountArgs>(
      args?: Subset<T, IncentiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncentiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incentive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncentiveAggregateArgs>(args: Subset<T, IncentiveAggregateArgs>): Prisma.PrismaPromise<GetIncentiveAggregateType<T>>

    /**
     * Group by Incentive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncentiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncentiveGroupByArgs['orderBy'] }
        : { orderBy?: IncentiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncentiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncentiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Incentive model
   */
  readonly fields: IncentiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incentive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncentiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Incentive model
   */
  interface IncentiveFieldRefs {
    readonly id: FieldRef<"Incentive", 'String'>
    readonly description: FieldRef<"Incentive", 'String'>
    readonly points: FieldRef<"Incentive", 'Int'>
    readonly assignedId: FieldRef<"Incentive", 'String'>
    readonly assignedAt: FieldRef<"Incentive", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Incentive findUnique
   */
  export type IncentiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incentive
     */
    omit?: IncentiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * Filter, which Incentive to fetch.
     */
    where: IncentiveWhereUniqueInput
  }

  /**
   * Incentive findUniqueOrThrow
   */
  export type IncentiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incentive
     */
    omit?: IncentiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * Filter, which Incentive to fetch.
     */
    where: IncentiveWhereUniqueInput
  }

  /**
   * Incentive findFirst
   */
  export type IncentiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incentive
     */
    omit?: IncentiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * Filter, which Incentive to fetch.
     */
    where?: IncentiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incentives to fetch.
     */
    orderBy?: IncentiveOrderByWithRelationInput | IncentiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incentives.
     */
    cursor?: IncentiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incentives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incentives.
     */
    distinct?: IncentiveScalarFieldEnum | IncentiveScalarFieldEnum[]
  }

  /**
   * Incentive findFirstOrThrow
   */
  export type IncentiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incentive
     */
    omit?: IncentiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * Filter, which Incentive to fetch.
     */
    where?: IncentiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incentives to fetch.
     */
    orderBy?: IncentiveOrderByWithRelationInput | IncentiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incentives.
     */
    cursor?: IncentiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incentives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incentives.
     */
    distinct?: IncentiveScalarFieldEnum | IncentiveScalarFieldEnum[]
  }

  /**
   * Incentive findMany
   */
  export type IncentiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incentive
     */
    omit?: IncentiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * Filter, which Incentives to fetch.
     */
    where?: IncentiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incentives to fetch.
     */
    orderBy?: IncentiveOrderByWithRelationInput | IncentiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incentives.
     */
    cursor?: IncentiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incentives.
     */
    skip?: number
    distinct?: IncentiveScalarFieldEnum | IncentiveScalarFieldEnum[]
  }

  /**
   * Incentive create
   */
  export type IncentiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incentive
     */
    omit?: IncentiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * The data needed to create a Incentive.
     */
    data: XOR<IncentiveCreateInput, IncentiveUncheckedCreateInput>
  }

  /**
   * Incentive createMany
   */
  export type IncentiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incentives.
     */
    data: IncentiveCreateManyInput | IncentiveCreateManyInput[]
  }

  /**
   * Incentive update
   */
  export type IncentiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incentive
     */
    omit?: IncentiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * The data needed to update a Incentive.
     */
    data: XOR<IncentiveUpdateInput, IncentiveUncheckedUpdateInput>
    /**
     * Choose, which Incentive to update.
     */
    where: IncentiveWhereUniqueInput
  }

  /**
   * Incentive updateMany
   */
  export type IncentiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incentives.
     */
    data: XOR<IncentiveUpdateManyMutationInput, IncentiveUncheckedUpdateManyInput>
    /**
     * Filter which Incentives to update
     */
    where?: IncentiveWhereInput
    /**
     * Limit how many Incentives to update.
     */
    limit?: number
  }

  /**
   * Incentive upsert
   */
  export type IncentiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incentive
     */
    omit?: IncentiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * The filter to search for the Incentive to update in case it exists.
     */
    where: IncentiveWhereUniqueInput
    /**
     * In case the Incentive found by the `where` argument doesn't exist, create a new Incentive with this data.
     */
    create: XOR<IncentiveCreateInput, IncentiveUncheckedCreateInput>
    /**
     * In case the Incentive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncentiveUpdateInput, IncentiveUncheckedUpdateInput>
  }

  /**
   * Incentive delete
   */
  export type IncentiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incentive
     */
    omit?: IncentiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * Filter which Incentive to delete.
     */
    where: IncentiveWhereUniqueInput
  }

  /**
   * Incentive deleteMany
   */
  export type IncentiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incentives to delete
     */
    where?: IncentiveWhereInput
    /**
     * Limit how many Incentives to delete.
     */
    limit?: number
  }

  /**
   * Incentive findRaw
   */
  export type IncentiveFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Incentive aggregateRaw
   */
  export type IncentiveAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Incentive without action
   */
  export type IncentiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incentive
     */
    omit?: IncentiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
  }


  /**
   * Model DVR
   */

  export type AggregateDVR = {
    _count: DVRCountAggregateOutputType | null
    _min: DVRMinAggregateOutputType | null
    _max: DVRMaxAggregateOutputType | null
  }

  export type DVRMinAggregateOutputType = {
    id: string | null
    executiveId: string | null
    feedback: string | null
    location: string | null
    status: string | null
    approvedBy: string | null
    approvedAt: Date | null
  }

  export type DVRMaxAggregateOutputType = {
    id: string | null
    executiveId: string | null
    feedback: string | null
    location: string | null
    status: string | null
    approvedBy: string | null
    approvedAt: Date | null
  }

  export type DVRCountAggregateOutputType = {
    id: number
    executiveId: number
    feedback: number
    location: number
    status: number
    approvedBy: number
    approvedAt: number
    _all: number
  }


  export type DVRMinAggregateInputType = {
    id?: true
    executiveId?: true
    feedback?: true
    location?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
  }

  export type DVRMaxAggregateInputType = {
    id?: true
    executiveId?: true
    feedback?: true
    location?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
  }

  export type DVRCountAggregateInputType = {
    id?: true
    executiveId?: true
    feedback?: true
    location?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    _all?: true
  }

  export type DVRAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DVR to aggregate.
     */
    where?: DVRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DVRS to fetch.
     */
    orderBy?: DVROrderByWithRelationInput | DVROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DVRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DVRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DVRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DVRS
    **/
    _count?: true | DVRCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DVRMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DVRMaxAggregateInputType
  }

  export type GetDVRAggregateType<T extends DVRAggregateArgs> = {
        [P in keyof T & keyof AggregateDVR]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDVR[P]>
      : GetScalarType<T[P], AggregateDVR[P]>
  }




  export type DVRGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DVRWhereInput
    orderBy?: DVROrderByWithAggregationInput | DVROrderByWithAggregationInput[]
    by: DVRScalarFieldEnum[] | DVRScalarFieldEnum
    having?: DVRScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DVRCountAggregateInputType | true
    _min?: DVRMinAggregateInputType
    _max?: DVRMaxAggregateInputType
  }

  export type DVRGroupByOutputType = {
    id: string
    executiveId: string
    feedback: string
    location: string
    status: string
    approvedBy: string | null
    approvedAt: Date | null
    _count: DVRCountAggregateOutputType | null
    _min: DVRMinAggregateOutputType | null
    _max: DVRMaxAggregateOutputType | null
  }

  type GetDVRGroupByPayload<T extends DVRGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DVRGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DVRGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DVRGroupByOutputType[P]>
            : GetScalarType<T[P], DVRGroupByOutputType[P]>
        }
      >
    >


  export type DVRSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executiveId?: boolean
    feedback?: boolean
    location?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    executive?: boolean | FieldExecutiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dVR"]>



  export type DVRSelectScalar = {
    id?: boolean
    executiveId?: boolean
    feedback?: boolean
    location?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
  }

  export type DVROmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "executiveId" | "feedback" | "location" | "status" | "approvedBy" | "approvedAt", ExtArgs["result"]["dVR"]>
  export type DVRInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executive?: boolean | FieldExecutiveDefaultArgs<ExtArgs>
  }

  export type $DVRPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DVR"
    objects: {
      executive: Prisma.$FieldExecutivePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executiveId: string
      feedback: string
      location: string
      status: string
      approvedBy: string | null
      approvedAt: Date | null
    }, ExtArgs["result"]["dVR"]>
    composites: {}
  }

  type DVRGetPayload<S extends boolean | null | undefined | DVRDefaultArgs> = $Result.GetResult<Prisma.$DVRPayload, S>

  type DVRCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DVRFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DVRCountAggregateInputType | true
    }

  export interface DVRDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DVR'], meta: { name: 'DVR' } }
    /**
     * Find zero or one DVR that matches the filter.
     * @param {DVRFindUniqueArgs} args - Arguments to find a DVR
     * @example
     * // Get one DVR
     * const dVR = await prisma.dVR.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DVRFindUniqueArgs>(args: SelectSubset<T, DVRFindUniqueArgs<ExtArgs>>): Prisma__DVRClient<$Result.GetResult<Prisma.$DVRPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DVR that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DVRFindUniqueOrThrowArgs} args - Arguments to find a DVR
     * @example
     * // Get one DVR
     * const dVR = await prisma.dVR.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DVRFindUniqueOrThrowArgs>(args: SelectSubset<T, DVRFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DVRClient<$Result.GetResult<Prisma.$DVRPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DVR that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DVRFindFirstArgs} args - Arguments to find a DVR
     * @example
     * // Get one DVR
     * const dVR = await prisma.dVR.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DVRFindFirstArgs>(args?: SelectSubset<T, DVRFindFirstArgs<ExtArgs>>): Prisma__DVRClient<$Result.GetResult<Prisma.$DVRPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DVR that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DVRFindFirstOrThrowArgs} args - Arguments to find a DVR
     * @example
     * // Get one DVR
     * const dVR = await prisma.dVR.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DVRFindFirstOrThrowArgs>(args?: SelectSubset<T, DVRFindFirstOrThrowArgs<ExtArgs>>): Prisma__DVRClient<$Result.GetResult<Prisma.$DVRPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DVRS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DVRFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DVRS
     * const dVRS = await prisma.dVR.findMany()
     * 
     * // Get first 10 DVRS
     * const dVRS = await prisma.dVR.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dVRWithIdOnly = await prisma.dVR.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DVRFindManyArgs>(args?: SelectSubset<T, DVRFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DVRPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DVR.
     * @param {DVRCreateArgs} args - Arguments to create a DVR.
     * @example
     * // Create one DVR
     * const DVR = await prisma.dVR.create({
     *   data: {
     *     // ... data to create a DVR
     *   }
     * })
     * 
     */
    create<T extends DVRCreateArgs>(args: SelectSubset<T, DVRCreateArgs<ExtArgs>>): Prisma__DVRClient<$Result.GetResult<Prisma.$DVRPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DVRS.
     * @param {DVRCreateManyArgs} args - Arguments to create many DVRS.
     * @example
     * // Create many DVRS
     * const dVR = await prisma.dVR.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DVRCreateManyArgs>(args?: SelectSubset<T, DVRCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DVR.
     * @param {DVRDeleteArgs} args - Arguments to delete one DVR.
     * @example
     * // Delete one DVR
     * const DVR = await prisma.dVR.delete({
     *   where: {
     *     // ... filter to delete one DVR
     *   }
     * })
     * 
     */
    delete<T extends DVRDeleteArgs>(args: SelectSubset<T, DVRDeleteArgs<ExtArgs>>): Prisma__DVRClient<$Result.GetResult<Prisma.$DVRPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DVR.
     * @param {DVRUpdateArgs} args - Arguments to update one DVR.
     * @example
     * // Update one DVR
     * const dVR = await prisma.dVR.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DVRUpdateArgs>(args: SelectSubset<T, DVRUpdateArgs<ExtArgs>>): Prisma__DVRClient<$Result.GetResult<Prisma.$DVRPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DVRS.
     * @param {DVRDeleteManyArgs} args - Arguments to filter DVRS to delete.
     * @example
     * // Delete a few DVRS
     * const { count } = await prisma.dVR.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DVRDeleteManyArgs>(args?: SelectSubset<T, DVRDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DVRS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DVRUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DVRS
     * const dVR = await prisma.dVR.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DVRUpdateManyArgs>(args: SelectSubset<T, DVRUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DVR.
     * @param {DVRUpsertArgs} args - Arguments to update or create a DVR.
     * @example
     * // Update or create a DVR
     * const dVR = await prisma.dVR.upsert({
     *   create: {
     *     // ... data to create a DVR
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DVR we want to update
     *   }
     * })
     */
    upsert<T extends DVRUpsertArgs>(args: SelectSubset<T, DVRUpsertArgs<ExtArgs>>): Prisma__DVRClient<$Result.GetResult<Prisma.$DVRPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DVRS that matches the filter.
     * @param {DVRFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dVR = await prisma.dVR.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DVRFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DVR.
     * @param {DVRAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dVR = await prisma.dVR.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DVRAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DVRS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DVRCountArgs} args - Arguments to filter DVRS to count.
     * @example
     * // Count the number of DVRS
     * const count = await prisma.dVR.count({
     *   where: {
     *     // ... the filter for the DVRS we want to count
     *   }
     * })
    **/
    count<T extends DVRCountArgs>(
      args?: Subset<T, DVRCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DVRCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DVR.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DVRAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DVRAggregateArgs>(args: Subset<T, DVRAggregateArgs>): Prisma.PrismaPromise<GetDVRAggregateType<T>>

    /**
     * Group by DVR.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DVRGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DVRGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DVRGroupByArgs['orderBy'] }
        : { orderBy?: DVRGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DVRGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDVRGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DVR model
   */
  readonly fields: DVRFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DVR.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DVRClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    executive<T extends FieldExecutiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldExecutiveDefaultArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DVR model
   */
  interface DVRFieldRefs {
    readonly id: FieldRef<"DVR", 'String'>
    readonly executiveId: FieldRef<"DVR", 'String'>
    readonly feedback: FieldRef<"DVR", 'String'>
    readonly location: FieldRef<"DVR", 'String'>
    readonly status: FieldRef<"DVR", 'String'>
    readonly approvedBy: FieldRef<"DVR", 'String'>
    readonly approvedAt: FieldRef<"DVR", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DVR findUnique
   */
  export type DVRFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DVR
     */
    select?: DVRSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DVR
     */
    omit?: DVROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DVRInclude<ExtArgs> | null
    /**
     * Filter, which DVR to fetch.
     */
    where: DVRWhereUniqueInput
  }

  /**
   * DVR findUniqueOrThrow
   */
  export type DVRFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DVR
     */
    select?: DVRSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DVR
     */
    omit?: DVROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DVRInclude<ExtArgs> | null
    /**
     * Filter, which DVR to fetch.
     */
    where: DVRWhereUniqueInput
  }

  /**
   * DVR findFirst
   */
  export type DVRFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DVR
     */
    select?: DVRSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DVR
     */
    omit?: DVROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DVRInclude<ExtArgs> | null
    /**
     * Filter, which DVR to fetch.
     */
    where?: DVRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DVRS to fetch.
     */
    orderBy?: DVROrderByWithRelationInput | DVROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DVRS.
     */
    cursor?: DVRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DVRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DVRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DVRS.
     */
    distinct?: DVRScalarFieldEnum | DVRScalarFieldEnum[]
  }

  /**
   * DVR findFirstOrThrow
   */
  export type DVRFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DVR
     */
    select?: DVRSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DVR
     */
    omit?: DVROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DVRInclude<ExtArgs> | null
    /**
     * Filter, which DVR to fetch.
     */
    where?: DVRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DVRS to fetch.
     */
    orderBy?: DVROrderByWithRelationInput | DVROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DVRS.
     */
    cursor?: DVRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DVRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DVRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DVRS.
     */
    distinct?: DVRScalarFieldEnum | DVRScalarFieldEnum[]
  }

  /**
   * DVR findMany
   */
  export type DVRFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DVR
     */
    select?: DVRSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DVR
     */
    omit?: DVROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DVRInclude<ExtArgs> | null
    /**
     * Filter, which DVRS to fetch.
     */
    where?: DVRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DVRS to fetch.
     */
    orderBy?: DVROrderByWithRelationInput | DVROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DVRS.
     */
    cursor?: DVRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DVRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DVRS.
     */
    skip?: number
    distinct?: DVRScalarFieldEnum | DVRScalarFieldEnum[]
  }

  /**
   * DVR create
   */
  export type DVRCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DVR
     */
    select?: DVRSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DVR
     */
    omit?: DVROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DVRInclude<ExtArgs> | null
    /**
     * The data needed to create a DVR.
     */
    data: XOR<DVRCreateInput, DVRUncheckedCreateInput>
  }

  /**
   * DVR createMany
   */
  export type DVRCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DVRS.
     */
    data: DVRCreateManyInput | DVRCreateManyInput[]
  }

  /**
   * DVR update
   */
  export type DVRUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DVR
     */
    select?: DVRSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DVR
     */
    omit?: DVROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DVRInclude<ExtArgs> | null
    /**
     * The data needed to update a DVR.
     */
    data: XOR<DVRUpdateInput, DVRUncheckedUpdateInput>
    /**
     * Choose, which DVR to update.
     */
    where: DVRWhereUniqueInput
  }

  /**
   * DVR updateMany
   */
  export type DVRUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DVRS.
     */
    data: XOR<DVRUpdateManyMutationInput, DVRUncheckedUpdateManyInput>
    /**
     * Filter which DVRS to update
     */
    where?: DVRWhereInput
    /**
     * Limit how many DVRS to update.
     */
    limit?: number
  }

  /**
   * DVR upsert
   */
  export type DVRUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DVR
     */
    select?: DVRSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DVR
     */
    omit?: DVROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DVRInclude<ExtArgs> | null
    /**
     * The filter to search for the DVR to update in case it exists.
     */
    where: DVRWhereUniqueInput
    /**
     * In case the DVR found by the `where` argument doesn't exist, create a new DVR with this data.
     */
    create: XOR<DVRCreateInput, DVRUncheckedCreateInput>
    /**
     * In case the DVR was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DVRUpdateInput, DVRUncheckedUpdateInput>
  }

  /**
   * DVR delete
   */
  export type DVRDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DVR
     */
    select?: DVRSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DVR
     */
    omit?: DVROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DVRInclude<ExtArgs> | null
    /**
     * Filter which DVR to delete.
     */
    where: DVRWhereUniqueInput
  }

  /**
   * DVR deleteMany
   */
  export type DVRDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DVRS to delete
     */
    where?: DVRWhereInput
    /**
     * Limit how many DVRS to delete.
     */
    limit?: number
  }

  /**
   * DVR findRaw
   */
  export type DVRFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DVR aggregateRaw
   */
  export type DVRAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DVR without action
   */
  export type DVRDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DVR
     */
    select?: DVRSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DVR
     */
    omit?: DVROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DVRInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryReport
   */

  export type AggregateDeliveryReport = {
    _count: DeliveryReportCountAggregateOutputType | null
    _avg: DeliveryReportAvgAggregateOutputType | null
    _sum: DeliveryReportSumAggregateOutputType | null
    _min: DeliveryReportMinAggregateOutputType | null
    _max: DeliveryReportMaxAggregateOutputType | null
  }

  export type DeliveryReportAvgAggregateOutputType = {
    quantity: number | null
  }

  export type DeliveryReportSumAggregateOutputType = {
    quantity: number | null
  }

  export type DeliveryReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    product: string | null
    quantity: number | null
    isForecasted: boolean | null
    qrRequested: boolean | null
    submittedAt: Date | null
  }

  export type DeliveryReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    product: string | null
    quantity: number | null
    isForecasted: boolean | null
    qrRequested: boolean | null
    submittedAt: Date | null
  }

  export type DeliveryReportCountAggregateOutputType = {
    id: number
    userId: number
    product: number
    quantity: number
    isForecasted: number
    qrRequested: number
    submittedAt: number
    _all: number
  }


  export type DeliveryReportAvgAggregateInputType = {
    quantity?: true
  }

  export type DeliveryReportSumAggregateInputType = {
    quantity?: true
  }

  export type DeliveryReportMinAggregateInputType = {
    id?: true
    userId?: true
    product?: true
    quantity?: true
    isForecasted?: true
    qrRequested?: true
    submittedAt?: true
  }

  export type DeliveryReportMaxAggregateInputType = {
    id?: true
    userId?: true
    product?: true
    quantity?: true
    isForecasted?: true
    qrRequested?: true
    submittedAt?: true
  }

  export type DeliveryReportCountAggregateInputType = {
    id?: true
    userId?: true
    product?: true
    quantity?: true
    isForecasted?: true
    qrRequested?: true
    submittedAt?: true
    _all?: true
  }

  export type DeliveryReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryReport to aggregate.
     */
    where?: DeliveryReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryReports to fetch.
     */
    orderBy?: DeliveryReportOrderByWithRelationInput | DeliveryReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryReports
    **/
    _count?: true | DeliveryReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryReportMaxAggregateInputType
  }

  export type GetDeliveryReportAggregateType<T extends DeliveryReportAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryReport[P]>
      : GetScalarType<T[P], AggregateDeliveryReport[P]>
  }




  export type DeliveryReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryReportWhereInput
    orderBy?: DeliveryReportOrderByWithAggregationInput | DeliveryReportOrderByWithAggregationInput[]
    by: DeliveryReportScalarFieldEnum[] | DeliveryReportScalarFieldEnum
    having?: DeliveryReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryReportCountAggregateInputType | true
    _avg?: DeliveryReportAvgAggregateInputType
    _sum?: DeliveryReportSumAggregateInputType
    _min?: DeliveryReportMinAggregateInputType
    _max?: DeliveryReportMaxAggregateInputType
  }

  export type DeliveryReportGroupByOutputType = {
    id: string
    userId: string
    product: string
    quantity: number
    isForecasted: boolean
    qrRequested: boolean
    submittedAt: Date
    _count: DeliveryReportCountAggregateOutputType | null
    _avg: DeliveryReportAvgAggregateOutputType | null
    _sum: DeliveryReportSumAggregateOutputType | null
    _min: DeliveryReportMinAggregateOutputType | null
    _max: DeliveryReportMaxAggregateOutputType | null
  }

  type GetDeliveryReportGroupByPayload<T extends DeliveryReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryReportGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryReportGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    product?: boolean
    quantity?: boolean
    isForecasted?: boolean
    qrRequested?: boolean
    submittedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryReport"]>



  export type DeliveryReportSelectScalar = {
    id?: boolean
    userId?: boolean
    product?: boolean
    quantity?: boolean
    isForecasted?: boolean
    qrRequested?: boolean
    submittedAt?: boolean
  }

  export type DeliveryReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "product" | "quantity" | "isForecasted" | "qrRequested" | "submittedAt", ExtArgs["result"]["deliveryReport"]>
  export type DeliveryReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeliveryReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryReport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      product: string
      quantity: number
      isForecasted: boolean
      qrRequested: boolean
      submittedAt: Date
    }, ExtArgs["result"]["deliveryReport"]>
    composites: {}
  }

  type DeliveryReportGetPayload<S extends boolean | null | undefined | DeliveryReportDefaultArgs> = $Result.GetResult<Prisma.$DeliveryReportPayload, S>

  type DeliveryReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryReportCountAggregateInputType | true
    }

  export interface DeliveryReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryReport'], meta: { name: 'DeliveryReport' } }
    /**
     * Find zero or one DeliveryReport that matches the filter.
     * @param {DeliveryReportFindUniqueArgs} args - Arguments to find a DeliveryReport
     * @example
     * // Get one DeliveryReport
     * const deliveryReport = await prisma.deliveryReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryReportFindUniqueArgs>(args: SelectSubset<T, DeliveryReportFindUniqueArgs<ExtArgs>>): Prisma__DeliveryReportClient<$Result.GetResult<Prisma.$DeliveryReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryReportFindUniqueOrThrowArgs} args - Arguments to find a DeliveryReport
     * @example
     * // Get one DeliveryReport
     * const deliveryReport = await prisma.deliveryReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryReportFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryReportClient<$Result.GetResult<Prisma.$DeliveryReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryReportFindFirstArgs} args - Arguments to find a DeliveryReport
     * @example
     * // Get one DeliveryReport
     * const deliveryReport = await prisma.deliveryReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryReportFindFirstArgs>(args?: SelectSubset<T, DeliveryReportFindFirstArgs<ExtArgs>>): Prisma__DeliveryReportClient<$Result.GetResult<Prisma.$DeliveryReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryReportFindFirstOrThrowArgs} args - Arguments to find a DeliveryReport
     * @example
     * // Get one DeliveryReport
     * const deliveryReport = await prisma.deliveryReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryReportFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryReportClient<$Result.GetResult<Prisma.$DeliveryReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryReports
     * const deliveryReports = await prisma.deliveryReport.findMany()
     * 
     * // Get first 10 DeliveryReports
     * const deliveryReports = await prisma.deliveryReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryReportWithIdOnly = await prisma.deliveryReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryReportFindManyArgs>(args?: SelectSubset<T, DeliveryReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryReport.
     * @param {DeliveryReportCreateArgs} args - Arguments to create a DeliveryReport.
     * @example
     * // Create one DeliveryReport
     * const DeliveryReport = await prisma.deliveryReport.create({
     *   data: {
     *     // ... data to create a DeliveryReport
     *   }
     * })
     * 
     */
    create<T extends DeliveryReportCreateArgs>(args: SelectSubset<T, DeliveryReportCreateArgs<ExtArgs>>): Prisma__DeliveryReportClient<$Result.GetResult<Prisma.$DeliveryReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryReports.
     * @param {DeliveryReportCreateManyArgs} args - Arguments to create many DeliveryReports.
     * @example
     * // Create many DeliveryReports
     * const deliveryReport = await prisma.deliveryReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryReportCreateManyArgs>(args?: SelectSubset<T, DeliveryReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeliveryReport.
     * @param {DeliveryReportDeleteArgs} args - Arguments to delete one DeliveryReport.
     * @example
     * // Delete one DeliveryReport
     * const DeliveryReport = await prisma.deliveryReport.delete({
     *   where: {
     *     // ... filter to delete one DeliveryReport
     *   }
     * })
     * 
     */
    delete<T extends DeliveryReportDeleteArgs>(args: SelectSubset<T, DeliveryReportDeleteArgs<ExtArgs>>): Prisma__DeliveryReportClient<$Result.GetResult<Prisma.$DeliveryReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryReport.
     * @param {DeliveryReportUpdateArgs} args - Arguments to update one DeliveryReport.
     * @example
     * // Update one DeliveryReport
     * const deliveryReport = await prisma.deliveryReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryReportUpdateArgs>(args: SelectSubset<T, DeliveryReportUpdateArgs<ExtArgs>>): Prisma__DeliveryReportClient<$Result.GetResult<Prisma.$DeliveryReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryReports.
     * @param {DeliveryReportDeleteManyArgs} args - Arguments to filter DeliveryReports to delete.
     * @example
     * // Delete a few DeliveryReports
     * const { count } = await prisma.deliveryReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryReportDeleteManyArgs>(args?: SelectSubset<T, DeliveryReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryReports
     * const deliveryReport = await prisma.deliveryReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryReportUpdateManyArgs>(args: SelectSubset<T, DeliveryReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryReport.
     * @param {DeliveryReportUpsertArgs} args - Arguments to update or create a DeliveryReport.
     * @example
     * // Update or create a DeliveryReport
     * const deliveryReport = await prisma.deliveryReport.upsert({
     *   create: {
     *     // ... data to create a DeliveryReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryReport we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryReportUpsertArgs>(args: SelectSubset<T, DeliveryReportUpsertArgs<ExtArgs>>): Prisma__DeliveryReportClient<$Result.GetResult<Prisma.$DeliveryReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryReports that matches the filter.
     * @param {DeliveryReportFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const deliveryReport = await prisma.deliveryReport.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DeliveryReportFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DeliveryReport.
     * @param {DeliveryReportAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const deliveryReport = await prisma.deliveryReport.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DeliveryReportAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DeliveryReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryReportCountArgs} args - Arguments to filter DeliveryReports to count.
     * @example
     * // Count the number of DeliveryReports
     * const count = await prisma.deliveryReport.count({
     *   where: {
     *     // ... the filter for the DeliveryReports we want to count
     *   }
     * })
    **/
    count<T extends DeliveryReportCountArgs>(
      args?: Subset<T, DeliveryReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryReportAggregateArgs>(args: Subset<T, DeliveryReportAggregateArgs>): Prisma.PrismaPromise<GetDeliveryReportAggregateType<T>>

    /**
     * Group by DeliveryReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryReportGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryReport model
   */
  readonly fields: DeliveryReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryReport model
   */
  interface DeliveryReportFieldRefs {
    readonly id: FieldRef<"DeliveryReport", 'String'>
    readonly userId: FieldRef<"DeliveryReport", 'String'>
    readonly product: FieldRef<"DeliveryReport", 'String'>
    readonly quantity: FieldRef<"DeliveryReport", 'Int'>
    readonly isForecasted: FieldRef<"DeliveryReport", 'Boolean'>
    readonly qrRequested: FieldRef<"DeliveryReport", 'Boolean'>
    readonly submittedAt: FieldRef<"DeliveryReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryReport findUnique
   */
  export type DeliveryReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryReport
     */
    select?: DeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryReport
     */
    omit?: DeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryReportInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryReport to fetch.
     */
    where: DeliveryReportWhereUniqueInput
  }

  /**
   * DeliveryReport findUniqueOrThrow
   */
  export type DeliveryReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryReport
     */
    select?: DeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryReport
     */
    omit?: DeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryReportInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryReport to fetch.
     */
    where: DeliveryReportWhereUniqueInput
  }

  /**
   * DeliveryReport findFirst
   */
  export type DeliveryReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryReport
     */
    select?: DeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryReport
     */
    omit?: DeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryReportInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryReport to fetch.
     */
    where?: DeliveryReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryReports to fetch.
     */
    orderBy?: DeliveryReportOrderByWithRelationInput | DeliveryReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryReports.
     */
    cursor?: DeliveryReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryReports.
     */
    distinct?: DeliveryReportScalarFieldEnum | DeliveryReportScalarFieldEnum[]
  }

  /**
   * DeliveryReport findFirstOrThrow
   */
  export type DeliveryReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryReport
     */
    select?: DeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryReport
     */
    omit?: DeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryReportInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryReport to fetch.
     */
    where?: DeliveryReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryReports to fetch.
     */
    orderBy?: DeliveryReportOrderByWithRelationInput | DeliveryReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryReports.
     */
    cursor?: DeliveryReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryReports.
     */
    distinct?: DeliveryReportScalarFieldEnum | DeliveryReportScalarFieldEnum[]
  }

  /**
   * DeliveryReport findMany
   */
  export type DeliveryReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryReport
     */
    select?: DeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryReport
     */
    omit?: DeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryReportInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryReports to fetch.
     */
    where?: DeliveryReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryReports to fetch.
     */
    orderBy?: DeliveryReportOrderByWithRelationInput | DeliveryReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryReports.
     */
    cursor?: DeliveryReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryReports.
     */
    skip?: number
    distinct?: DeliveryReportScalarFieldEnum | DeliveryReportScalarFieldEnum[]
  }

  /**
   * DeliveryReport create
   */
  export type DeliveryReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryReport
     */
    select?: DeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryReport
     */
    omit?: DeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryReportInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryReport.
     */
    data: XOR<DeliveryReportCreateInput, DeliveryReportUncheckedCreateInput>
  }

  /**
   * DeliveryReport createMany
   */
  export type DeliveryReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryReports.
     */
    data: DeliveryReportCreateManyInput | DeliveryReportCreateManyInput[]
  }

  /**
   * DeliveryReport update
   */
  export type DeliveryReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryReport
     */
    select?: DeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryReport
     */
    omit?: DeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryReportInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryReport.
     */
    data: XOR<DeliveryReportUpdateInput, DeliveryReportUncheckedUpdateInput>
    /**
     * Choose, which DeliveryReport to update.
     */
    where: DeliveryReportWhereUniqueInput
  }

  /**
   * DeliveryReport updateMany
   */
  export type DeliveryReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryReports.
     */
    data: XOR<DeliveryReportUpdateManyMutationInput, DeliveryReportUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryReports to update
     */
    where?: DeliveryReportWhereInput
    /**
     * Limit how many DeliveryReports to update.
     */
    limit?: number
  }

  /**
   * DeliveryReport upsert
   */
  export type DeliveryReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryReport
     */
    select?: DeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryReport
     */
    omit?: DeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryReportInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryReport to update in case it exists.
     */
    where: DeliveryReportWhereUniqueInput
    /**
     * In case the DeliveryReport found by the `where` argument doesn't exist, create a new DeliveryReport with this data.
     */
    create: XOR<DeliveryReportCreateInput, DeliveryReportUncheckedCreateInput>
    /**
     * In case the DeliveryReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryReportUpdateInput, DeliveryReportUncheckedUpdateInput>
  }

  /**
   * DeliveryReport delete
   */
  export type DeliveryReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryReport
     */
    select?: DeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryReport
     */
    omit?: DeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryReportInclude<ExtArgs> | null
    /**
     * Filter which DeliveryReport to delete.
     */
    where: DeliveryReportWhereUniqueInput
  }

  /**
   * DeliveryReport deleteMany
   */
  export type DeliveryReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryReports to delete
     */
    where?: DeliveryReportWhereInput
    /**
     * Limit how many DeliveryReports to delete.
     */
    limit?: number
  }

  /**
   * DeliveryReport findRaw
   */
  export type DeliveryReportFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DeliveryReport aggregateRaw
   */
  export type DeliveryReportAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DeliveryReport without action
   */
  export type DeliveryReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryReport
     */
    select?: DeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryReport
     */
    omit?: DeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryReportInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.OrderStatus | null
    orderDate: Date | null
    promoCodeId: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.OrderStatus | null
    orderDate: Date | null
    promoCodeId: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    orderDate: number
    promoCodeId: number
    _all: number
  }


  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    orderDate?: true
    promoCodeId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    orderDate?: true
    promoCodeId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    orderDate?: true
    promoCodeId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.OrderStatus
    orderDate: Date
    promoCodeId: string | null
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    orderDate?: boolean
    promoCodeId?: boolean
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    invoice?: boolean | Order$invoiceArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    promoCode?: boolean | Order$promoCodeArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>



  export type OrderSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    orderDate?: boolean
    promoCodeId?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "orderDate" | "promoCodeId", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    invoice?: boolean | Order$invoiceArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    promoCode?: boolean | Order$promoCodeArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      promoCode: Prisma.$PromoCodePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.OrderStatus
      orderDate: Date
      promoCodeId: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * @param {OrderFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const order = await prisma.order.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OrderFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Order.
     * @param {OrderAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const order = await prisma.order.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OrderAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Order$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice<T extends Order$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Order$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    promoCode<T extends Order$promoCodeArgs<ExtArgs> = {}>(args?: Subset<T, Order$promoCodeArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly orderDate: FieldRef<"Order", 'DateTime'>
    readonly promoCodeId: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order findRaw
   */
  export type OrderFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Order aggregateRaw
   */
  export type OrderAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Order.orderItems
   */
  export type Order$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.invoice
   */
  export type Order$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Order.promoCode
   */
  export type Order$promoCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    where?: PromoCodeWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    unitPrice: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    quantity: number
    unitPrice: number
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>



  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "quantity" | "unitPrice", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      quantity: number
      unitPrice: number
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * @param {OrderItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const orderItem = await prisma.orderItem.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OrderItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OrderItem.
     * @param {OrderItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const orderItem = await prisma.orderItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OrderItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly unitPrice: FieldRef<"OrderItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem findRaw
   */
  export type OrderItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OrderItem aggregateRaw
   */
  export type OrderItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    totalAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    totalAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    invoiceDate: Date | null
    totalAmount: number | null
    pdfUrl: string | null
    status: $Enums.InvoiceStatus | null
    sentAt: Date | null
    paidAt: Date | null
    dueDate: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    invoiceDate: Date | null
    totalAmount: number | null
    pdfUrl: string | null
    status: $Enums.InvoiceStatus | null
    sentAt: Date | null
    paidAt: Date | null
    dueDate: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    orderId: number
    invoiceDate: number
    totalAmount: number
    pdfUrl: number
    status: number
    sentAt: number
    paidAt: number
    dueDate: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    totalAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    totalAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    orderId?: true
    invoiceDate?: true
    totalAmount?: true
    pdfUrl?: true
    status?: true
    sentAt?: true
    paidAt?: true
    dueDate?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    orderId?: true
    invoiceDate?: true
    totalAmount?: true
    pdfUrl?: true
    status?: true
    sentAt?: true
    paidAt?: true
    dueDate?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    orderId?: true
    invoiceDate?: true
    totalAmount?: true
    pdfUrl?: true
    status?: true
    sentAt?: true
    paidAt?: true
    dueDate?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    orderId: string
    invoiceDate: Date
    totalAmount: number
    pdfUrl: string
    status: $Enums.InvoiceStatus
    sentAt: Date | null
    paidAt: Date | null
    dueDate: Date | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    invoiceDate?: boolean
    totalAmount?: boolean
    pdfUrl?: boolean
    status?: boolean
    sentAt?: boolean
    paidAt?: boolean
    dueDate?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>



  export type InvoiceSelectScalar = {
    id?: boolean
    orderId?: boolean
    invoiceDate?: boolean
    totalAmount?: boolean
    pdfUrl?: boolean
    status?: boolean
    sentAt?: boolean
    paidAt?: boolean
    dueDate?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "invoiceDate" | "totalAmount" | "pdfUrl" | "status" | "sentAt" | "paidAt" | "dueDate", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      invoiceDate: Date
      totalAmount: number
      pdfUrl: string
      status: $Enums.InvoiceStatus
      sentAt: Date | null
      paidAt: Date | null
      dueDate: Date | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * @param {InvoiceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const invoice = await prisma.invoice.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: InvoiceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Invoice.
     * @param {InvoiceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const invoice = await prisma.invoice.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InvoiceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly orderId: FieldRef<"Invoice", 'String'>
    readonly invoiceDate: FieldRef<"Invoice", 'DateTime'>
    readonly totalAmount: FieldRef<"Invoice", 'Float'>
    readonly pdfUrl: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly sentAt: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice findRaw
   */
  export type InvoiceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Invoice aggregateRaw
   */
  export type InvoiceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model LiveLocation
   */

  export type AggregateLiveLocation = {
    _count: LiveLocationCountAggregateOutputType | null
    _avg: LiveLocationAvgAggregateOutputType | null
    _sum: LiveLocationSumAggregateOutputType | null
    _min: LiveLocationMinAggregateOutputType | null
    _max: LiveLocationMaxAggregateOutputType | null
  }

  export type LiveLocationAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LiveLocationSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LiveLocationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    latitude: number | null
    longitude: number | null
    timeStamp: Date | null
  }

  export type LiveLocationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    latitude: number | null
    longitude: number | null
    timeStamp: Date | null
  }

  export type LiveLocationCountAggregateOutputType = {
    id: number
    userId: number
    latitude: number
    longitude: number
    timeStamp: number
    _all: number
  }


  export type LiveLocationAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LiveLocationSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LiveLocationMinAggregateInputType = {
    id?: true
    userId?: true
    latitude?: true
    longitude?: true
    timeStamp?: true
  }

  export type LiveLocationMaxAggregateInputType = {
    id?: true
    userId?: true
    latitude?: true
    longitude?: true
    timeStamp?: true
  }

  export type LiveLocationCountAggregateInputType = {
    id?: true
    userId?: true
    latitude?: true
    longitude?: true
    timeStamp?: true
    _all?: true
  }

  export type LiveLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiveLocation to aggregate.
     */
    where?: LiveLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveLocations to fetch.
     */
    orderBy?: LiveLocationOrderByWithRelationInput | LiveLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiveLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiveLocations
    **/
    _count?: true | LiveLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiveLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiveLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiveLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiveLocationMaxAggregateInputType
  }

  export type GetLiveLocationAggregateType<T extends LiveLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLiveLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiveLocation[P]>
      : GetScalarType<T[P], AggregateLiveLocation[P]>
  }




  export type LiveLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiveLocationWhereInput
    orderBy?: LiveLocationOrderByWithAggregationInput | LiveLocationOrderByWithAggregationInput[]
    by: LiveLocationScalarFieldEnum[] | LiveLocationScalarFieldEnum
    having?: LiveLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiveLocationCountAggregateInputType | true
    _avg?: LiveLocationAvgAggregateInputType
    _sum?: LiveLocationSumAggregateInputType
    _min?: LiveLocationMinAggregateInputType
    _max?: LiveLocationMaxAggregateInputType
  }

  export type LiveLocationGroupByOutputType = {
    id: string
    userId: string
    latitude: number
    longitude: number
    timeStamp: Date
    _count: LiveLocationCountAggregateOutputType | null
    _avg: LiveLocationAvgAggregateOutputType | null
    _sum: LiveLocationSumAggregateOutputType | null
    _min: LiveLocationMinAggregateOutputType | null
    _max: LiveLocationMaxAggregateOutputType | null
  }

  type GetLiveLocationGroupByPayload<T extends LiveLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiveLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiveLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiveLocationGroupByOutputType[P]>
            : GetScalarType<T[P], LiveLocationGroupByOutputType[P]>
        }
      >
    >


  export type LiveLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    latitude?: boolean
    longitude?: boolean
    timeStamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liveLocation"]>



  export type LiveLocationSelectScalar = {
    id?: boolean
    userId?: boolean
    latitude?: boolean
    longitude?: boolean
    timeStamp?: boolean
  }

  export type LiveLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "latitude" | "longitude" | "timeStamp", ExtArgs["result"]["liveLocation"]>
  export type LiveLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LiveLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiveLocation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      latitude: number
      longitude: number
      timeStamp: Date
    }, ExtArgs["result"]["liveLocation"]>
    composites: {}
  }

  type LiveLocationGetPayload<S extends boolean | null | undefined | LiveLocationDefaultArgs> = $Result.GetResult<Prisma.$LiveLocationPayload, S>

  type LiveLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiveLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiveLocationCountAggregateInputType | true
    }

  export interface LiveLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiveLocation'], meta: { name: 'LiveLocation' } }
    /**
     * Find zero or one LiveLocation that matches the filter.
     * @param {LiveLocationFindUniqueArgs} args - Arguments to find a LiveLocation
     * @example
     * // Get one LiveLocation
     * const liveLocation = await prisma.liveLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiveLocationFindUniqueArgs>(args: SelectSubset<T, LiveLocationFindUniqueArgs<ExtArgs>>): Prisma__LiveLocationClient<$Result.GetResult<Prisma.$LiveLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LiveLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiveLocationFindUniqueOrThrowArgs} args - Arguments to find a LiveLocation
     * @example
     * // Get one LiveLocation
     * const liveLocation = await prisma.liveLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiveLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LiveLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiveLocationClient<$Result.GetResult<Prisma.$LiveLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LiveLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveLocationFindFirstArgs} args - Arguments to find a LiveLocation
     * @example
     * // Get one LiveLocation
     * const liveLocation = await prisma.liveLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiveLocationFindFirstArgs>(args?: SelectSubset<T, LiveLocationFindFirstArgs<ExtArgs>>): Prisma__LiveLocationClient<$Result.GetResult<Prisma.$LiveLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LiveLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveLocationFindFirstOrThrowArgs} args - Arguments to find a LiveLocation
     * @example
     * // Get one LiveLocation
     * const liveLocation = await prisma.liveLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiveLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LiveLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiveLocationClient<$Result.GetResult<Prisma.$LiveLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LiveLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiveLocations
     * const liveLocations = await prisma.liveLocation.findMany()
     * 
     * // Get first 10 LiveLocations
     * const liveLocations = await prisma.liveLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liveLocationWithIdOnly = await prisma.liveLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiveLocationFindManyArgs>(args?: SelectSubset<T, LiveLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiveLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LiveLocation.
     * @param {LiveLocationCreateArgs} args - Arguments to create a LiveLocation.
     * @example
     * // Create one LiveLocation
     * const LiveLocation = await prisma.liveLocation.create({
     *   data: {
     *     // ... data to create a LiveLocation
     *   }
     * })
     * 
     */
    create<T extends LiveLocationCreateArgs>(args: SelectSubset<T, LiveLocationCreateArgs<ExtArgs>>): Prisma__LiveLocationClient<$Result.GetResult<Prisma.$LiveLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LiveLocations.
     * @param {LiveLocationCreateManyArgs} args - Arguments to create many LiveLocations.
     * @example
     * // Create many LiveLocations
     * const liveLocation = await prisma.liveLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiveLocationCreateManyArgs>(args?: SelectSubset<T, LiveLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LiveLocation.
     * @param {LiveLocationDeleteArgs} args - Arguments to delete one LiveLocation.
     * @example
     * // Delete one LiveLocation
     * const LiveLocation = await prisma.liveLocation.delete({
     *   where: {
     *     // ... filter to delete one LiveLocation
     *   }
     * })
     * 
     */
    delete<T extends LiveLocationDeleteArgs>(args: SelectSubset<T, LiveLocationDeleteArgs<ExtArgs>>): Prisma__LiveLocationClient<$Result.GetResult<Prisma.$LiveLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LiveLocation.
     * @param {LiveLocationUpdateArgs} args - Arguments to update one LiveLocation.
     * @example
     * // Update one LiveLocation
     * const liveLocation = await prisma.liveLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiveLocationUpdateArgs>(args: SelectSubset<T, LiveLocationUpdateArgs<ExtArgs>>): Prisma__LiveLocationClient<$Result.GetResult<Prisma.$LiveLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LiveLocations.
     * @param {LiveLocationDeleteManyArgs} args - Arguments to filter LiveLocations to delete.
     * @example
     * // Delete a few LiveLocations
     * const { count } = await prisma.liveLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiveLocationDeleteManyArgs>(args?: SelectSubset<T, LiveLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiveLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiveLocations
     * const liveLocation = await prisma.liveLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiveLocationUpdateManyArgs>(args: SelectSubset<T, LiveLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LiveLocation.
     * @param {LiveLocationUpsertArgs} args - Arguments to update or create a LiveLocation.
     * @example
     * // Update or create a LiveLocation
     * const liveLocation = await prisma.liveLocation.upsert({
     *   create: {
     *     // ... data to create a LiveLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiveLocation we want to update
     *   }
     * })
     */
    upsert<T extends LiveLocationUpsertArgs>(args: SelectSubset<T, LiveLocationUpsertArgs<ExtArgs>>): Prisma__LiveLocationClient<$Result.GetResult<Prisma.$LiveLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LiveLocations that matches the filter.
     * @param {LiveLocationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const liveLocation = await prisma.liveLocation.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LiveLocationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a LiveLocation.
     * @param {LiveLocationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const liveLocation = await prisma.liveLocation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LiveLocationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of LiveLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveLocationCountArgs} args - Arguments to filter LiveLocations to count.
     * @example
     * // Count the number of LiveLocations
     * const count = await prisma.liveLocation.count({
     *   where: {
     *     // ... the filter for the LiveLocations we want to count
     *   }
     * })
    **/
    count<T extends LiveLocationCountArgs>(
      args?: Subset<T, LiveLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiveLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiveLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiveLocationAggregateArgs>(args: Subset<T, LiveLocationAggregateArgs>): Prisma.PrismaPromise<GetLiveLocationAggregateType<T>>

    /**
     * Group by LiveLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiveLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiveLocationGroupByArgs['orderBy'] }
        : { orderBy?: LiveLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiveLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiveLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiveLocation model
   */
  readonly fields: LiveLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiveLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiveLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiveLocation model
   */
  interface LiveLocationFieldRefs {
    readonly id: FieldRef<"LiveLocation", 'String'>
    readonly userId: FieldRef<"LiveLocation", 'String'>
    readonly latitude: FieldRef<"LiveLocation", 'Float'>
    readonly longitude: FieldRef<"LiveLocation", 'Float'>
    readonly timeStamp: FieldRef<"LiveLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LiveLocation findUnique
   */
  export type LiveLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveLocation
     */
    select?: LiveLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveLocation
     */
    omit?: LiveLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveLocationInclude<ExtArgs> | null
    /**
     * Filter, which LiveLocation to fetch.
     */
    where: LiveLocationWhereUniqueInput
  }

  /**
   * LiveLocation findUniqueOrThrow
   */
  export type LiveLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveLocation
     */
    select?: LiveLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveLocation
     */
    omit?: LiveLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveLocationInclude<ExtArgs> | null
    /**
     * Filter, which LiveLocation to fetch.
     */
    where: LiveLocationWhereUniqueInput
  }

  /**
   * LiveLocation findFirst
   */
  export type LiveLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveLocation
     */
    select?: LiveLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveLocation
     */
    omit?: LiveLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveLocationInclude<ExtArgs> | null
    /**
     * Filter, which LiveLocation to fetch.
     */
    where?: LiveLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveLocations to fetch.
     */
    orderBy?: LiveLocationOrderByWithRelationInput | LiveLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiveLocations.
     */
    cursor?: LiveLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiveLocations.
     */
    distinct?: LiveLocationScalarFieldEnum | LiveLocationScalarFieldEnum[]
  }

  /**
   * LiveLocation findFirstOrThrow
   */
  export type LiveLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveLocation
     */
    select?: LiveLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveLocation
     */
    omit?: LiveLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveLocationInclude<ExtArgs> | null
    /**
     * Filter, which LiveLocation to fetch.
     */
    where?: LiveLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveLocations to fetch.
     */
    orderBy?: LiveLocationOrderByWithRelationInput | LiveLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiveLocations.
     */
    cursor?: LiveLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiveLocations.
     */
    distinct?: LiveLocationScalarFieldEnum | LiveLocationScalarFieldEnum[]
  }

  /**
   * LiveLocation findMany
   */
  export type LiveLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveLocation
     */
    select?: LiveLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveLocation
     */
    omit?: LiveLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveLocationInclude<ExtArgs> | null
    /**
     * Filter, which LiveLocations to fetch.
     */
    where?: LiveLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveLocations to fetch.
     */
    orderBy?: LiveLocationOrderByWithRelationInput | LiveLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiveLocations.
     */
    cursor?: LiveLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveLocations.
     */
    skip?: number
    distinct?: LiveLocationScalarFieldEnum | LiveLocationScalarFieldEnum[]
  }

  /**
   * LiveLocation create
   */
  export type LiveLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveLocation
     */
    select?: LiveLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveLocation
     */
    omit?: LiveLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a LiveLocation.
     */
    data: XOR<LiveLocationCreateInput, LiveLocationUncheckedCreateInput>
  }

  /**
   * LiveLocation createMany
   */
  export type LiveLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiveLocations.
     */
    data: LiveLocationCreateManyInput | LiveLocationCreateManyInput[]
  }

  /**
   * LiveLocation update
   */
  export type LiveLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveLocation
     */
    select?: LiveLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveLocation
     */
    omit?: LiveLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a LiveLocation.
     */
    data: XOR<LiveLocationUpdateInput, LiveLocationUncheckedUpdateInput>
    /**
     * Choose, which LiveLocation to update.
     */
    where: LiveLocationWhereUniqueInput
  }

  /**
   * LiveLocation updateMany
   */
  export type LiveLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiveLocations.
     */
    data: XOR<LiveLocationUpdateManyMutationInput, LiveLocationUncheckedUpdateManyInput>
    /**
     * Filter which LiveLocations to update
     */
    where?: LiveLocationWhereInput
    /**
     * Limit how many LiveLocations to update.
     */
    limit?: number
  }

  /**
   * LiveLocation upsert
   */
  export type LiveLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveLocation
     */
    select?: LiveLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveLocation
     */
    omit?: LiveLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the LiveLocation to update in case it exists.
     */
    where: LiveLocationWhereUniqueInput
    /**
     * In case the LiveLocation found by the `where` argument doesn't exist, create a new LiveLocation with this data.
     */
    create: XOR<LiveLocationCreateInput, LiveLocationUncheckedCreateInput>
    /**
     * In case the LiveLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiveLocationUpdateInput, LiveLocationUncheckedUpdateInput>
  }

  /**
   * LiveLocation delete
   */
  export type LiveLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveLocation
     */
    select?: LiveLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveLocation
     */
    omit?: LiveLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveLocationInclude<ExtArgs> | null
    /**
     * Filter which LiveLocation to delete.
     */
    where: LiveLocationWhereUniqueInput
  }

  /**
   * LiveLocation deleteMany
   */
  export type LiveLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiveLocations to delete
     */
    where?: LiveLocationWhereInput
    /**
     * Limit how many LiveLocations to delete.
     */
    limit?: number
  }

  /**
   * LiveLocation findRaw
   */
  export type LiveLocationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LiveLocation aggregateRaw
   */
  export type LiveLocationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LiveLocation without action
   */
  export type LiveLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveLocation
     */
    select?: LiveLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveLocation
     */
    omit?: LiveLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveLocationInclude<ExtArgs> | null
  }


  /**
   * Model ShiftAlert
   */

  export type AggregateShiftAlert = {
    _count: ShiftAlertCountAggregateOutputType | null
    _min: ShiftAlertMinAggregateOutputType | null
    _max: ShiftAlertMaxAggregateOutputType | null
  }

  export type ShiftAlertMinAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    createdAt: Date | null
    acknowledged: boolean | null
  }

  export type ShiftAlertMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    createdAt: Date | null
    acknowledged: boolean | null
  }

  export type ShiftAlertCountAggregateOutputType = {
    id: number
    userId: number
    message: number
    createdAt: number
    acknowledged: number
    _all: number
  }


  export type ShiftAlertMinAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    createdAt?: true
    acknowledged?: true
  }

  export type ShiftAlertMaxAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    createdAt?: true
    acknowledged?: true
  }

  export type ShiftAlertCountAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    createdAt?: true
    acknowledged?: true
    _all?: true
  }

  export type ShiftAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftAlert to aggregate.
     */
    where?: ShiftAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftAlerts to fetch.
     */
    orderBy?: ShiftAlertOrderByWithRelationInput | ShiftAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShiftAlerts
    **/
    _count?: true | ShiftAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftAlertMaxAggregateInputType
  }

  export type GetShiftAlertAggregateType<T extends ShiftAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateShiftAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiftAlert[P]>
      : GetScalarType<T[P], AggregateShiftAlert[P]>
  }




  export type ShiftAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftAlertWhereInput
    orderBy?: ShiftAlertOrderByWithAggregationInput | ShiftAlertOrderByWithAggregationInput[]
    by: ShiftAlertScalarFieldEnum[] | ShiftAlertScalarFieldEnum
    having?: ShiftAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftAlertCountAggregateInputType | true
    _min?: ShiftAlertMinAggregateInputType
    _max?: ShiftAlertMaxAggregateInputType
  }

  export type ShiftAlertGroupByOutputType = {
    id: string
    userId: string
    message: string
    createdAt: Date
    acknowledged: boolean
    _count: ShiftAlertCountAggregateOutputType | null
    _min: ShiftAlertMinAggregateOutputType | null
    _max: ShiftAlertMaxAggregateOutputType | null
  }

  type GetShiftAlertGroupByPayload<T extends ShiftAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftAlertGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftAlertGroupByOutputType[P]>
        }
      >
    >


  export type ShiftAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    createdAt?: boolean
    acknowledged?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftAlert"]>



  export type ShiftAlertSelectScalar = {
    id?: boolean
    userId?: boolean
    message?: boolean
    createdAt?: boolean
    acknowledged?: boolean
  }

  export type ShiftAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "message" | "createdAt" | "acknowledged", ExtArgs["result"]["shiftAlert"]>
  export type ShiftAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ShiftAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShiftAlert"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      message: string
      createdAt: Date
      acknowledged: boolean
    }, ExtArgs["result"]["shiftAlert"]>
    composites: {}
  }

  type ShiftAlertGetPayload<S extends boolean | null | undefined | ShiftAlertDefaultArgs> = $Result.GetResult<Prisma.$ShiftAlertPayload, S>

  type ShiftAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftAlertCountAggregateInputType | true
    }

  export interface ShiftAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShiftAlert'], meta: { name: 'ShiftAlert' } }
    /**
     * Find zero or one ShiftAlert that matches the filter.
     * @param {ShiftAlertFindUniqueArgs} args - Arguments to find a ShiftAlert
     * @example
     * // Get one ShiftAlert
     * const shiftAlert = await prisma.shiftAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftAlertFindUniqueArgs>(args: SelectSubset<T, ShiftAlertFindUniqueArgs<ExtArgs>>): Prisma__ShiftAlertClient<$Result.GetResult<Prisma.$ShiftAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShiftAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftAlertFindUniqueOrThrowArgs} args - Arguments to find a ShiftAlert
     * @example
     * // Get one ShiftAlert
     * const shiftAlert = await prisma.shiftAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftAlertClient<$Result.GetResult<Prisma.$ShiftAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAlertFindFirstArgs} args - Arguments to find a ShiftAlert
     * @example
     * // Get one ShiftAlert
     * const shiftAlert = await prisma.shiftAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftAlertFindFirstArgs>(args?: SelectSubset<T, ShiftAlertFindFirstArgs<ExtArgs>>): Prisma__ShiftAlertClient<$Result.GetResult<Prisma.$ShiftAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAlertFindFirstOrThrowArgs} args - Arguments to find a ShiftAlert
     * @example
     * // Get one ShiftAlert
     * const shiftAlert = await prisma.shiftAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftAlertClient<$Result.GetResult<Prisma.$ShiftAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShiftAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShiftAlerts
     * const shiftAlerts = await prisma.shiftAlert.findMany()
     * 
     * // Get first 10 ShiftAlerts
     * const shiftAlerts = await prisma.shiftAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftAlertWithIdOnly = await prisma.shiftAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftAlertFindManyArgs>(args?: SelectSubset<T, ShiftAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShiftAlert.
     * @param {ShiftAlertCreateArgs} args - Arguments to create a ShiftAlert.
     * @example
     * // Create one ShiftAlert
     * const ShiftAlert = await prisma.shiftAlert.create({
     *   data: {
     *     // ... data to create a ShiftAlert
     *   }
     * })
     * 
     */
    create<T extends ShiftAlertCreateArgs>(args: SelectSubset<T, ShiftAlertCreateArgs<ExtArgs>>): Prisma__ShiftAlertClient<$Result.GetResult<Prisma.$ShiftAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShiftAlerts.
     * @param {ShiftAlertCreateManyArgs} args - Arguments to create many ShiftAlerts.
     * @example
     * // Create many ShiftAlerts
     * const shiftAlert = await prisma.shiftAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftAlertCreateManyArgs>(args?: SelectSubset<T, ShiftAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShiftAlert.
     * @param {ShiftAlertDeleteArgs} args - Arguments to delete one ShiftAlert.
     * @example
     * // Delete one ShiftAlert
     * const ShiftAlert = await prisma.shiftAlert.delete({
     *   where: {
     *     // ... filter to delete one ShiftAlert
     *   }
     * })
     * 
     */
    delete<T extends ShiftAlertDeleteArgs>(args: SelectSubset<T, ShiftAlertDeleteArgs<ExtArgs>>): Prisma__ShiftAlertClient<$Result.GetResult<Prisma.$ShiftAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShiftAlert.
     * @param {ShiftAlertUpdateArgs} args - Arguments to update one ShiftAlert.
     * @example
     * // Update one ShiftAlert
     * const shiftAlert = await prisma.shiftAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftAlertUpdateArgs>(args: SelectSubset<T, ShiftAlertUpdateArgs<ExtArgs>>): Prisma__ShiftAlertClient<$Result.GetResult<Prisma.$ShiftAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShiftAlerts.
     * @param {ShiftAlertDeleteManyArgs} args - Arguments to filter ShiftAlerts to delete.
     * @example
     * // Delete a few ShiftAlerts
     * const { count } = await prisma.shiftAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftAlertDeleteManyArgs>(args?: SelectSubset<T, ShiftAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShiftAlerts
     * const shiftAlert = await prisma.shiftAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftAlertUpdateManyArgs>(args: SelectSubset<T, ShiftAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShiftAlert.
     * @param {ShiftAlertUpsertArgs} args - Arguments to update or create a ShiftAlert.
     * @example
     * // Update or create a ShiftAlert
     * const shiftAlert = await prisma.shiftAlert.upsert({
     *   create: {
     *     // ... data to create a ShiftAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShiftAlert we want to update
     *   }
     * })
     */
    upsert<T extends ShiftAlertUpsertArgs>(args: SelectSubset<T, ShiftAlertUpsertArgs<ExtArgs>>): Prisma__ShiftAlertClient<$Result.GetResult<Prisma.$ShiftAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShiftAlerts that matches the filter.
     * @param {ShiftAlertFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const shiftAlert = await prisma.shiftAlert.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ShiftAlertFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ShiftAlert.
     * @param {ShiftAlertAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const shiftAlert = await prisma.shiftAlert.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ShiftAlertAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ShiftAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAlertCountArgs} args - Arguments to filter ShiftAlerts to count.
     * @example
     * // Count the number of ShiftAlerts
     * const count = await prisma.shiftAlert.count({
     *   where: {
     *     // ... the filter for the ShiftAlerts we want to count
     *   }
     * })
    **/
    count<T extends ShiftAlertCountArgs>(
      args?: Subset<T, ShiftAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShiftAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAlertAggregateArgs>(args: Subset<T, ShiftAlertAggregateArgs>): Prisma.PrismaPromise<GetShiftAlertAggregateType<T>>

    /**
     * Group by ShiftAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftAlertGroupByArgs['orderBy'] }
        : { orderBy?: ShiftAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShiftAlert model
   */
  readonly fields: ShiftAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShiftAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShiftAlert model
   */
  interface ShiftAlertFieldRefs {
    readonly id: FieldRef<"ShiftAlert", 'String'>
    readonly userId: FieldRef<"ShiftAlert", 'String'>
    readonly message: FieldRef<"ShiftAlert", 'String'>
    readonly createdAt: FieldRef<"ShiftAlert", 'DateTime'>
    readonly acknowledged: FieldRef<"ShiftAlert", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ShiftAlert findUnique
   */
  export type ShiftAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAlert
     */
    select?: ShiftAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftAlert
     */
    omit?: ShiftAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAlertInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAlert to fetch.
     */
    where: ShiftAlertWhereUniqueInput
  }

  /**
   * ShiftAlert findUniqueOrThrow
   */
  export type ShiftAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAlert
     */
    select?: ShiftAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftAlert
     */
    omit?: ShiftAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAlertInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAlert to fetch.
     */
    where: ShiftAlertWhereUniqueInput
  }

  /**
   * ShiftAlert findFirst
   */
  export type ShiftAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAlert
     */
    select?: ShiftAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftAlert
     */
    omit?: ShiftAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAlertInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAlert to fetch.
     */
    where?: ShiftAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftAlerts to fetch.
     */
    orderBy?: ShiftAlertOrderByWithRelationInput | ShiftAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftAlerts.
     */
    cursor?: ShiftAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftAlerts.
     */
    distinct?: ShiftAlertScalarFieldEnum | ShiftAlertScalarFieldEnum[]
  }

  /**
   * ShiftAlert findFirstOrThrow
   */
  export type ShiftAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAlert
     */
    select?: ShiftAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftAlert
     */
    omit?: ShiftAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAlertInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAlert to fetch.
     */
    where?: ShiftAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftAlerts to fetch.
     */
    orderBy?: ShiftAlertOrderByWithRelationInput | ShiftAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftAlerts.
     */
    cursor?: ShiftAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftAlerts.
     */
    distinct?: ShiftAlertScalarFieldEnum | ShiftAlertScalarFieldEnum[]
  }

  /**
   * ShiftAlert findMany
   */
  export type ShiftAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAlert
     */
    select?: ShiftAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftAlert
     */
    omit?: ShiftAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAlertInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAlerts to fetch.
     */
    where?: ShiftAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftAlerts to fetch.
     */
    orderBy?: ShiftAlertOrderByWithRelationInput | ShiftAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShiftAlerts.
     */
    cursor?: ShiftAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftAlerts.
     */
    skip?: number
    distinct?: ShiftAlertScalarFieldEnum | ShiftAlertScalarFieldEnum[]
  }

  /**
   * ShiftAlert create
   */
  export type ShiftAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAlert
     */
    select?: ShiftAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftAlert
     */
    omit?: ShiftAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a ShiftAlert.
     */
    data: XOR<ShiftAlertCreateInput, ShiftAlertUncheckedCreateInput>
  }

  /**
   * ShiftAlert createMany
   */
  export type ShiftAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShiftAlerts.
     */
    data: ShiftAlertCreateManyInput | ShiftAlertCreateManyInput[]
  }

  /**
   * ShiftAlert update
   */
  export type ShiftAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAlert
     */
    select?: ShiftAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftAlert
     */
    omit?: ShiftAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a ShiftAlert.
     */
    data: XOR<ShiftAlertUpdateInput, ShiftAlertUncheckedUpdateInput>
    /**
     * Choose, which ShiftAlert to update.
     */
    where: ShiftAlertWhereUniqueInput
  }

  /**
   * ShiftAlert updateMany
   */
  export type ShiftAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShiftAlerts.
     */
    data: XOR<ShiftAlertUpdateManyMutationInput, ShiftAlertUncheckedUpdateManyInput>
    /**
     * Filter which ShiftAlerts to update
     */
    where?: ShiftAlertWhereInput
    /**
     * Limit how many ShiftAlerts to update.
     */
    limit?: number
  }

  /**
   * ShiftAlert upsert
   */
  export type ShiftAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAlert
     */
    select?: ShiftAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftAlert
     */
    omit?: ShiftAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the ShiftAlert to update in case it exists.
     */
    where: ShiftAlertWhereUniqueInput
    /**
     * In case the ShiftAlert found by the `where` argument doesn't exist, create a new ShiftAlert with this data.
     */
    create: XOR<ShiftAlertCreateInput, ShiftAlertUncheckedCreateInput>
    /**
     * In case the ShiftAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftAlertUpdateInput, ShiftAlertUncheckedUpdateInput>
  }

  /**
   * ShiftAlert delete
   */
  export type ShiftAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAlert
     */
    select?: ShiftAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftAlert
     */
    omit?: ShiftAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAlertInclude<ExtArgs> | null
    /**
     * Filter which ShiftAlert to delete.
     */
    where: ShiftAlertWhereUniqueInput
  }

  /**
   * ShiftAlert deleteMany
   */
  export type ShiftAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftAlerts to delete
     */
    where?: ShiftAlertWhereInput
    /**
     * Limit how many ShiftAlerts to delete.
     */
    limit?: number
  }

  /**
   * ShiftAlert findRaw
   */
  export type ShiftAlertFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ShiftAlert aggregateRaw
   */
  export type ShiftAlertAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ShiftAlert without action
   */
  export type ShiftAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAlert
     */
    select?: ShiftAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftAlert
     */
    omit?: ShiftAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAlertInclude<ExtArgs> | null
  }


  /**
   * Model RegisterWarranty
   */

  export type AggregateRegisterWarranty = {
    _count: RegisterWarrantyCountAggregateOutputType | null
    _avg: RegisterWarrantyAvgAggregateOutputType | null
    _sum: RegisterWarrantySumAggregateOutputType | null
    _min: RegisterWarrantyMinAggregateOutputType | null
    _max: RegisterWarrantyMaxAggregateOutputType | null
  }

  export type RegisterWarrantyAvgAggregateOutputType = {
    warrantyMonths: number | null
  }

  export type RegisterWarrantySumAggregateOutputType = {
    warrantyMonths: number | null
  }

  export type RegisterWarrantyMinAggregateOutputType = {
    id: string | null
    productId: string | null
    serialNumber: string | null
    purchaseDate: Date | null
    warrantyMonths: number | null
    sellerId: string | null
    registeredAt: Date | null
    qrImage: string | null
  }

  export type RegisterWarrantyMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    serialNumber: string | null
    purchaseDate: Date | null
    warrantyMonths: number | null
    sellerId: string | null
    registeredAt: Date | null
    qrImage: string | null
  }

  export type RegisterWarrantyCountAggregateOutputType = {
    id: number
    productId: number
    serialNumber: number
    purchaseDate: number
    warrantyMonths: number
    sellerId: number
    registeredAt: number
    qrImage: number
    _all: number
  }


  export type RegisterWarrantyAvgAggregateInputType = {
    warrantyMonths?: true
  }

  export type RegisterWarrantySumAggregateInputType = {
    warrantyMonths?: true
  }

  export type RegisterWarrantyMinAggregateInputType = {
    id?: true
    productId?: true
    serialNumber?: true
    purchaseDate?: true
    warrantyMonths?: true
    sellerId?: true
    registeredAt?: true
    qrImage?: true
  }

  export type RegisterWarrantyMaxAggregateInputType = {
    id?: true
    productId?: true
    serialNumber?: true
    purchaseDate?: true
    warrantyMonths?: true
    sellerId?: true
    registeredAt?: true
    qrImage?: true
  }

  export type RegisterWarrantyCountAggregateInputType = {
    id?: true
    productId?: true
    serialNumber?: true
    purchaseDate?: true
    warrantyMonths?: true
    sellerId?: true
    registeredAt?: true
    qrImage?: true
    _all?: true
  }

  export type RegisterWarrantyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegisterWarranty to aggregate.
     */
    where?: RegisterWarrantyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterWarranties to fetch.
     */
    orderBy?: RegisterWarrantyOrderByWithRelationInput | RegisterWarrantyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegisterWarrantyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterWarranties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterWarranties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegisterWarranties
    **/
    _count?: true | RegisterWarrantyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegisterWarrantyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegisterWarrantySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegisterWarrantyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegisterWarrantyMaxAggregateInputType
  }

  export type GetRegisterWarrantyAggregateType<T extends RegisterWarrantyAggregateArgs> = {
        [P in keyof T & keyof AggregateRegisterWarranty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegisterWarranty[P]>
      : GetScalarType<T[P], AggregateRegisterWarranty[P]>
  }




  export type RegisterWarrantyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegisterWarrantyWhereInput
    orderBy?: RegisterWarrantyOrderByWithAggregationInput | RegisterWarrantyOrderByWithAggregationInput[]
    by: RegisterWarrantyScalarFieldEnum[] | RegisterWarrantyScalarFieldEnum
    having?: RegisterWarrantyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegisterWarrantyCountAggregateInputType | true
    _avg?: RegisterWarrantyAvgAggregateInputType
    _sum?: RegisterWarrantySumAggregateInputType
    _min?: RegisterWarrantyMinAggregateInputType
    _max?: RegisterWarrantyMaxAggregateInputType
  }

  export type RegisterWarrantyGroupByOutputType = {
    id: string
    productId: string
    serialNumber: string
    purchaseDate: Date
    warrantyMonths: number
    sellerId: string
    registeredAt: Date
    qrImage: string | null
    _count: RegisterWarrantyCountAggregateOutputType | null
    _avg: RegisterWarrantyAvgAggregateOutputType | null
    _sum: RegisterWarrantySumAggregateOutputType | null
    _min: RegisterWarrantyMinAggregateOutputType | null
    _max: RegisterWarrantyMaxAggregateOutputType | null
  }

  type GetRegisterWarrantyGroupByPayload<T extends RegisterWarrantyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegisterWarrantyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegisterWarrantyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegisterWarrantyGroupByOutputType[P]>
            : GetScalarType<T[P], RegisterWarrantyGroupByOutputType[P]>
        }
      >
    >


  export type RegisterWarrantySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    serialNumber?: boolean
    purchaseDate?: boolean
    warrantyMonths?: boolean
    sellerId?: boolean
    registeredAt?: boolean
    qrImage?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registerWarranty"]>



  export type RegisterWarrantySelectScalar = {
    id?: boolean
    productId?: boolean
    serialNumber?: boolean
    purchaseDate?: boolean
    warrantyMonths?: boolean
    sellerId?: boolean
    registeredAt?: boolean
    qrImage?: boolean
  }

  export type RegisterWarrantyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "serialNumber" | "purchaseDate" | "warrantyMonths" | "sellerId" | "registeredAt" | "qrImage", ExtArgs["result"]["registerWarranty"]>
  export type RegisterWarrantyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RegisterWarrantyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegisterWarranty"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      seller: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      serialNumber: string
      purchaseDate: Date
      warrantyMonths: number
      sellerId: string
      registeredAt: Date
      qrImage: string | null
    }, ExtArgs["result"]["registerWarranty"]>
    composites: {}
  }

  type RegisterWarrantyGetPayload<S extends boolean | null | undefined | RegisterWarrantyDefaultArgs> = $Result.GetResult<Prisma.$RegisterWarrantyPayload, S>

  type RegisterWarrantyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegisterWarrantyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegisterWarrantyCountAggregateInputType | true
    }

  export interface RegisterWarrantyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegisterWarranty'], meta: { name: 'RegisterWarranty' } }
    /**
     * Find zero or one RegisterWarranty that matches the filter.
     * @param {RegisterWarrantyFindUniqueArgs} args - Arguments to find a RegisterWarranty
     * @example
     * // Get one RegisterWarranty
     * const registerWarranty = await prisma.registerWarranty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegisterWarrantyFindUniqueArgs>(args: SelectSubset<T, RegisterWarrantyFindUniqueArgs<ExtArgs>>): Prisma__RegisterWarrantyClient<$Result.GetResult<Prisma.$RegisterWarrantyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegisterWarranty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegisterWarrantyFindUniqueOrThrowArgs} args - Arguments to find a RegisterWarranty
     * @example
     * // Get one RegisterWarranty
     * const registerWarranty = await prisma.registerWarranty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegisterWarrantyFindUniqueOrThrowArgs>(args: SelectSubset<T, RegisterWarrantyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegisterWarrantyClient<$Result.GetResult<Prisma.$RegisterWarrantyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegisterWarranty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterWarrantyFindFirstArgs} args - Arguments to find a RegisterWarranty
     * @example
     * // Get one RegisterWarranty
     * const registerWarranty = await prisma.registerWarranty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegisterWarrantyFindFirstArgs>(args?: SelectSubset<T, RegisterWarrantyFindFirstArgs<ExtArgs>>): Prisma__RegisterWarrantyClient<$Result.GetResult<Prisma.$RegisterWarrantyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegisterWarranty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterWarrantyFindFirstOrThrowArgs} args - Arguments to find a RegisterWarranty
     * @example
     * // Get one RegisterWarranty
     * const registerWarranty = await prisma.registerWarranty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegisterWarrantyFindFirstOrThrowArgs>(args?: SelectSubset<T, RegisterWarrantyFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegisterWarrantyClient<$Result.GetResult<Prisma.$RegisterWarrantyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegisterWarranties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterWarrantyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegisterWarranties
     * const registerWarranties = await prisma.registerWarranty.findMany()
     * 
     * // Get first 10 RegisterWarranties
     * const registerWarranties = await prisma.registerWarranty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const registerWarrantyWithIdOnly = await prisma.registerWarranty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegisterWarrantyFindManyArgs>(args?: SelectSubset<T, RegisterWarrantyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisterWarrantyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegisterWarranty.
     * @param {RegisterWarrantyCreateArgs} args - Arguments to create a RegisterWarranty.
     * @example
     * // Create one RegisterWarranty
     * const RegisterWarranty = await prisma.registerWarranty.create({
     *   data: {
     *     // ... data to create a RegisterWarranty
     *   }
     * })
     * 
     */
    create<T extends RegisterWarrantyCreateArgs>(args: SelectSubset<T, RegisterWarrantyCreateArgs<ExtArgs>>): Prisma__RegisterWarrantyClient<$Result.GetResult<Prisma.$RegisterWarrantyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegisterWarranties.
     * @param {RegisterWarrantyCreateManyArgs} args - Arguments to create many RegisterWarranties.
     * @example
     * // Create many RegisterWarranties
     * const registerWarranty = await prisma.registerWarranty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegisterWarrantyCreateManyArgs>(args?: SelectSubset<T, RegisterWarrantyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RegisterWarranty.
     * @param {RegisterWarrantyDeleteArgs} args - Arguments to delete one RegisterWarranty.
     * @example
     * // Delete one RegisterWarranty
     * const RegisterWarranty = await prisma.registerWarranty.delete({
     *   where: {
     *     // ... filter to delete one RegisterWarranty
     *   }
     * })
     * 
     */
    delete<T extends RegisterWarrantyDeleteArgs>(args: SelectSubset<T, RegisterWarrantyDeleteArgs<ExtArgs>>): Prisma__RegisterWarrantyClient<$Result.GetResult<Prisma.$RegisterWarrantyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegisterWarranty.
     * @param {RegisterWarrantyUpdateArgs} args - Arguments to update one RegisterWarranty.
     * @example
     * // Update one RegisterWarranty
     * const registerWarranty = await prisma.registerWarranty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegisterWarrantyUpdateArgs>(args: SelectSubset<T, RegisterWarrantyUpdateArgs<ExtArgs>>): Prisma__RegisterWarrantyClient<$Result.GetResult<Prisma.$RegisterWarrantyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegisterWarranties.
     * @param {RegisterWarrantyDeleteManyArgs} args - Arguments to filter RegisterWarranties to delete.
     * @example
     * // Delete a few RegisterWarranties
     * const { count } = await prisma.registerWarranty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegisterWarrantyDeleteManyArgs>(args?: SelectSubset<T, RegisterWarrantyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegisterWarranties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterWarrantyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegisterWarranties
     * const registerWarranty = await prisma.registerWarranty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegisterWarrantyUpdateManyArgs>(args: SelectSubset<T, RegisterWarrantyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RegisterWarranty.
     * @param {RegisterWarrantyUpsertArgs} args - Arguments to update or create a RegisterWarranty.
     * @example
     * // Update or create a RegisterWarranty
     * const registerWarranty = await prisma.registerWarranty.upsert({
     *   create: {
     *     // ... data to create a RegisterWarranty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegisterWarranty we want to update
     *   }
     * })
     */
    upsert<T extends RegisterWarrantyUpsertArgs>(args: SelectSubset<T, RegisterWarrantyUpsertArgs<ExtArgs>>): Prisma__RegisterWarrantyClient<$Result.GetResult<Prisma.$RegisterWarrantyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegisterWarranties that matches the filter.
     * @param {RegisterWarrantyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const registerWarranty = await prisma.registerWarranty.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RegisterWarrantyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a RegisterWarranty.
     * @param {RegisterWarrantyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const registerWarranty = await prisma.registerWarranty.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RegisterWarrantyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of RegisterWarranties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterWarrantyCountArgs} args - Arguments to filter RegisterWarranties to count.
     * @example
     * // Count the number of RegisterWarranties
     * const count = await prisma.registerWarranty.count({
     *   where: {
     *     // ... the filter for the RegisterWarranties we want to count
     *   }
     * })
    **/
    count<T extends RegisterWarrantyCountArgs>(
      args?: Subset<T, RegisterWarrantyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegisterWarrantyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegisterWarranty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterWarrantyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegisterWarrantyAggregateArgs>(args: Subset<T, RegisterWarrantyAggregateArgs>): Prisma.PrismaPromise<GetRegisterWarrantyAggregateType<T>>

    /**
     * Group by RegisterWarranty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterWarrantyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegisterWarrantyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegisterWarrantyGroupByArgs['orderBy'] }
        : { orderBy?: RegisterWarrantyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegisterWarrantyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegisterWarrantyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegisterWarranty model
   */
  readonly fields: RegisterWarrantyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegisterWarranty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegisterWarrantyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegisterWarranty model
   */
  interface RegisterWarrantyFieldRefs {
    readonly id: FieldRef<"RegisterWarranty", 'String'>
    readonly productId: FieldRef<"RegisterWarranty", 'String'>
    readonly serialNumber: FieldRef<"RegisterWarranty", 'String'>
    readonly purchaseDate: FieldRef<"RegisterWarranty", 'DateTime'>
    readonly warrantyMonths: FieldRef<"RegisterWarranty", 'Int'>
    readonly sellerId: FieldRef<"RegisterWarranty", 'String'>
    readonly registeredAt: FieldRef<"RegisterWarranty", 'DateTime'>
    readonly qrImage: FieldRef<"RegisterWarranty", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RegisterWarranty findUnique
   */
  export type RegisterWarrantyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterWarranty
     */
    select?: RegisterWarrantySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterWarranty
     */
    omit?: RegisterWarrantyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisterWarrantyInclude<ExtArgs> | null
    /**
     * Filter, which RegisterWarranty to fetch.
     */
    where: RegisterWarrantyWhereUniqueInput
  }

  /**
   * RegisterWarranty findUniqueOrThrow
   */
  export type RegisterWarrantyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterWarranty
     */
    select?: RegisterWarrantySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterWarranty
     */
    omit?: RegisterWarrantyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisterWarrantyInclude<ExtArgs> | null
    /**
     * Filter, which RegisterWarranty to fetch.
     */
    where: RegisterWarrantyWhereUniqueInput
  }

  /**
   * RegisterWarranty findFirst
   */
  export type RegisterWarrantyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterWarranty
     */
    select?: RegisterWarrantySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterWarranty
     */
    omit?: RegisterWarrantyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisterWarrantyInclude<ExtArgs> | null
    /**
     * Filter, which RegisterWarranty to fetch.
     */
    where?: RegisterWarrantyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterWarranties to fetch.
     */
    orderBy?: RegisterWarrantyOrderByWithRelationInput | RegisterWarrantyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegisterWarranties.
     */
    cursor?: RegisterWarrantyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterWarranties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterWarranties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegisterWarranties.
     */
    distinct?: RegisterWarrantyScalarFieldEnum | RegisterWarrantyScalarFieldEnum[]
  }

  /**
   * RegisterWarranty findFirstOrThrow
   */
  export type RegisterWarrantyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterWarranty
     */
    select?: RegisterWarrantySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterWarranty
     */
    omit?: RegisterWarrantyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisterWarrantyInclude<ExtArgs> | null
    /**
     * Filter, which RegisterWarranty to fetch.
     */
    where?: RegisterWarrantyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterWarranties to fetch.
     */
    orderBy?: RegisterWarrantyOrderByWithRelationInput | RegisterWarrantyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegisterWarranties.
     */
    cursor?: RegisterWarrantyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterWarranties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterWarranties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegisterWarranties.
     */
    distinct?: RegisterWarrantyScalarFieldEnum | RegisterWarrantyScalarFieldEnum[]
  }

  /**
   * RegisterWarranty findMany
   */
  export type RegisterWarrantyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterWarranty
     */
    select?: RegisterWarrantySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterWarranty
     */
    omit?: RegisterWarrantyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisterWarrantyInclude<ExtArgs> | null
    /**
     * Filter, which RegisterWarranties to fetch.
     */
    where?: RegisterWarrantyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterWarranties to fetch.
     */
    orderBy?: RegisterWarrantyOrderByWithRelationInput | RegisterWarrantyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegisterWarranties.
     */
    cursor?: RegisterWarrantyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterWarranties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterWarranties.
     */
    skip?: number
    distinct?: RegisterWarrantyScalarFieldEnum | RegisterWarrantyScalarFieldEnum[]
  }

  /**
   * RegisterWarranty create
   */
  export type RegisterWarrantyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterWarranty
     */
    select?: RegisterWarrantySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterWarranty
     */
    omit?: RegisterWarrantyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisterWarrantyInclude<ExtArgs> | null
    /**
     * The data needed to create a RegisterWarranty.
     */
    data: XOR<RegisterWarrantyCreateInput, RegisterWarrantyUncheckedCreateInput>
  }

  /**
   * RegisterWarranty createMany
   */
  export type RegisterWarrantyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegisterWarranties.
     */
    data: RegisterWarrantyCreateManyInput | RegisterWarrantyCreateManyInput[]
  }

  /**
   * RegisterWarranty update
   */
  export type RegisterWarrantyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterWarranty
     */
    select?: RegisterWarrantySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterWarranty
     */
    omit?: RegisterWarrantyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisterWarrantyInclude<ExtArgs> | null
    /**
     * The data needed to update a RegisterWarranty.
     */
    data: XOR<RegisterWarrantyUpdateInput, RegisterWarrantyUncheckedUpdateInput>
    /**
     * Choose, which RegisterWarranty to update.
     */
    where: RegisterWarrantyWhereUniqueInput
  }

  /**
   * RegisterWarranty updateMany
   */
  export type RegisterWarrantyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegisterWarranties.
     */
    data: XOR<RegisterWarrantyUpdateManyMutationInput, RegisterWarrantyUncheckedUpdateManyInput>
    /**
     * Filter which RegisterWarranties to update
     */
    where?: RegisterWarrantyWhereInput
    /**
     * Limit how many RegisterWarranties to update.
     */
    limit?: number
  }

  /**
   * RegisterWarranty upsert
   */
  export type RegisterWarrantyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterWarranty
     */
    select?: RegisterWarrantySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterWarranty
     */
    omit?: RegisterWarrantyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisterWarrantyInclude<ExtArgs> | null
    /**
     * The filter to search for the RegisterWarranty to update in case it exists.
     */
    where: RegisterWarrantyWhereUniqueInput
    /**
     * In case the RegisterWarranty found by the `where` argument doesn't exist, create a new RegisterWarranty with this data.
     */
    create: XOR<RegisterWarrantyCreateInput, RegisterWarrantyUncheckedCreateInput>
    /**
     * In case the RegisterWarranty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegisterWarrantyUpdateInput, RegisterWarrantyUncheckedUpdateInput>
  }

  /**
   * RegisterWarranty delete
   */
  export type RegisterWarrantyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterWarranty
     */
    select?: RegisterWarrantySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterWarranty
     */
    omit?: RegisterWarrantyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisterWarrantyInclude<ExtArgs> | null
    /**
     * Filter which RegisterWarranty to delete.
     */
    where: RegisterWarrantyWhereUniqueInput
  }

  /**
   * RegisterWarranty deleteMany
   */
  export type RegisterWarrantyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegisterWarranties to delete
     */
    where?: RegisterWarrantyWhereInput
    /**
     * Limit how many RegisterWarranties to delete.
     */
    limit?: number
  }

  /**
   * RegisterWarranty findRaw
   */
  export type RegisterWarrantyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RegisterWarranty aggregateRaw
   */
  export type RegisterWarrantyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RegisterWarranty without action
   */
  export type RegisterWarrantyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterWarranty
     */
    select?: RegisterWarrantySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterWarranty
     */
    omit?: RegisterWarrantyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisterWarrantyInclude<ExtArgs> | null
  }


  /**
   * Model PostDeliveryReport
   */

  export type AggregatePostDeliveryReport = {
    _count: PostDeliveryReportCountAggregateOutputType | null
    _avg: PostDeliveryReportAvgAggregateOutputType | null
    _sum: PostDeliveryReportSumAggregateOutputType | null
    _min: PostDeliveryReportMinAggregateOutputType | null
    _max: PostDeliveryReportMaxAggregateOutputType | null
  }

  export type PostDeliveryReportAvgAggregateOutputType = {
    quantity: number | null
  }

  export type PostDeliveryReportSumAggregateOutputType = {
    quantity: number | null
  }

  export type PostDeliveryReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    product: string | null
    quantity: number | null
    submittedAt: Date | null
  }

  export type PostDeliveryReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    product: string | null
    quantity: number | null
    submittedAt: Date | null
  }

  export type PostDeliveryReportCountAggregateOutputType = {
    id: number
    userId: number
    product: number
    quantity: number
    submittedAt: number
    _all: number
  }


  export type PostDeliveryReportAvgAggregateInputType = {
    quantity?: true
  }

  export type PostDeliveryReportSumAggregateInputType = {
    quantity?: true
  }

  export type PostDeliveryReportMinAggregateInputType = {
    id?: true
    userId?: true
    product?: true
    quantity?: true
    submittedAt?: true
  }

  export type PostDeliveryReportMaxAggregateInputType = {
    id?: true
    userId?: true
    product?: true
    quantity?: true
    submittedAt?: true
  }

  export type PostDeliveryReportCountAggregateInputType = {
    id?: true
    userId?: true
    product?: true
    quantity?: true
    submittedAt?: true
    _all?: true
  }

  export type PostDeliveryReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostDeliveryReport to aggregate.
     */
    where?: PostDeliveryReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostDeliveryReports to fetch.
     */
    orderBy?: PostDeliveryReportOrderByWithRelationInput | PostDeliveryReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostDeliveryReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostDeliveryReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostDeliveryReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostDeliveryReports
    **/
    _count?: true | PostDeliveryReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostDeliveryReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostDeliveryReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostDeliveryReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostDeliveryReportMaxAggregateInputType
  }

  export type GetPostDeliveryReportAggregateType<T extends PostDeliveryReportAggregateArgs> = {
        [P in keyof T & keyof AggregatePostDeliveryReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostDeliveryReport[P]>
      : GetScalarType<T[P], AggregatePostDeliveryReport[P]>
  }




  export type PostDeliveryReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostDeliveryReportWhereInput
    orderBy?: PostDeliveryReportOrderByWithAggregationInput | PostDeliveryReportOrderByWithAggregationInput[]
    by: PostDeliveryReportScalarFieldEnum[] | PostDeliveryReportScalarFieldEnum
    having?: PostDeliveryReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostDeliveryReportCountAggregateInputType | true
    _avg?: PostDeliveryReportAvgAggregateInputType
    _sum?: PostDeliveryReportSumAggregateInputType
    _min?: PostDeliveryReportMinAggregateInputType
    _max?: PostDeliveryReportMaxAggregateInputType
  }

  export type PostDeliveryReportGroupByOutputType = {
    id: string
    userId: string
    product: string
    quantity: number
    submittedAt: Date
    _count: PostDeliveryReportCountAggregateOutputType | null
    _avg: PostDeliveryReportAvgAggregateOutputType | null
    _sum: PostDeliveryReportSumAggregateOutputType | null
    _min: PostDeliveryReportMinAggregateOutputType | null
    _max: PostDeliveryReportMaxAggregateOutputType | null
  }

  type GetPostDeliveryReportGroupByPayload<T extends PostDeliveryReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostDeliveryReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostDeliveryReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostDeliveryReportGroupByOutputType[P]>
            : GetScalarType<T[P], PostDeliveryReportGroupByOutputType[P]>
        }
      >
    >


  export type PostDeliveryReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    product?: boolean
    quantity?: boolean
    submittedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postDeliveryReport"]>



  export type PostDeliveryReportSelectScalar = {
    id?: boolean
    userId?: boolean
    product?: boolean
    quantity?: boolean
    submittedAt?: boolean
  }

  export type PostDeliveryReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "product" | "quantity" | "submittedAt", ExtArgs["result"]["postDeliveryReport"]>
  export type PostDeliveryReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostDeliveryReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostDeliveryReport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      product: string
      quantity: number
      submittedAt: Date
    }, ExtArgs["result"]["postDeliveryReport"]>
    composites: {}
  }

  type PostDeliveryReportGetPayload<S extends boolean | null | undefined | PostDeliveryReportDefaultArgs> = $Result.GetResult<Prisma.$PostDeliveryReportPayload, S>

  type PostDeliveryReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostDeliveryReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostDeliveryReportCountAggregateInputType | true
    }

  export interface PostDeliveryReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostDeliveryReport'], meta: { name: 'PostDeliveryReport' } }
    /**
     * Find zero or one PostDeliveryReport that matches the filter.
     * @param {PostDeliveryReportFindUniqueArgs} args - Arguments to find a PostDeliveryReport
     * @example
     * // Get one PostDeliveryReport
     * const postDeliveryReport = await prisma.postDeliveryReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostDeliveryReportFindUniqueArgs>(args: SelectSubset<T, PostDeliveryReportFindUniqueArgs<ExtArgs>>): Prisma__PostDeliveryReportClient<$Result.GetResult<Prisma.$PostDeliveryReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostDeliveryReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostDeliveryReportFindUniqueOrThrowArgs} args - Arguments to find a PostDeliveryReport
     * @example
     * // Get one PostDeliveryReport
     * const postDeliveryReport = await prisma.postDeliveryReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostDeliveryReportFindUniqueOrThrowArgs>(args: SelectSubset<T, PostDeliveryReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostDeliveryReportClient<$Result.GetResult<Prisma.$PostDeliveryReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostDeliveryReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDeliveryReportFindFirstArgs} args - Arguments to find a PostDeliveryReport
     * @example
     * // Get one PostDeliveryReport
     * const postDeliveryReport = await prisma.postDeliveryReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostDeliveryReportFindFirstArgs>(args?: SelectSubset<T, PostDeliveryReportFindFirstArgs<ExtArgs>>): Prisma__PostDeliveryReportClient<$Result.GetResult<Prisma.$PostDeliveryReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostDeliveryReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDeliveryReportFindFirstOrThrowArgs} args - Arguments to find a PostDeliveryReport
     * @example
     * // Get one PostDeliveryReport
     * const postDeliveryReport = await prisma.postDeliveryReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostDeliveryReportFindFirstOrThrowArgs>(args?: SelectSubset<T, PostDeliveryReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostDeliveryReportClient<$Result.GetResult<Prisma.$PostDeliveryReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostDeliveryReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDeliveryReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostDeliveryReports
     * const postDeliveryReports = await prisma.postDeliveryReport.findMany()
     * 
     * // Get first 10 PostDeliveryReports
     * const postDeliveryReports = await prisma.postDeliveryReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postDeliveryReportWithIdOnly = await prisma.postDeliveryReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostDeliveryReportFindManyArgs>(args?: SelectSubset<T, PostDeliveryReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostDeliveryReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostDeliveryReport.
     * @param {PostDeliveryReportCreateArgs} args - Arguments to create a PostDeliveryReport.
     * @example
     * // Create one PostDeliveryReport
     * const PostDeliveryReport = await prisma.postDeliveryReport.create({
     *   data: {
     *     // ... data to create a PostDeliveryReport
     *   }
     * })
     * 
     */
    create<T extends PostDeliveryReportCreateArgs>(args: SelectSubset<T, PostDeliveryReportCreateArgs<ExtArgs>>): Prisma__PostDeliveryReportClient<$Result.GetResult<Prisma.$PostDeliveryReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostDeliveryReports.
     * @param {PostDeliveryReportCreateManyArgs} args - Arguments to create many PostDeliveryReports.
     * @example
     * // Create many PostDeliveryReports
     * const postDeliveryReport = await prisma.postDeliveryReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostDeliveryReportCreateManyArgs>(args?: SelectSubset<T, PostDeliveryReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PostDeliveryReport.
     * @param {PostDeliveryReportDeleteArgs} args - Arguments to delete one PostDeliveryReport.
     * @example
     * // Delete one PostDeliveryReport
     * const PostDeliveryReport = await prisma.postDeliveryReport.delete({
     *   where: {
     *     // ... filter to delete one PostDeliveryReport
     *   }
     * })
     * 
     */
    delete<T extends PostDeliveryReportDeleteArgs>(args: SelectSubset<T, PostDeliveryReportDeleteArgs<ExtArgs>>): Prisma__PostDeliveryReportClient<$Result.GetResult<Prisma.$PostDeliveryReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostDeliveryReport.
     * @param {PostDeliveryReportUpdateArgs} args - Arguments to update one PostDeliveryReport.
     * @example
     * // Update one PostDeliveryReport
     * const postDeliveryReport = await prisma.postDeliveryReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostDeliveryReportUpdateArgs>(args: SelectSubset<T, PostDeliveryReportUpdateArgs<ExtArgs>>): Prisma__PostDeliveryReportClient<$Result.GetResult<Prisma.$PostDeliveryReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostDeliveryReports.
     * @param {PostDeliveryReportDeleteManyArgs} args - Arguments to filter PostDeliveryReports to delete.
     * @example
     * // Delete a few PostDeliveryReports
     * const { count } = await prisma.postDeliveryReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeliveryReportDeleteManyArgs>(args?: SelectSubset<T, PostDeliveryReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostDeliveryReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDeliveryReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostDeliveryReports
     * const postDeliveryReport = await prisma.postDeliveryReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostDeliveryReportUpdateManyArgs>(args: SelectSubset<T, PostDeliveryReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostDeliveryReport.
     * @param {PostDeliveryReportUpsertArgs} args - Arguments to update or create a PostDeliveryReport.
     * @example
     * // Update or create a PostDeliveryReport
     * const postDeliveryReport = await prisma.postDeliveryReport.upsert({
     *   create: {
     *     // ... data to create a PostDeliveryReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostDeliveryReport we want to update
     *   }
     * })
     */
    upsert<T extends PostDeliveryReportUpsertArgs>(args: SelectSubset<T, PostDeliveryReportUpsertArgs<ExtArgs>>): Prisma__PostDeliveryReportClient<$Result.GetResult<Prisma.$PostDeliveryReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostDeliveryReports that matches the filter.
     * @param {PostDeliveryReportFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const postDeliveryReport = await prisma.postDeliveryReport.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PostDeliveryReportFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PostDeliveryReport.
     * @param {PostDeliveryReportAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const postDeliveryReport = await prisma.postDeliveryReport.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PostDeliveryReportAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PostDeliveryReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDeliveryReportCountArgs} args - Arguments to filter PostDeliveryReports to count.
     * @example
     * // Count the number of PostDeliveryReports
     * const count = await prisma.postDeliveryReport.count({
     *   where: {
     *     // ... the filter for the PostDeliveryReports we want to count
     *   }
     * })
    **/
    count<T extends PostDeliveryReportCountArgs>(
      args?: Subset<T, PostDeliveryReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostDeliveryReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostDeliveryReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDeliveryReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostDeliveryReportAggregateArgs>(args: Subset<T, PostDeliveryReportAggregateArgs>): Prisma.PrismaPromise<GetPostDeliveryReportAggregateType<T>>

    /**
     * Group by PostDeliveryReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDeliveryReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostDeliveryReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostDeliveryReportGroupByArgs['orderBy'] }
        : { orderBy?: PostDeliveryReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostDeliveryReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostDeliveryReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostDeliveryReport model
   */
  readonly fields: PostDeliveryReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostDeliveryReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostDeliveryReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostDeliveryReport model
   */
  interface PostDeliveryReportFieldRefs {
    readonly id: FieldRef<"PostDeliveryReport", 'String'>
    readonly userId: FieldRef<"PostDeliveryReport", 'String'>
    readonly product: FieldRef<"PostDeliveryReport", 'String'>
    readonly quantity: FieldRef<"PostDeliveryReport", 'Int'>
    readonly submittedAt: FieldRef<"PostDeliveryReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostDeliveryReport findUnique
   */
  export type PostDeliveryReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDeliveryReport
     */
    select?: PostDeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDeliveryReport
     */
    omit?: PostDeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDeliveryReportInclude<ExtArgs> | null
    /**
     * Filter, which PostDeliveryReport to fetch.
     */
    where: PostDeliveryReportWhereUniqueInput
  }

  /**
   * PostDeliveryReport findUniqueOrThrow
   */
  export type PostDeliveryReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDeliveryReport
     */
    select?: PostDeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDeliveryReport
     */
    omit?: PostDeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDeliveryReportInclude<ExtArgs> | null
    /**
     * Filter, which PostDeliveryReport to fetch.
     */
    where: PostDeliveryReportWhereUniqueInput
  }

  /**
   * PostDeliveryReport findFirst
   */
  export type PostDeliveryReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDeliveryReport
     */
    select?: PostDeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDeliveryReport
     */
    omit?: PostDeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDeliveryReportInclude<ExtArgs> | null
    /**
     * Filter, which PostDeliveryReport to fetch.
     */
    where?: PostDeliveryReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostDeliveryReports to fetch.
     */
    orderBy?: PostDeliveryReportOrderByWithRelationInput | PostDeliveryReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostDeliveryReports.
     */
    cursor?: PostDeliveryReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostDeliveryReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostDeliveryReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostDeliveryReports.
     */
    distinct?: PostDeliveryReportScalarFieldEnum | PostDeliveryReportScalarFieldEnum[]
  }

  /**
   * PostDeliveryReport findFirstOrThrow
   */
  export type PostDeliveryReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDeliveryReport
     */
    select?: PostDeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDeliveryReport
     */
    omit?: PostDeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDeliveryReportInclude<ExtArgs> | null
    /**
     * Filter, which PostDeliveryReport to fetch.
     */
    where?: PostDeliveryReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostDeliveryReports to fetch.
     */
    orderBy?: PostDeliveryReportOrderByWithRelationInput | PostDeliveryReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostDeliveryReports.
     */
    cursor?: PostDeliveryReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostDeliveryReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostDeliveryReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostDeliveryReports.
     */
    distinct?: PostDeliveryReportScalarFieldEnum | PostDeliveryReportScalarFieldEnum[]
  }

  /**
   * PostDeliveryReport findMany
   */
  export type PostDeliveryReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDeliveryReport
     */
    select?: PostDeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDeliveryReport
     */
    omit?: PostDeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDeliveryReportInclude<ExtArgs> | null
    /**
     * Filter, which PostDeliveryReports to fetch.
     */
    where?: PostDeliveryReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostDeliveryReports to fetch.
     */
    orderBy?: PostDeliveryReportOrderByWithRelationInput | PostDeliveryReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostDeliveryReports.
     */
    cursor?: PostDeliveryReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostDeliveryReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostDeliveryReports.
     */
    skip?: number
    distinct?: PostDeliveryReportScalarFieldEnum | PostDeliveryReportScalarFieldEnum[]
  }

  /**
   * PostDeliveryReport create
   */
  export type PostDeliveryReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDeliveryReport
     */
    select?: PostDeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDeliveryReport
     */
    omit?: PostDeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDeliveryReportInclude<ExtArgs> | null
    /**
     * The data needed to create a PostDeliveryReport.
     */
    data: XOR<PostDeliveryReportCreateInput, PostDeliveryReportUncheckedCreateInput>
  }

  /**
   * PostDeliveryReport createMany
   */
  export type PostDeliveryReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostDeliveryReports.
     */
    data: PostDeliveryReportCreateManyInput | PostDeliveryReportCreateManyInput[]
  }

  /**
   * PostDeliveryReport update
   */
  export type PostDeliveryReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDeliveryReport
     */
    select?: PostDeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDeliveryReport
     */
    omit?: PostDeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDeliveryReportInclude<ExtArgs> | null
    /**
     * The data needed to update a PostDeliveryReport.
     */
    data: XOR<PostDeliveryReportUpdateInput, PostDeliveryReportUncheckedUpdateInput>
    /**
     * Choose, which PostDeliveryReport to update.
     */
    where: PostDeliveryReportWhereUniqueInput
  }

  /**
   * PostDeliveryReport updateMany
   */
  export type PostDeliveryReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostDeliveryReports.
     */
    data: XOR<PostDeliveryReportUpdateManyMutationInput, PostDeliveryReportUncheckedUpdateManyInput>
    /**
     * Filter which PostDeliveryReports to update
     */
    where?: PostDeliveryReportWhereInput
    /**
     * Limit how many PostDeliveryReports to update.
     */
    limit?: number
  }

  /**
   * PostDeliveryReport upsert
   */
  export type PostDeliveryReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDeliveryReport
     */
    select?: PostDeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDeliveryReport
     */
    omit?: PostDeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDeliveryReportInclude<ExtArgs> | null
    /**
     * The filter to search for the PostDeliveryReport to update in case it exists.
     */
    where: PostDeliveryReportWhereUniqueInput
    /**
     * In case the PostDeliveryReport found by the `where` argument doesn't exist, create a new PostDeliveryReport with this data.
     */
    create: XOR<PostDeliveryReportCreateInput, PostDeliveryReportUncheckedCreateInput>
    /**
     * In case the PostDeliveryReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostDeliveryReportUpdateInput, PostDeliveryReportUncheckedUpdateInput>
  }

  /**
   * PostDeliveryReport delete
   */
  export type PostDeliveryReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDeliveryReport
     */
    select?: PostDeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDeliveryReport
     */
    omit?: PostDeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDeliveryReportInclude<ExtArgs> | null
    /**
     * Filter which PostDeliveryReport to delete.
     */
    where: PostDeliveryReportWhereUniqueInput
  }

  /**
   * PostDeliveryReport deleteMany
   */
  export type PostDeliveryReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostDeliveryReports to delete
     */
    where?: PostDeliveryReportWhereInput
    /**
     * Limit how many PostDeliveryReports to delete.
     */
    limit?: number
  }

  /**
   * PostDeliveryReport findRaw
   */
  export type PostDeliveryReportFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PostDeliveryReport aggregateRaw
   */
  export type PostDeliveryReportAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PostDeliveryReport without action
   */
  export type PostDeliveryReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDeliveryReport
     */
    select?: PostDeliveryReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDeliveryReport
     */
    omit?: PostDeliveryReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDeliveryReportInclude<ExtArgs> | null
  }


  /**
   * Model CommissionedWork
   */

  export type AggregateCommissionedWork = {
    _count: CommissionedWorkCountAggregateOutputType | null
    _avg: CommissionedWorkAvgAggregateOutputType | null
    _sum: CommissionedWorkSumAggregateOutputType | null
    _min: CommissionedWorkMinAggregateOutputType | null
    _max: CommissionedWorkMaxAggregateOutputType | null
  }

  export type CommissionedWorkAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type CommissionedWorkSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type CommissionedWorkMinAggregateOutputType = {
    id: string | null
    userId: string | null
    latitude: number | null
    longitude: number | null
    qrCode: string | null
    qrImage: Uint8Array | null
    appliedAt: Date | null
  }

  export type CommissionedWorkMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    latitude: number | null
    longitude: number | null
    qrCode: string | null
    qrImage: Uint8Array | null
    appliedAt: Date | null
  }

  export type CommissionedWorkCountAggregateOutputType = {
    id: number
    userId: number
    latitude: number
    longitude: number
    qrCode: number
    qrImage: number
    appliedAt: number
    _all: number
  }


  export type CommissionedWorkAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CommissionedWorkSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CommissionedWorkMinAggregateInputType = {
    id?: true
    userId?: true
    latitude?: true
    longitude?: true
    qrCode?: true
    qrImage?: true
    appliedAt?: true
  }

  export type CommissionedWorkMaxAggregateInputType = {
    id?: true
    userId?: true
    latitude?: true
    longitude?: true
    qrCode?: true
    qrImage?: true
    appliedAt?: true
  }

  export type CommissionedWorkCountAggregateInputType = {
    id?: true
    userId?: true
    latitude?: true
    longitude?: true
    qrCode?: true
    qrImage?: true
    appliedAt?: true
    _all?: true
  }

  export type CommissionedWorkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionedWork to aggregate.
     */
    where?: CommissionedWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionedWorks to fetch.
     */
    orderBy?: CommissionedWorkOrderByWithRelationInput | CommissionedWorkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommissionedWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionedWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionedWorks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommissionedWorks
    **/
    _count?: true | CommissionedWorkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommissionedWorkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommissionedWorkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommissionedWorkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommissionedWorkMaxAggregateInputType
  }

  export type GetCommissionedWorkAggregateType<T extends CommissionedWorkAggregateArgs> = {
        [P in keyof T & keyof AggregateCommissionedWork]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommissionedWork[P]>
      : GetScalarType<T[P], AggregateCommissionedWork[P]>
  }




  export type CommissionedWorkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionedWorkWhereInput
    orderBy?: CommissionedWorkOrderByWithAggregationInput | CommissionedWorkOrderByWithAggregationInput[]
    by: CommissionedWorkScalarFieldEnum[] | CommissionedWorkScalarFieldEnum
    having?: CommissionedWorkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommissionedWorkCountAggregateInputType | true
    _avg?: CommissionedWorkAvgAggregateInputType
    _sum?: CommissionedWorkSumAggregateInputType
    _min?: CommissionedWorkMinAggregateInputType
    _max?: CommissionedWorkMaxAggregateInputType
  }

  export type CommissionedWorkGroupByOutputType = {
    id: string
    userId: string
    latitude: number
    longitude: number
    qrCode: string
    qrImage: Uint8Array
    appliedAt: Date
    _count: CommissionedWorkCountAggregateOutputType | null
    _avg: CommissionedWorkAvgAggregateOutputType | null
    _sum: CommissionedWorkSumAggregateOutputType | null
    _min: CommissionedWorkMinAggregateOutputType | null
    _max: CommissionedWorkMaxAggregateOutputType | null
  }

  type GetCommissionedWorkGroupByPayload<T extends CommissionedWorkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommissionedWorkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommissionedWorkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommissionedWorkGroupByOutputType[P]>
            : GetScalarType<T[P], CommissionedWorkGroupByOutputType[P]>
        }
      >
    >


  export type CommissionedWorkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    latitude?: boolean
    longitude?: boolean
    qrCode?: boolean
    qrImage?: boolean
    appliedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commissionedWork"]>



  export type CommissionedWorkSelectScalar = {
    id?: boolean
    userId?: boolean
    latitude?: boolean
    longitude?: boolean
    qrCode?: boolean
    qrImage?: boolean
    appliedAt?: boolean
  }

  export type CommissionedWorkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "latitude" | "longitude" | "qrCode" | "qrImage" | "appliedAt", ExtArgs["result"]["commissionedWork"]>
  export type CommissionedWorkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommissionedWorkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommissionedWork"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      latitude: number
      longitude: number
      qrCode: string
      qrImage: Uint8Array
      appliedAt: Date
    }, ExtArgs["result"]["commissionedWork"]>
    composites: {}
  }

  type CommissionedWorkGetPayload<S extends boolean | null | undefined | CommissionedWorkDefaultArgs> = $Result.GetResult<Prisma.$CommissionedWorkPayload, S>

  type CommissionedWorkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommissionedWorkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommissionedWorkCountAggregateInputType | true
    }

  export interface CommissionedWorkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommissionedWork'], meta: { name: 'CommissionedWork' } }
    /**
     * Find zero or one CommissionedWork that matches the filter.
     * @param {CommissionedWorkFindUniqueArgs} args - Arguments to find a CommissionedWork
     * @example
     * // Get one CommissionedWork
     * const commissionedWork = await prisma.commissionedWork.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommissionedWorkFindUniqueArgs>(args: SelectSubset<T, CommissionedWorkFindUniqueArgs<ExtArgs>>): Prisma__CommissionedWorkClient<$Result.GetResult<Prisma.$CommissionedWorkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommissionedWork that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommissionedWorkFindUniqueOrThrowArgs} args - Arguments to find a CommissionedWork
     * @example
     * // Get one CommissionedWork
     * const commissionedWork = await prisma.commissionedWork.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommissionedWorkFindUniqueOrThrowArgs>(args: SelectSubset<T, CommissionedWorkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommissionedWorkClient<$Result.GetResult<Prisma.$CommissionedWorkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommissionedWork that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionedWorkFindFirstArgs} args - Arguments to find a CommissionedWork
     * @example
     * // Get one CommissionedWork
     * const commissionedWork = await prisma.commissionedWork.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommissionedWorkFindFirstArgs>(args?: SelectSubset<T, CommissionedWorkFindFirstArgs<ExtArgs>>): Prisma__CommissionedWorkClient<$Result.GetResult<Prisma.$CommissionedWorkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommissionedWork that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionedWorkFindFirstOrThrowArgs} args - Arguments to find a CommissionedWork
     * @example
     * // Get one CommissionedWork
     * const commissionedWork = await prisma.commissionedWork.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommissionedWorkFindFirstOrThrowArgs>(args?: SelectSubset<T, CommissionedWorkFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommissionedWorkClient<$Result.GetResult<Prisma.$CommissionedWorkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommissionedWorks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionedWorkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommissionedWorks
     * const commissionedWorks = await prisma.commissionedWork.findMany()
     * 
     * // Get first 10 CommissionedWorks
     * const commissionedWorks = await prisma.commissionedWork.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commissionedWorkWithIdOnly = await prisma.commissionedWork.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommissionedWorkFindManyArgs>(args?: SelectSubset<T, CommissionedWorkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionedWorkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommissionedWork.
     * @param {CommissionedWorkCreateArgs} args - Arguments to create a CommissionedWork.
     * @example
     * // Create one CommissionedWork
     * const CommissionedWork = await prisma.commissionedWork.create({
     *   data: {
     *     // ... data to create a CommissionedWork
     *   }
     * })
     * 
     */
    create<T extends CommissionedWorkCreateArgs>(args: SelectSubset<T, CommissionedWorkCreateArgs<ExtArgs>>): Prisma__CommissionedWorkClient<$Result.GetResult<Prisma.$CommissionedWorkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommissionedWorks.
     * @param {CommissionedWorkCreateManyArgs} args - Arguments to create many CommissionedWorks.
     * @example
     * // Create many CommissionedWorks
     * const commissionedWork = await prisma.commissionedWork.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommissionedWorkCreateManyArgs>(args?: SelectSubset<T, CommissionedWorkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommissionedWork.
     * @param {CommissionedWorkDeleteArgs} args - Arguments to delete one CommissionedWork.
     * @example
     * // Delete one CommissionedWork
     * const CommissionedWork = await prisma.commissionedWork.delete({
     *   where: {
     *     // ... filter to delete one CommissionedWork
     *   }
     * })
     * 
     */
    delete<T extends CommissionedWorkDeleteArgs>(args: SelectSubset<T, CommissionedWorkDeleteArgs<ExtArgs>>): Prisma__CommissionedWorkClient<$Result.GetResult<Prisma.$CommissionedWorkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommissionedWork.
     * @param {CommissionedWorkUpdateArgs} args - Arguments to update one CommissionedWork.
     * @example
     * // Update one CommissionedWork
     * const commissionedWork = await prisma.commissionedWork.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommissionedWorkUpdateArgs>(args: SelectSubset<T, CommissionedWorkUpdateArgs<ExtArgs>>): Prisma__CommissionedWorkClient<$Result.GetResult<Prisma.$CommissionedWorkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommissionedWorks.
     * @param {CommissionedWorkDeleteManyArgs} args - Arguments to filter CommissionedWorks to delete.
     * @example
     * // Delete a few CommissionedWorks
     * const { count } = await prisma.commissionedWork.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommissionedWorkDeleteManyArgs>(args?: SelectSubset<T, CommissionedWorkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommissionedWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionedWorkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommissionedWorks
     * const commissionedWork = await prisma.commissionedWork.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommissionedWorkUpdateManyArgs>(args: SelectSubset<T, CommissionedWorkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommissionedWork.
     * @param {CommissionedWorkUpsertArgs} args - Arguments to update or create a CommissionedWork.
     * @example
     * // Update or create a CommissionedWork
     * const commissionedWork = await prisma.commissionedWork.upsert({
     *   create: {
     *     // ... data to create a CommissionedWork
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommissionedWork we want to update
     *   }
     * })
     */
    upsert<T extends CommissionedWorkUpsertArgs>(args: SelectSubset<T, CommissionedWorkUpsertArgs<ExtArgs>>): Prisma__CommissionedWorkClient<$Result.GetResult<Prisma.$CommissionedWorkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommissionedWorks that matches the filter.
     * @param {CommissionedWorkFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const commissionedWork = await prisma.commissionedWork.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CommissionedWorkFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CommissionedWork.
     * @param {CommissionedWorkAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const commissionedWork = await prisma.commissionedWork.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CommissionedWorkAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CommissionedWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionedWorkCountArgs} args - Arguments to filter CommissionedWorks to count.
     * @example
     * // Count the number of CommissionedWorks
     * const count = await prisma.commissionedWork.count({
     *   where: {
     *     // ... the filter for the CommissionedWorks we want to count
     *   }
     * })
    **/
    count<T extends CommissionedWorkCountArgs>(
      args?: Subset<T, CommissionedWorkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommissionedWorkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommissionedWork.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionedWorkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommissionedWorkAggregateArgs>(args: Subset<T, CommissionedWorkAggregateArgs>): Prisma.PrismaPromise<GetCommissionedWorkAggregateType<T>>

    /**
     * Group by CommissionedWork.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionedWorkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommissionedWorkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommissionedWorkGroupByArgs['orderBy'] }
        : { orderBy?: CommissionedWorkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommissionedWorkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommissionedWorkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommissionedWork model
   */
  readonly fields: CommissionedWorkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommissionedWork.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommissionedWorkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommissionedWork model
   */
  interface CommissionedWorkFieldRefs {
    readonly id: FieldRef<"CommissionedWork", 'String'>
    readonly userId: FieldRef<"CommissionedWork", 'String'>
    readonly latitude: FieldRef<"CommissionedWork", 'Float'>
    readonly longitude: FieldRef<"CommissionedWork", 'Float'>
    readonly qrCode: FieldRef<"CommissionedWork", 'String'>
    readonly qrImage: FieldRef<"CommissionedWork", 'Bytes'>
    readonly appliedAt: FieldRef<"CommissionedWork", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommissionedWork findUnique
   */
  export type CommissionedWorkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionedWork
     */
    select?: CommissionedWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionedWork
     */
    omit?: CommissionedWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionedWorkInclude<ExtArgs> | null
    /**
     * Filter, which CommissionedWork to fetch.
     */
    where: CommissionedWorkWhereUniqueInput
  }

  /**
   * CommissionedWork findUniqueOrThrow
   */
  export type CommissionedWorkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionedWork
     */
    select?: CommissionedWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionedWork
     */
    omit?: CommissionedWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionedWorkInclude<ExtArgs> | null
    /**
     * Filter, which CommissionedWork to fetch.
     */
    where: CommissionedWorkWhereUniqueInput
  }

  /**
   * CommissionedWork findFirst
   */
  export type CommissionedWorkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionedWork
     */
    select?: CommissionedWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionedWork
     */
    omit?: CommissionedWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionedWorkInclude<ExtArgs> | null
    /**
     * Filter, which CommissionedWork to fetch.
     */
    where?: CommissionedWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionedWorks to fetch.
     */
    orderBy?: CommissionedWorkOrderByWithRelationInput | CommissionedWorkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionedWorks.
     */
    cursor?: CommissionedWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionedWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionedWorks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionedWorks.
     */
    distinct?: CommissionedWorkScalarFieldEnum | CommissionedWorkScalarFieldEnum[]
  }

  /**
   * CommissionedWork findFirstOrThrow
   */
  export type CommissionedWorkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionedWork
     */
    select?: CommissionedWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionedWork
     */
    omit?: CommissionedWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionedWorkInclude<ExtArgs> | null
    /**
     * Filter, which CommissionedWork to fetch.
     */
    where?: CommissionedWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionedWorks to fetch.
     */
    orderBy?: CommissionedWorkOrderByWithRelationInput | CommissionedWorkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionedWorks.
     */
    cursor?: CommissionedWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionedWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionedWorks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionedWorks.
     */
    distinct?: CommissionedWorkScalarFieldEnum | CommissionedWorkScalarFieldEnum[]
  }

  /**
   * CommissionedWork findMany
   */
  export type CommissionedWorkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionedWork
     */
    select?: CommissionedWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionedWork
     */
    omit?: CommissionedWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionedWorkInclude<ExtArgs> | null
    /**
     * Filter, which CommissionedWorks to fetch.
     */
    where?: CommissionedWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionedWorks to fetch.
     */
    orderBy?: CommissionedWorkOrderByWithRelationInput | CommissionedWorkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommissionedWorks.
     */
    cursor?: CommissionedWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionedWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionedWorks.
     */
    skip?: number
    distinct?: CommissionedWorkScalarFieldEnum | CommissionedWorkScalarFieldEnum[]
  }

  /**
   * CommissionedWork create
   */
  export type CommissionedWorkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionedWork
     */
    select?: CommissionedWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionedWork
     */
    omit?: CommissionedWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionedWorkInclude<ExtArgs> | null
    /**
     * The data needed to create a CommissionedWork.
     */
    data: XOR<CommissionedWorkCreateInput, CommissionedWorkUncheckedCreateInput>
  }

  /**
   * CommissionedWork createMany
   */
  export type CommissionedWorkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommissionedWorks.
     */
    data: CommissionedWorkCreateManyInput | CommissionedWorkCreateManyInput[]
  }

  /**
   * CommissionedWork update
   */
  export type CommissionedWorkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionedWork
     */
    select?: CommissionedWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionedWork
     */
    omit?: CommissionedWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionedWorkInclude<ExtArgs> | null
    /**
     * The data needed to update a CommissionedWork.
     */
    data: XOR<CommissionedWorkUpdateInput, CommissionedWorkUncheckedUpdateInput>
    /**
     * Choose, which CommissionedWork to update.
     */
    where: CommissionedWorkWhereUniqueInput
  }

  /**
   * CommissionedWork updateMany
   */
  export type CommissionedWorkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommissionedWorks.
     */
    data: XOR<CommissionedWorkUpdateManyMutationInput, CommissionedWorkUncheckedUpdateManyInput>
    /**
     * Filter which CommissionedWorks to update
     */
    where?: CommissionedWorkWhereInput
    /**
     * Limit how many CommissionedWorks to update.
     */
    limit?: number
  }

  /**
   * CommissionedWork upsert
   */
  export type CommissionedWorkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionedWork
     */
    select?: CommissionedWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionedWork
     */
    omit?: CommissionedWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionedWorkInclude<ExtArgs> | null
    /**
     * The filter to search for the CommissionedWork to update in case it exists.
     */
    where: CommissionedWorkWhereUniqueInput
    /**
     * In case the CommissionedWork found by the `where` argument doesn't exist, create a new CommissionedWork with this data.
     */
    create: XOR<CommissionedWorkCreateInput, CommissionedWorkUncheckedCreateInput>
    /**
     * In case the CommissionedWork was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommissionedWorkUpdateInput, CommissionedWorkUncheckedUpdateInput>
  }

  /**
   * CommissionedWork delete
   */
  export type CommissionedWorkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionedWork
     */
    select?: CommissionedWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionedWork
     */
    omit?: CommissionedWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionedWorkInclude<ExtArgs> | null
    /**
     * Filter which CommissionedWork to delete.
     */
    where: CommissionedWorkWhereUniqueInput
  }

  /**
   * CommissionedWork deleteMany
   */
  export type CommissionedWorkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionedWorks to delete
     */
    where?: CommissionedWorkWhereInput
    /**
     * Limit how many CommissionedWorks to delete.
     */
    limit?: number
  }

  /**
   * CommissionedWork findRaw
   */
  export type CommissionedWorkFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CommissionedWork aggregateRaw
   */
  export type CommissionedWorkAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CommissionedWork without action
   */
  export type CommissionedWorkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionedWork
     */
    select?: CommissionedWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionedWork
     */
    omit?: CommissionedWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionedWorkInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>



  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * @param {CategoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const category = await prisma.category.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CategoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Category.
     * @param {CategoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const category = await prisma.category.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CategoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category findRaw
   */
  export type CategoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Category aggregateRaw
   */
  export type CategoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.CartStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.CartStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.CartStatus
    createdAt: Date
    updatedAt: Date
    _count: CartCountAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Cart$itemsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>



  export type CartSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["cart"]>
  export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Cart$itemsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$CartItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.CartStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartFindManyArgs>(args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends CartCreateArgs>(args: SelectSubset<T, CartCreateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartCreateManyArgs>(args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends CartDeleteArgs>(args: SelectSubset<T, CartDeleteArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartUpdateArgs>(args: SelectSubset<T, CartUpdateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartDeleteManyArgs>(args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartUpdateManyArgs>(args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(args: SelectSubset<T, CartUpsertArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * @param {CartFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const cart = await prisma.cart.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CartFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Cart.
     * @param {CartAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const cart = await prisma.cart.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CartAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart model
   */
  readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Cart$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Cart$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart model
   */
  interface CartFieldRefs {
    readonly id: FieldRef<"Cart", 'String'>
    readonly userId: FieldRef<"Cart", 'String'>
    readonly status: FieldRef<"Cart", 'CartStatus'>
    readonly createdAt: FieldRef<"Cart", 'DateTime'>
    readonly updatedAt: FieldRef<"Cart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>
  }

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
  }

  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
  }

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }

  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to delete.
     */
    limit?: number
  }

  /**
   * Cart findRaw
   */
  export type CartFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Cart aggregateRaw
   */
  export type CartAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Cart.items
   */
  export type Cart$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Cart without action
   */
  export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
  }


  /**
   * Model CartItem
   */

  export type AggregateCartItem = {
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  export type CartItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type CartItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type CartItemMinAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    quantity: number | null
    addedAt: Date | null
  }

  export type CartItemMaxAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    quantity: number | null
    addedAt: Date | null
  }

  export type CartItemCountAggregateOutputType = {
    id: number
    cartId: number
    productId: number
    quantity: number
    addedAt: number
    _all: number
  }


  export type CartItemAvgAggregateInputType = {
    quantity?: true
  }

  export type CartItemSumAggregateInputType = {
    quantity?: true
  }

  export type CartItemMinAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    addedAt?: true
  }

  export type CartItemMaxAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    addedAt?: true
  }

  export type CartItemCountAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    addedAt?: true
    _all?: true
  }

  export type CartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItem to aggregate.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItems
    **/
    _count?: true | CartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemMaxAggregateInputType
  }

  export type GetCartItemAggregateType<T extends CartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItem[P]>
      : GetScalarType<T[P], AggregateCartItem[P]>
  }




  export type CartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithAggregationInput | CartItemOrderByWithAggregationInput[]
    by: CartItemScalarFieldEnum[] | CartItemScalarFieldEnum
    having?: CartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemCountAggregateInputType | true
    _avg?: CartItemAvgAggregateInputType
    _sum?: CartItemSumAggregateInputType
    _min?: CartItemMinAggregateInputType
    _max?: CartItemMaxAggregateInputType
  }

  export type CartItemGroupByOutputType = {
    id: string
    cartId: string
    productId: string
    quantity: number
    addedAt: Date
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  type GetCartItemGroupByPayload<T extends CartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemGroupByOutputType[P]>
        }
      >
    >


  export type CartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    addedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>



  export type CartItemSelectScalar = {
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    addedAt?: boolean
  }

  export type CartItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cartId" | "productId" | "quantity" | "addedAt", ExtArgs["result"]["cartItem"]>
  export type CartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItem"
    objects: {
      cart: Prisma.$CartPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cartId: string
      productId: string
      quantity: number
      addedAt: Date
    }, ExtArgs["result"]["cartItem"]>
    composites: {}
  }

  type CartItemGetPayload<S extends boolean | null | undefined | CartItemDefaultArgs> = $Result.GetResult<Prisma.$CartItemPayload, S>

  type CartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartItemCountAggregateInputType | true
    }

  export interface CartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItem'], meta: { name: 'CartItem' } }
    /**
     * Find zero or one CartItem that matches the filter.
     * @param {CartItemFindUniqueArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemFindUniqueArgs>(args: SelectSubset<T, CartItemFindUniqueArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemFindUniqueOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemFindFirstArgs>(args?: SelectSubset<T, CartItemFindFirstArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItem.findMany()
     * 
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemFindManyArgs>(args?: SelectSubset<T, CartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartItem.
     * @param {CartItemCreateArgs} args - Arguments to create a CartItem.
     * @example
     * // Create one CartItem
     * const CartItem = await prisma.cartItem.create({
     *   data: {
     *     // ... data to create a CartItem
     *   }
     * })
     * 
     */
    create<T extends CartItemCreateArgs>(args: SelectSubset<T, CartItemCreateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartItems.
     * @param {CartItemCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemCreateManyArgs>(args?: SelectSubset<T, CartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CartItem.
     * @param {CartItemDeleteArgs} args - Arguments to delete one CartItem.
     * @example
     * // Delete one CartItem
     * const CartItem = await prisma.cartItem.delete({
     *   where: {
     *     // ... filter to delete one CartItem
     *   }
     * })
     * 
     */
    delete<T extends CartItemDeleteArgs>(args: SelectSubset<T, CartItemDeleteArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartItem.
     * @param {CartItemUpdateArgs} args - Arguments to update one CartItem.
     * @example
     * // Update one CartItem
     * const cartItem = await prisma.cartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemUpdateArgs>(args: SelectSubset<T, CartItemUpdateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartItems.
     * @param {CartItemDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemDeleteManyArgs>(args?: SelectSubset<T, CartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemUpdateManyArgs>(args: SelectSubset<T, CartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CartItem.
     * @param {CartItemUpsertArgs} args - Arguments to update or create a CartItem.
     * @example
     * // Update or create a CartItem
     * const cartItem = await prisma.cartItem.upsert({
     *   create: {
     *     // ... data to create a CartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItem we want to update
     *   }
     * })
     */
    upsert<T extends CartItemUpsertArgs>(args: SelectSubset<T, CartItemUpsertArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItems that matches the filter.
     * @param {CartItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const cartItem = await prisma.cartItem.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CartItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CartItem.
     * @param {CartItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const cartItem = await prisma.cartItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CartItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItem.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
    **/
    count<T extends CartItemCountArgs>(
      args?: Subset<T, CartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemAggregateArgs>(args: Subset<T, CartItemAggregateArgs>): Prisma.PrismaPromise<GetCartItemAggregateType<T>>

    /**
     * Group by CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemGroupByArgs['orderBy'] }
        : { orderBy?: CartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItem model
   */
  readonly fields: CartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartDefaultArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItem model
   */
  interface CartItemFieldRefs {
    readonly id: FieldRef<"CartItem", 'String'>
    readonly cartId: FieldRef<"CartItem", 'String'>
    readonly productId: FieldRef<"CartItem", 'String'>
    readonly quantity: FieldRef<"CartItem", 'Int'>
    readonly addedAt: FieldRef<"CartItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CartItem findUnique
   */
  export type CartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findUniqueOrThrow
   */
  export type CartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findFirst
   */
  export type CartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findFirstOrThrow
   */
  export type CartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findMany
   */
  export type CartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem create
   */
  export type CartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItem.
     */
    data: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
  }

  /**
   * CartItem createMany
   */
  export type CartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
  }

  /**
   * CartItem update
   */
  export type CartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItem.
     */
    data: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
    /**
     * Choose, which CartItem to update.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem updateMany
   */
  export type CartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
  }

  /**
   * CartItem upsert
   */
  export type CartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItem to update in case it exists.
     */
    where: CartItemWhereUniqueInput
    /**
     * In case the CartItem found by the `where` argument doesn't exist, create a new CartItem with this data.
     */
    create: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
    /**
     * In case the CartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
  }

  /**
   * CartItem delete
   */
  export type CartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter which CartItem to delete.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem deleteMany
   */
  export type CartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to delete.
     */
    limit?: number
  }

  /**
   * CartItem findRaw
   */
  export type CartItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CartItem aggregateRaw
   */
  export type CartItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CartItem without action
   */
  export type CartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
  }


  /**
   * Model PromoCode
   */

  export type AggregatePromoCode = {
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  export type PromoCodeAvgAggregateOutputType = {
    discountValue: number | null
    minOrderAmount: number | null
    maxDiscount: number | null
    usageLimit: number | null
    usedCount: number | null
  }

  export type PromoCodeSumAggregateOutputType = {
    discountValue: number | null
    minOrderAmount: number | null
    maxDiscount: number | null
    usageLimit: number | null
    usedCount: number | null
  }

  export type PromoCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    discountType: string | null
    discountValue: number | null
    minOrderAmount: number | null
    maxDiscount: number | null
    usageLimit: number | null
    usedCount: number | null
    status: $Enums.PromoCodeStatus | null
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date | null
  }

  export type PromoCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    discountType: string | null
    discountValue: number | null
    minOrderAmount: number | null
    maxDiscount: number | null
    usageLimit: number | null
    usedCount: number | null
    status: $Enums.PromoCodeStatus | null
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date | null
  }

  export type PromoCodeCountAggregateOutputType = {
    id: number
    code: number
    description: number
    discountType: number
    discountValue: number
    minOrderAmount: number
    maxDiscount: number
    usageLimit: number
    usedCount: number
    status: number
    validFrom: number
    validUntil: number
    createdAt: number
    _all: number
  }


  export type PromoCodeAvgAggregateInputType = {
    discountValue?: true
    minOrderAmount?: true
    maxDiscount?: true
    usageLimit?: true
    usedCount?: true
  }

  export type PromoCodeSumAggregateInputType = {
    discountValue?: true
    minOrderAmount?: true
    maxDiscount?: true
    usageLimit?: true
    usedCount?: true
  }

  export type PromoCodeMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    minOrderAmount?: true
    maxDiscount?: true
    usageLimit?: true
    usedCount?: true
    status?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
  }

  export type PromoCodeMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    minOrderAmount?: true
    maxDiscount?: true
    usageLimit?: true
    usedCount?: true
    status?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
  }

  export type PromoCodeCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    minOrderAmount?: true
    maxDiscount?: true
    usageLimit?: true
    usedCount?: true
    status?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
    _all?: true
  }

  export type PromoCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCode to aggregate.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoCodes
    **/
    _count?: true | PromoCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromoCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromoCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoCodeMaxAggregateInputType
  }

  export type GetPromoCodeAggregateType<T extends PromoCodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCode[P]>
      : GetScalarType<T[P], AggregatePromoCode[P]>
  }




  export type PromoCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithAggregationInput | PromoCodeOrderByWithAggregationInput[]
    by: PromoCodeScalarFieldEnum[] | PromoCodeScalarFieldEnum
    having?: PromoCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoCodeCountAggregateInputType | true
    _avg?: PromoCodeAvgAggregateInputType
    _sum?: PromoCodeSumAggregateInputType
    _min?: PromoCodeMinAggregateInputType
    _max?: PromoCodeMaxAggregateInputType
  }

  export type PromoCodeGroupByOutputType = {
    id: string
    code: string
    description: string
    discountType: string
    discountValue: number
    minOrderAmount: number | null
    maxDiscount: number | null
    usageLimit: number | null
    usedCount: number
    status: $Enums.PromoCodeStatus
    validFrom: Date
    validUntil: Date
    createdAt: Date
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  type GetPromoCodeGroupByPayload<T extends PromoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
            : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
        }
      >
    >


  export type PromoCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    minOrderAmount?: boolean
    maxDiscount?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    status?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
    orders?: boolean | PromoCode$ordersArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCode"]>



  export type PromoCodeSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    minOrderAmount?: boolean
    maxDiscount?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    status?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
  }

  export type PromoCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "discountType" | "discountValue" | "minOrderAmount" | "maxDiscount" | "usageLimit" | "usedCount" | "status" | "validFrom" | "validUntil" | "createdAt", ExtArgs["result"]["promoCode"]>
  export type PromoCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | PromoCode$ordersArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PromoCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoCode"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string
      discountType: string
      discountValue: number
      minOrderAmount: number | null
      maxDiscount: number | null
      usageLimit: number | null
      usedCount: number
      status: $Enums.PromoCodeStatus
      validFrom: Date
      validUntil: Date
      createdAt: Date
    }, ExtArgs["result"]["promoCode"]>
    composites: {}
  }

  type PromoCodeGetPayload<S extends boolean | null | undefined | PromoCodeDefaultArgs> = $Result.GetResult<Prisma.$PromoCodePayload, S>

  type PromoCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromoCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromoCodeCountAggregateInputType | true
    }

  export interface PromoCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoCode'], meta: { name: 'PromoCode' } }
    /**
     * Find zero or one PromoCode that matches the filter.
     * @param {PromoCodeFindUniqueArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoCodeFindUniqueArgs>(args: SelectSubset<T, PromoCodeFindUniqueArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromoCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromoCodeFindUniqueOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoCodeFindFirstArgs>(args?: SelectSubset<T, PromoCodeFindFirstArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodes
     * const promoCodes = await prisma.promoCode.findMany()
     * 
     * // Get first 10 PromoCodes
     * const promoCodes = await prisma.promoCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoCodeFindManyArgs>(args?: SelectSubset<T, PromoCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromoCode.
     * @param {PromoCodeCreateArgs} args - Arguments to create a PromoCode.
     * @example
     * // Create one PromoCode
     * const PromoCode = await prisma.promoCode.create({
     *   data: {
     *     // ... data to create a PromoCode
     *   }
     * })
     * 
     */
    create<T extends PromoCodeCreateArgs>(args: SelectSubset<T, PromoCodeCreateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromoCodes.
     * @param {PromoCodeCreateManyArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoCodeCreateManyArgs>(args?: SelectSubset<T, PromoCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PromoCode.
     * @param {PromoCodeDeleteArgs} args - Arguments to delete one PromoCode.
     * @example
     * // Delete one PromoCode
     * const PromoCode = await prisma.promoCode.delete({
     *   where: {
     *     // ... filter to delete one PromoCode
     *   }
     * })
     * 
     */
    delete<T extends PromoCodeDeleteArgs>(args: SelectSubset<T, PromoCodeDeleteArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromoCode.
     * @param {PromoCodeUpdateArgs} args - Arguments to update one PromoCode.
     * @example
     * // Update one PromoCode
     * const promoCode = await prisma.promoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoCodeUpdateArgs>(args: SelectSubset<T, PromoCodeUpdateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromoCodes.
     * @param {PromoCodeDeleteManyArgs} args - Arguments to filter PromoCodes to delete.
     * @example
     * // Delete a few PromoCodes
     * const { count } = await prisma.promoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoCodeDeleteManyArgs>(args?: SelectSubset<T, PromoCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoCodeUpdateManyArgs>(args: SelectSubset<T, PromoCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromoCode.
     * @param {PromoCodeUpsertArgs} args - Arguments to update or create a PromoCode.
     * @example
     * // Update or create a PromoCode
     * const promoCode = await prisma.promoCode.upsert({
     *   create: {
     *     // ... data to create a PromoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCode we want to update
     *   }
     * })
     */
    upsert<T extends PromoCodeUpsertArgs>(args: SelectSubset<T, PromoCodeUpsertArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromoCodes that matches the filter.
     * @param {PromoCodeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const promoCode = await prisma.promoCode.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PromoCodeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PromoCode.
     * @param {PromoCodeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const promoCode = await prisma.promoCode.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PromoCodeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeCountArgs} args - Arguments to filter PromoCodes to count.
     * @example
     * // Count the number of PromoCodes
     * const count = await prisma.promoCode.count({
     *   where: {
     *     // ... the filter for the PromoCodes we want to count
     *   }
     * })
    **/
    count<T extends PromoCodeCountArgs>(
      args?: Subset<T, PromoCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoCodeAggregateArgs>(args: Subset<T, PromoCodeAggregateArgs>): Prisma.PrismaPromise<GetPromoCodeAggregateType<T>>

    /**
     * Group by PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoCode model
   */
  readonly fields: PromoCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends PromoCode$ordersArgs<ExtArgs> = {}>(args?: Subset<T, PromoCode$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoCode model
   */
  interface PromoCodeFieldRefs {
    readonly id: FieldRef<"PromoCode", 'String'>
    readonly code: FieldRef<"PromoCode", 'String'>
    readonly description: FieldRef<"PromoCode", 'String'>
    readonly discountType: FieldRef<"PromoCode", 'String'>
    readonly discountValue: FieldRef<"PromoCode", 'Float'>
    readonly minOrderAmount: FieldRef<"PromoCode", 'Float'>
    readonly maxDiscount: FieldRef<"PromoCode", 'Float'>
    readonly usageLimit: FieldRef<"PromoCode", 'Int'>
    readonly usedCount: FieldRef<"PromoCode", 'Int'>
    readonly status: FieldRef<"PromoCode", 'PromoCodeStatus'>
    readonly validFrom: FieldRef<"PromoCode", 'DateTime'>
    readonly validUntil: FieldRef<"PromoCode", 'DateTime'>
    readonly createdAt: FieldRef<"PromoCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromoCode findUnique
   */
  export type PromoCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findUniqueOrThrow
   */
  export type PromoCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findFirst
   */
  export type PromoCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findFirstOrThrow
   */
  export type PromoCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findMany
   */
  export type PromoCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodes to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode create
   */
  export type PromoCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoCode.
     */
    data: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
  }

  /**
   * PromoCode createMany
   */
  export type PromoCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
  }

  /**
   * PromoCode update
   */
  export type PromoCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoCode.
     */
    data: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
    /**
     * Choose, which PromoCode to update.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode updateMany
   */
  export type PromoCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to update.
     */
    limit?: number
  }

  /**
   * PromoCode upsert
   */
  export type PromoCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoCode to update in case it exists.
     */
    where: PromoCodeWhereUniqueInput
    /**
     * In case the PromoCode found by the `where` argument doesn't exist, create a new PromoCode with this data.
     */
    create: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
    /**
     * In case the PromoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
  }

  /**
   * PromoCode delete
   */
  export type PromoCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter which PromoCode to delete.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode deleteMany
   */
  export type PromoCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodes to delete
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to delete.
     */
    limit?: number
  }

  /**
   * PromoCode findRaw
   */
  export type PromoCodeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PromoCode aggregateRaw
   */
  export type PromoCodeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PromoCode.orders
   */
  export type PromoCode$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * PromoCode without action
   */
  export type PromoCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
  }


  /**
   * Model Audit
   */

  export type AggregateAudit = {
    _count: AuditCountAggregateOutputType | null
    _min: AuditMinAggregateOutputType | null
    _max: AuditMaxAggregateOutputType | null
  }

  export type AuditMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    details: string | null
    timestamp: Date | null
  }

  export type AuditMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    details: string | null
    timestamp: Date | null
  }

  export type AuditCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    details: number
    timestamp: number
    _all: number
  }


  export type AuditMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    details?: true
    timestamp?: true
  }

  export type AuditMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    details?: true
    timestamp?: true
  }

  export type AuditCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    details?: true
    timestamp?: true
    _all?: true
  }

  export type AuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Audit to aggregate.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Audits
    **/
    _count?: true | AuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditMaxAggregateInputType
  }

  export type GetAuditAggregateType<T extends AuditAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit[P]>
      : GetScalarType<T[P], AggregateAudit[P]>
  }




  export type AuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithAggregationInput | AuditOrderByWithAggregationInput[]
    by: AuditScalarFieldEnum[] | AuditScalarFieldEnum
    having?: AuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditCountAggregateInputType | true
    _min?: AuditMinAggregateInputType
    _max?: AuditMaxAggregateInputType
  }

  export type AuditGroupByOutputType = {
    id: string
    userId: string
    action: string
    resource: string | null
    details: string | null
    timestamp: Date
    _count: AuditCountAggregateOutputType | null
    _min: AuditMinAggregateOutputType | null
    _max: AuditMaxAggregateOutputType | null
  }

  type GetAuditGroupByPayload<T extends AuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditGroupByOutputType[P]>
            : GetScalarType<T[P], AuditGroupByOutputType[P]>
        }
      >
    >


  export type AuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    details?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit"]>



  export type AuditSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    details?: boolean
    timestamp?: boolean
  }

  export type AuditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "resource" | "details" | "timestamp", ExtArgs["result"]["audit"]>
  export type AuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Audit"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      resource: string | null
      details: string | null
      timestamp: Date
    }, ExtArgs["result"]["audit"]>
    composites: {}
  }

  type AuditGetPayload<S extends boolean | null | undefined | AuditDefaultArgs> = $Result.GetResult<Prisma.$AuditPayload, S>

  type AuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditCountAggregateInputType | true
    }

  export interface AuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Audit'], meta: { name: 'Audit' } }
    /**
     * Find zero or one Audit that matches the filter.
     * @param {AuditFindUniqueArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditFindUniqueArgs>(args: SelectSubset<T, AuditFindUniqueArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditFindUniqueOrThrowArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindFirstArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditFindFirstArgs>(args?: SelectSubset<T, AuditFindFirstArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindFirstOrThrowArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audits
     * const audits = await prisma.audit.findMany()
     * 
     * // Get first 10 Audits
     * const audits = await prisma.audit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditWithIdOnly = await prisma.audit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditFindManyArgs>(args?: SelectSubset<T, AuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit.
     * @param {AuditCreateArgs} args - Arguments to create a Audit.
     * @example
     * // Create one Audit
     * const Audit = await prisma.audit.create({
     *   data: {
     *     // ... data to create a Audit
     *   }
     * })
     * 
     */
    create<T extends AuditCreateArgs>(args: SelectSubset<T, AuditCreateArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audits.
     * @param {AuditCreateManyArgs} args - Arguments to create many Audits.
     * @example
     * // Create many Audits
     * const audit = await prisma.audit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditCreateManyArgs>(args?: SelectSubset<T, AuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Audit.
     * @param {AuditDeleteArgs} args - Arguments to delete one Audit.
     * @example
     * // Delete one Audit
     * const Audit = await prisma.audit.delete({
     *   where: {
     *     // ... filter to delete one Audit
     *   }
     * })
     * 
     */
    delete<T extends AuditDeleteArgs>(args: SelectSubset<T, AuditDeleteArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit.
     * @param {AuditUpdateArgs} args - Arguments to update one Audit.
     * @example
     * // Update one Audit
     * const audit = await prisma.audit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditUpdateArgs>(args: SelectSubset<T, AuditUpdateArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audits.
     * @param {AuditDeleteManyArgs} args - Arguments to filter Audits to delete.
     * @example
     * // Delete a few Audits
     * const { count } = await prisma.audit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditDeleteManyArgs>(args?: SelectSubset<T, AuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audits
     * const audit = await prisma.audit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditUpdateManyArgs>(args: SelectSubset<T, AuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Audit.
     * @param {AuditUpsertArgs} args - Arguments to update or create a Audit.
     * @example
     * // Update or create a Audit
     * const audit = await prisma.audit.upsert({
     *   create: {
     *     // ... data to create a Audit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit we want to update
     *   }
     * })
     */
    upsert<T extends AuditUpsertArgs>(args: SelectSubset<T, AuditUpsertArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audits that matches the filter.
     * @param {AuditFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const audit = await prisma.audit.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AuditFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Audit.
     * @param {AuditAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const audit = await prisma.audit.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AuditAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditCountArgs} args - Arguments to filter Audits to count.
     * @example
     * // Count the number of Audits
     * const count = await prisma.audit.count({
     *   where: {
     *     // ... the filter for the Audits we want to count
     *   }
     * })
    **/
    count<T extends AuditCountArgs>(
      args?: Subset<T, AuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditAggregateArgs>(args: Subset<T, AuditAggregateArgs>): Prisma.PrismaPromise<GetAuditAggregateType<T>>

    /**
     * Group by Audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditGroupByArgs['orderBy'] }
        : { orderBy?: AuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Audit model
   */
  readonly fields: AuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Audit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Audit model
   */
  interface AuditFieldRefs {
    readonly id: FieldRef<"Audit", 'String'>
    readonly userId: FieldRef<"Audit", 'String'>
    readonly action: FieldRef<"Audit", 'String'>
    readonly resource: FieldRef<"Audit", 'String'>
    readonly details: FieldRef<"Audit", 'String'>
    readonly timestamp: FieldRef<"Audit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Audit findUnique
   */
  export type AuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit findUniqueOrThrow
   */
  export type AuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit findFirst
   */
  export type AuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audits.
     */
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit findFirstOrThrow
   */
  export type AuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audits.
     */
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit findMany
   */
  export type AuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audits to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit create
   */
  export type AuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * The data needed to create a Audit.
     */
    data: XOR<AuditCreateInput, AuditUncheckedCreateInput>
  }

  /**
   * Audit createMany
   */
  export type AuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Audits.
     */
    data: AuditCreateManyInput | AuditCreateManyInput[]
  }

  /**
   * Audit update
   */
  export type AuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * The data needed to update a Audit.
     */
    data: XOR<AuditUpdateInput, AuditUncheckedUpdateInput>
    /**
     * Choose, which Audit to update.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit updateMany
   */
  export type AuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Audits.
     */
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyInput>
    /**
     * Filter which Audits to update
     */
    where?: AuditWhereInput
    /**
     * Limit how many Audits to update.
     */
    limit?: number
  }

  /**
   * Audit upsert
   */
  export type AuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * The filter to search for the Audit to update in case it exists.
     */
    where: AuditWhereUniqueInput
    /**
     * In case the Audit found by the `where` argument doesn't exist, create a new Audit with this data.
     */
    create: XOR<AuditCreateInput, AuditUncheckedCreateInput>
    /**
     * In case the Audit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditUpdateInput, AuditUncheckedUpdateInput>
  }

  /**
   * Audit delete
   */
  export type AuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter which Audit to delete.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit deleteMany
   */
  export type AuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Audits to delete
     */
    where?: AuditWhereInput
    /**
     * Limit how many Audits to delete.
     */
    limit?: number
  }

  /**
   * Audit findRaw
   */
  export type AuditFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Audit aggregateRaw
   */
  export type AuditAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Audit without action
   */
  export type AuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: string | null
    message: string | null
    userId: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    message: string | null
    userId: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    message: number
    userId: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    message?: true
    userId?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    message?: true
    userId?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    message?: true
    userId?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: string
    message: string
    userId: string | null
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    message?: boolean
    userId?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    message?: boolean
    userId?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "message" | "userId" | "isRead" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      message: string
      userId: string | null
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * @param {NotificationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const notification = await prisma.notification.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: NotificationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Notification.
     * @param {NotificationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const notification = await prisma.notification.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NotificationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Notification$userArgs<ExtArgs> = {}>(args?: Subset<T, Notification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification findRaw
   */
  export type NotificationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification aggregateRaw
   */
  export type NotificationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification.user
   */
  export type Notification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model FinancialLog
   */

  export type AggregateFinancialLog = {
    _count: FinancialLogCountAggregateOutputType | null
    _avg: FinancialLogAvgAggregateOutputType | null
    _sum: FinancialLogSumAggregateOutputType | null
    _min: FinancialLogMinAggregateOutputType | null
    _max: FinancialLogMaxAggregateOutputType | null
  }

  export type FinancialLogAvgAggregateOutputType = {
    amount: number | null
  }

  export type FinancialLogSumAggregateOutputType = {
    amount: number | null
  }

  export type FinancialLogMinAggregateOutputType = {
    id: string | null
    type: $Enums.FinancialLogType | null
    amount: number | null
    description: string | null
    category: string | null
    reference: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancialLogMaxAggregateOutputType = {
    id: string | null
    type: $Enums.FinancialLogType | null
    amount: number | null
    description: string | null
    category: string | null
    reference: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancialLogCountAggregateOutputType = {
    id: number
    type: number
    amount: number
    description: number
    category: number
    reference: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FinancialLogAvgAggregateInputType = {
    amount?: true
  }

  export type FinancialLogSumAggregateInputType = {
    amount?: true
  }

  export type FinancialLogMinAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    description?: true
    category?: true
    reference?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancialLogMaxAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    description?: true
    category?: true
    reference?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancialLogCountAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    description?: true
    category?: true
    reference?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FinancialLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialLog to aggregate.
     */
    where?: FinancialLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialLogs to fetch.
     */
    orderBy?: FinancialLogOrderByWithRelationInput | FinancialLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialLogs
    **/
    _count?: true | FinancialLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialLogMaxAggregateInputType
  }

  export type GetFinancialLogAggregateType<T extends FinancialLogAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialLog[P]>
      : GetScalarType<T[P], AggregateFinancialLog[P]>
  }




  export type FinancialLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialLogWhereInput
    orderBy?: FinancialLogOrderByWithAggregationInput | FinancialLogOrderByWithAggregationInput[]
    by: FinancialLogScalarFieldEnum[] | FinancialLogScalarFieldEnum
    having?: FinancialLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialLogCountAggregateInputType | true
    _avg?: FinancialLogAvgAggregateInputType
    _sum?: FinancialLogSumAggregateInputType
    _min?: FinancialLogMinAggregateInputType
    _max?: FinancialLogMaxAggregateInputType
  }

  export type FinancialLogGroupByOutputType = {
    id: string
    type: $Enums.FinancialLogType
    amount: number
    description: string
    category: string | null
    reference: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: FinancialLogCountAggregateOutputType | null
    _avg: FinancialLogAvgAggregateOutputType | null
    _sum: FinancialLogSumAggregateOutputType | null
    _min: FinancialLogMinAggregateOutputType | null
    _max: FinancialLogMaxAggregateOutputType | null
  }

  type GetFinancialLogGroupByPayload<T extends FinancialLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialLogGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialLogGroupByOutputType[P]>
        }
      >
    >


  export type FinancialLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    category?: boolean
    reference?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialLog"]>



  export type FinancialLogSelectScalar = {
    id?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    category?: boolean
    reference?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FinancialLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "amount" | "description" | "category" | "reference" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["financialLog"]>
  export type FinancialLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FinancialLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialLog"
    objects: {
      createdByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.FinancialLogType
      amount: number
      description: string
      category: string | null
      reference: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["financialLog"]>
    composites: {}
  }

  type FinancialLogGetPayload<S extends boolean | null | undefined | FinancialLogDefaultArgs> = $Result.GetResult<Prisma.$FinancialLogPayload, S>

  type FinancialLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinancialLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancialLogCountAggregateInputType | true
    }

  export interface FinancialLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialLog'], meta: { name: 'FinancialLog' } }
    /**
     * Find zero or one FinancialLog that matches the filter.
     * @param {FinancialLogFindUniqueArgs} args - Arguments to find a FinancialLog
     * @example
     * // Get one FinancialLog
     * const financialLog = await prisma.financialLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialLogFindUniqueArgs>(args: SelectSubset<T, FinancialLogFindUniqueArgs<ExtArgs>>): Prisma__FinancialLogClient<$Result.GetResult<Prisma.$FinancialLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinancialLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinancialLogFindUniqueOrThrowArgs} args - Arguments to find a FinancialLog
     * @example
     * // Get one FinancialLog
     * const financialLog = await prisma.financialLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialLogFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialLogClient<$Result.GetResult<Prisma.$FinancialLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialLogFindFirstArgs} args - Arguments to find a FinancialLog
     * @example
     * // Get one FinancialLog
     * const financialLog = await prisma.financialLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialLogFindFirstArgs>(args?: SelectSubset<T, FinancialLogFindFirstArgs<ExtArgs>>): Prisma__FinancialLogClient<$Result.GetResult<Prisma.$FinancialLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialLogFindFirstOrThrowArgs} args - Arguments to find a FinancialLog
     * @example
     * // Get one FinancialLog
     * const financialLog = await prisma.financialLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialLogFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialLogClient<$Result.GetResult<Prisma.$FinancialLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinancialLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialLogs
     * const financialLogs = await prisma.financialLog.findMany()
     * 
     * // Get first 10 FinancialLogs
     * const financialLogs = await prisma.financialLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialLogWithIdOnly = await prisma.financialLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialLogFindManyArgs>(args?: SelectSubset<T, FinancialLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinancialLog.
     * @param {FinancialLogCreateArgs} args - Arguments to create a FinancialLog.
     * @example
     * // Create one FinancialLog
     * const FinancialLog = await prisma.financialLog.create({
     *   data: {
     *     // ... data to create a FinancialLog
     *   }
     * })
     * 
     */
    create<T extends FinancialLogCreateArgs>(args: SelectSubset<T, FinancialLogCreateArgs<ExtArgs>>): Prisma__FinancialLogClient<$Result.GetResult<Prisma.$FinancialLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinancialLogs.
     * @param {FinancialLogCreateManyArgs} args - Arguments to create many FinancialLogs.
     * @example
     * // Create many FinancialLogs
     * const financialLog = await prisma.financialLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialLogCreateManyArgs>(args?: SelectSubset<T, FinancialLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FinancialLog.
     * @param {FinancialLogDeleteArgs} args - Arguments to delete one FinancialLog.
     * @example
     * // Delete one FinancialLog
     * const FinancialLog = await prisma.financialLog.delete({
     *   where: {
     *     // ... filter to delete one FinancialLog
     *   }
     * })
     * 
     */
    delete<T extends FinancialLogDeleteArgs>(args: SelectSubset<T, FinancialLogDeleteArgs<ExtArgs>>): Prisma__FinancialLogClient<$Result.GetResult<Prisma.$FinancialLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinancialLog.
     * @param {FinancialLogUpdateArgs} args - Arguments to update one FinancialLog.
     * @example
     * // Update one FinancialLog
     * const financialLog = await prisma.financialLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialLogUpdateArgs>(args: SelectSubset<T, FinancialLogUpdateArgs<ExtArgs>>): Prisma__FinancialLogClient<$Result.GetResult<Prisma.$FinancialLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinancialLogs.
     * @param {FinancialLogDeleteManyArgs} args - Arguments to filter FinancialLogs to delete.
     * @example
     * // Delete a few FinancialLogs
     * const { count } = await prisma.financialLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialLogDeleteManyArgs>(args?: SelectSubset<T, FinancialLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialLogs
     * const financialLog = await prisma.financialLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialLogUpdateManyArgs>(args: SelectSubset<T, FinancialLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FinancialLog.
     * @param {FinancialLogUpsertArgs} args - Arguments to update or create a FinancialLog.
     * @example
     * // Update or create a FinancialLog
     * const financialLog = await prisma.financialLog.upsert({
     *   create: {
     *     // ... data to create a FinancialLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialLog we want to update
     *   }
     * })
     */
    upsert<T extends FinancialLogUpsertArgs>(args: SelectSubset<T, FinancialLogUpsertArgs<ExtArgs>>): Prisma__FinancialLogClient<$Result.GetResult<Prisma.$FinancialLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinancialLogs that matches the filter.
     * @param {FinancialLogFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const financialLog = await prisma.financialLog.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FinancialLogFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FinancialLog.
     * @param {FinancialLogAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const financialLog = await prisma.financialLog.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FinancialLogAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FinancialLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialLogCountArgs} args - Arguments to filter FinancialLogs to count.
     * @example
     * // Count the number of FinancialLogs
     * const count = await prisma.financialLog.count({
     *   where: {
     *     // ... the filter for the FinancialLogs we want to count
     *   }
     * })
    **/
    count<T extends FinancialLogCountArgs>(
      args?: Subset<T, FinancialLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialLogAggregateArgs>(args: Subset<T, FinancialLogAggregateArgs>): Prisma.PrismaPromise<GetFinancialLogAggregateType<T>>

    /**
     * Group by FinancialLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialLogGroupByArgs['orderBy'] }
        : { orderBy?: FinancialLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialLog model
   */
  readonly fields: FinancialLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialLog model
   */
  interface FinancialLogFieldRefs {
    readonly id: FieldRef<"FinancialLog", 'String'>
    readonly type: FieldRef<"FinancialLog", 'FinancialLogType'>
    readonly amount: FieldRef<"FinancialLog", 'Float'>
    readonly description: FieldRef<"FinancialLog", 'String'>
    readonly category: FieldRef<"FinancialLog", 'String'>
    readonly reference: FieldRef<"FinancialLog", 'String'>
    readonly createdBy: FieldRef<"FinancialLog", 'String'>
    readonly createdAt: FieldRef<"FinancialLog", 'DateTime'>
    readonly updatedAt: FieldRef<"FinancialLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FinancialLog findUnique
   */
  export type FinancialLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialLog
     */
    select?: FinancialLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialLog
     */
    omit?: FinancialLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialLogInclude<ExtArgs> | null
    /**
     * Filter, which FinancialLog to fetch.
     */
    where: FinancialLogWhereUniqueInput
  }

  /**
   * FinancialLog findUniqueOrThrow
   */
  export type FinancialLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialLog
     */
    select?: FinancialLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialLog
     */
    omit?: FinancialLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialLogInclude<ExtArgs> | null
    /**
     * Filter, which FinancialLog to fetch.
     */
    where: FinancialLogWhereUniqueInput
  }

  /**
   * FinancialLog findFirst
   */
  export type FinancialLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialLog
     */
    select?: FinancialLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialLog
     */
    omit?: FinancialLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialLogInclude<ExtArgs> | null
    /**
     * Filter, which FinancialLog to fetch.
     */
    where?: FinancialLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialLogs to fetch.
     */
    orderBy?: FinancialLogOrderByWithRelationInput | FinancialLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialLogs.
     */
    cursor?: FinancialLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialLogs.
     */
    distinct?: FinancialLogScalarFieldEnum | FinancialLogScalarFieldEnum[]
  }

  /**
   * FinancialLog findFirstOrThrow
   */
  export type FinancialLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialLog
     */
    select?: FinancialLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialLog
     */
    omit?: FinancialLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialLogInclude<ExtArgs> | null
    /**
     * Filter, which FinancialLog to fetch.
     */
    where?: FinancialLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialLogs to fetch.
     */
    orderBy?: FinancialLogOrderByWithRelationInput | FinancialLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialLogs.
     */
    cursor?: FinancialLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialLogs.
     */
    distinct?: FinancialLogScalarFieldEnum | FinancialLogScalarFieldEnum[]
  }

  /**
   * FinancialLog findMany
   */
  export type FinancialLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialLog
     */
    select?: FinancialLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialLog
     */
    omit?: FinancialLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialLogInclude<ExtArgs> | null
    /**
     * Filter, which FinancialLogs to fetch.
     */
    where?: FinancialLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialLogs to fetch.
     */
    orderBy?: FinancialLogOrderByWithRelationInput | FinancialLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialLogs.
     */
    cursor?: FinancialLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialLogs.
     */
    skip?: number
    distinct?: FinancialLogScalarFieldEnum | FinancialLogScalarFieldEnum[]
  }

  /**
   * FinancialLog create
   */
  export type FinancialLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialLog
     */
    select?: FinancialLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialLog
     */
    omit?: FinancialLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialLogInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialLog.
     */
    data: XOR<FinancialLogCreateInput, FinancialLogUncheckedCreateInput>
  }

  /**
   * FinancialLog createMany
   */
  export type FinancialLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialLogs.
     */
    data: FinancialLogCreateManyInput | FinancialLogCreateManyInput[]
  }

  /**
   * FinancialLog update
   */
  export type FinancialLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialLog
     */
    select?: FinancialLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialLog
     */
    omit?: FinancialLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialLogInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialLog.
     */
    data: XOR<FinancialLogUpdateInput, FinancialLogUncheckedUpdateInput>
    /**
     * Choose, which FinancialLog to update.
     */
    where: FinancialLogWhereUniqueInput
  }

  /**
   * FinancialLog updateMany
   */
  export type FinancialLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialLogs.
     */
    data: XOR<FinancialLogUpdateManyMutationInput, FinancialLogUncheckedUpdateManyInput>
    /**
     * Filter which FinancialLogs to update
     */
    where?: FinancialLogWhereInput
    /**
     * Limit how many FinancialLogs to update.
     */
    limit?: number
  }

  /**
   * FinancialLog upsert
   */
  export type FinancialLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialLog
     */
    select?: FinancialLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialLog
     */
    omit?: FinancialLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialLogInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialLog to update in case it exists.
     */
    where: FinancialLogWhereUniqueInput
    /**
     * In case the FinancialLog found by the `where` argument doesn't exist, create a new FinancialLog with this data.
     */
    create: XOR<FinancialLogCreateInput, FinancialLogUncheckedCreateInput>
    /**
     * In case the FinancialLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialLogUpdateInput, FinancialLogUncheckedUpdateInput>
  }

  /**
   * FinancialLog delete
   */
  export type FinancialLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialLog
     */
    select?: FinancialLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialLog
     */
    omit?: FinancialLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialLogInclude<ExtArgs> | null
    /**
     * Filter which FinancialLog to delete.
     */
    where: FinancialLogWhereUniqueInput
  }

  /**
   * FinancialLog deleteMany
   */
  export type FinancialLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialLogs to delete
     */
    where?: FinancialLogWhereInput
    /**
     * Limit how many FinancialLogs to delete.
     */
    limit?: number
  }

  /**
   * FinancialLog findRaw
   */
  export type FinancialLogFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FinancialLog aggregateRaw
   */
  export type FinancialLogAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FinancialLog without action
   */
  export type FinancialLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialLog
     */
    select?: FinancialLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialLog
     */
    omit?: FinancialLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialLogInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    dueDate: Date | null
    executiveId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    dueDate: Date | null
    executiveId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    dueDate: number
    executiveId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    dueDate?: true
    executiveId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    dueDate?: true
    executiveId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    dueDate?: true
    executiveId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string
    status: $Enums.TaskStatus
    dueDate: Date | null
    executiveId: string
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    executiveId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["task"]>



  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    executiveId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "dueDate" | "executiveId" | "createdAt" | "updatedAt", ExtArgs["result"]["task"]>

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      status: $Enums.TaskStatus
      dueDate: Date | null
      executiveId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * @param {TaskFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const task = await prisma.task.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TaskFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Task.
     * @param {TaskAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const task = await prisma.task.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TaskAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly executiveId: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task findRaw
   */
  export type TaskFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Task aggregateRaw
   */
  export type TaskAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
  }


  /**
   * Model DamageReport
   */

  export type AggregateDamageReport = {
    _count: DamageReportCountAggregateOutputType | null
    _avg: DamageReportAvgAggregateOutputType | null
    _sum: DamageReportSumAggregateOutputType | null
    _min: DamageReportMinAggregateOutputType | null
    _max: DamageReportMaxAggregateOutputType | null
  }

  export type DamageReportAvgAggregateOutputType = {
    quantity: number | null
  }

  export type DamageReportSumAggregateOutputType = {
    quantity: number | null
  }

  export type DamageReportMinAggregateOutputType = {
    id: string | null
    stockId: string | null
    workerId: string | null
    reason: string | null
    quantity: number | null
    location: string | null
    reportedAt: Date | null
  }

  export type DamageReportMaxAggregateOutputType = {
    id: string | null
    stockId: string | null
    workerId: string | null
    reason: string | null
    quantity: number | null
    location: string | null
    reportedAt: Date | null
  }

  export type DamageReportCountAggregateOutputType = {
    id: number
    stockId: number
    workerId: number
    reason: number
    quantity: number
    location: number
    reportedAt: number
    _all: number
  }


  export type DamageReportAvgAggregateInputType = {
    quantity?: true
  }

  export type DamageReportSumAggregateInputType = {
    quantity?: true
  }

  export type DamageReportMinAggregateInputType = {
    id?: true
    stockId?: true
    workerId?: true
    reason?: true
    quantity?: true
    location?: true
    reportedAt?: true
  }

  export type DamageReportMaxAggregateInputType = {
    id?: true
    stockId?: true
    workerId?: true
    reason?: true
    quantity?: true
    location?: true
    reportedAt?: true
  }

  export type DamageReportCountAggregateInputType = {
    id?: true
    stockId?: true
    workerId?: true
    reason?: true
    quantity?: true
    location?: true
    reportedAt?: true
    _all?: true
  }

  export type DamageReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DamageReport to aggregate.
     */
    where?: DamageReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageReports to fetch.
     */
    orderBy?: DamageReportOrderByWithRelationInput | DamageReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DamageReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DamageReports
    **/
    _count?: true | DamageReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DamageReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DamageReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DamageReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DamageReportMaxAggregateInputType
  }

  export type GetDamageReportAggregateType<T extends DamageReportAggregateArgs> = {
        [P in keyof T & keyof AggregateDamageReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDamageReport[P]>
      : GetScalarType<T[P], AggregateDamageReport[P]>
  }




  export type DamageReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DamageReportWhereInput
    orderBy?: DamageReportOrderByWithAggregationInput | DamageReportOrderByWithAggregationInput[]
    by: DamageReportScalarFieldEnum[] | DamageReportScalarFieldEnum
    having?: DamageReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DamageReportCountAggregateInputType | true
    _avg?: DamageReportAvgAggregateInputType
    _sum?: DamageReportSumAggregateInputType
    _min?: DamageReportMinAggregateInputType
    _max?: DamageReportMaxAggregateInputType
  }

  export type DamageReportGroupByOutputType = {
    id: string
    stockId: string
    workerId: string
    reason: string
    quantity: number
    location: string
    reportedAt: Date
    _count: DamageReportCountAggregateOutputType | null
    _avg: DamageReportAvgAggregateOutputType | null
    _sum: DamageReportSumAggregateOutputType | null
    _min: DamageReportMinAggregateOutputType | null
    _max: DamageReportMaxAggregateOutputType | null
  }

  type GetDamageReportGroupByPayload<T extends DamageReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DamageReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DamageReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DamageReportGroupByOutputType[P]>
            : GetScalarType<T[P], DamageReportGroupByOutputType[P]>
        }
      >
    >


  export type DamageReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stockId?: boolean
    workerId?: boolean
    reason?: boolean
    quantity?: boolean
    location?: boolean
    reportedAt?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["damageReport"]>



  export type DamageReportSelectScalar = {
    id?: boolean
    stockId?: boolean
    workerId?: boolean
    reason?: boolean
    quantity?: boolean
    location?: boolean
    reportedAt?: boolean
  }

  export type DamageReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stockId" | "workerId" | "reason" | "quantity" | "location" | "reportedAt", ExtArgs["result"]["damageReport"]>
  export type DamageReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
  }

  export type $DamageReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DamageReport"
    objects: {
      stock: Prisma.$StockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stockId: string
      workerId: string
      reason: string
      quantity: number
      location: string
      reportedAt: Date
    }, ExtArgs["result"]["damageReport"]>
    composites: {}
  }

  type DamageReportGetPayload<S extends boolean | null | undefined | DamageReportDefaultArgs> = $Result.GetResult<Prisma.$DamageReportPayload, S>

  type DamageReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DamageReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DamageReportCountAggregateInputType | true
    }

  export interface DamageReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DamageReport'], meta: { name: 'DamageReport' } }
    /**
     * Find zero or one DamageReport that matches the filter.
     * @param {DamageReportFindUniqueArgs} args - Arguments to find a DamageReport
     * @example
     * // Get one DamageReport
     * const damageReport = await prisma.damageReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DamageReportFindUniqueArgs>(args: SelectSubset<T, DamageReportFindUniqueArgs<ExtArgs>>): Prisma__DamageReportClient<$Result.GetResult<Prisma.$DamageReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DamageReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DamageReportFindUniqueOrThrowArgs} args - Arguments to find a DamageReport
     * @example
     * // Get one DamageReport
     * const damageReport = await prisma.damageReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DamageReportFindUniqueOrThrowArgs>(args: SelectSubset<T, DamageReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DamageReportClient<$Result.GetResult<Prisma.$DamageReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DamageReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageReportFindFirstArgs} args - Arguments to find a DamageReport
     * @example
     * // Get one DamageReport
     * const damageReport = await prisma.damageReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DamageReportFindFirstArgs>(args?: SelectSubset<T, DamageReportFindFirstArgs<ExtArgs>>): Prisma__DamageReportClient<$Result.GetResult<Prisma.$DamageReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DamageReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageReportFindFirstOrThrowArgs} args - Arguments to find a DamageReport
     * @example
     * // Get one DamageReport
     * const damageReport = await prisma.damageReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DamageReportFindFirstOrThrowArgs>(args?: SelectSubset<T, DamageReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__DamageReportClient<$Result.GetResult<Prisma.$DamageReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DamageReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DamageReports
     * const damageReports = await prisma.damageReport.findMany()
     * 
     * // Get first 10 DamageReports
     * const damageReports = await prisma.damageReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const damageReportWithIdOnly = await prisma.damageReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DamageReportFindManyArgs>(args?: SelectSubset<T, DamageReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DamageReport.
     * @param {DamageReportCreateArgs} args - Arguments to create a DamageReport.
     * @example
     * // Create one DamageReport
     * const DamageReport = await prisma.damageReport.create({
     *   data: {
     *     // ... data to create a DamageReport
     *   }
     * })
     * 
     */
    create<T extends DamageReportCreateArgs>(args: SelectSubset<T, DamageReportCreateArgs<ExtArgs>>): Prisma__DamageReportClient<$Result.GetResult<Prisma.$DamageReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DamageReports.
     * @param {DamageReportCreateManyArgs} args - Arguments to create many DamageReports.
     * @example
     * // Create many DamageReports
     * const damageReport = await prisma.damageReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DamageReportCreateManyArgs>(args?: SelectSubset<T, DamageReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DamageReport.
     * @param {DamageReportDeleteArgs} args - Arguments to delete one DamageReport.
     * @example
     * // Delete one DamageReport
     * const DamageReport = await prisma.damageReport.delete({
     *   where: {
     *     // ... filter to delete one DamageReport
     *   }
     * })
     * 
     */
    delete<T extends DamageReportDeleteArgs>(args: SelectSubset<T, DamageReportDeleteArgs<ExtArgs>>): Prisma__DamageReportClient<$Result.GetResult<Prisma.$DamageReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DamageReport.
     * @param {DamageReportUpdateArgs} args - Arguments to update one DamageReport.
     * @example
     * // Update one DamageReport
     * const damageReport = await prisma.damageReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DamageReportUpdateArgs>(args: SelectSubset<T, DamageReportUpdateArgs<ExtArgs>>): Prisma__DamageReportClient<$Result.GetResult<Prisma.$DamageReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DamageReports.
     * @param {DamageReportDeleteManyArgs} args - Arguments to filter DamageReports to delete.
     * @example
     * // Delete a few DamageReports
     * const { count } = await prisma.damageReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DamageReportDeleteManyArgs>(args?: SelectSubset<T, DamageReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DamageReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DamageReports
     * const damageReport = await prisma.damageReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DamageReportUpdateManyArgs>(args: SelectSubset<T, DamageReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DamageReport.
     * @param {DamageReportUpsertArgs} args - Arguments to update or create a DamageReport.
     * @example
     * // Update or create a DamageReport
     * const damageReport = await prisma.damageReport.upsert({
     *   create: {
     *     // ... data to create a DamageReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DamageReport we want to update
     *   }
     * })
     */
    upsert<T extends DamageReportUpsertArgs>(args: SelectSubset<T, DamageReportUpsertArgs<ExtArgs>>): Prisma__DamageReportClient<$Result.GetResult<Prisma.$DamageReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DamageReports that matches the filter.
     * @param {DamageReportFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const damageReport = await prisma.damageReport.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DamageReportFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DamageReport.
     * @param {DamageReportAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const damageReport = await prisma.damageReport.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DamageReportAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DamageReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageReportCountArgs} args - Arguments to filter DamageReports to count.
     * @example
     * // Count the number of DamageReports
     * const count = await prisma.damageReport.count({
     *   where: {
     *     // ... the filter for the DamageReports we want to count
     *   }
     * })
    **/
    count<T extends DamageReportCountArgs>(
      args?: Subset<T, DamageReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DamageReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DamageReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DamageReportAggregateArgs>(args: Subset<T, DamageReportAggregateArgs>): Prisma.PrismaPromise<GetDamageReportAggregateType<T>>

    /**
     * Group by DamageReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DamageReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DamageReportGroupByArgs['orderBy'] }
        : { orderBy?: DamageReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DamageReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDamageReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DamageReport model
   */
  readonly fields: DamageReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DamageReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DamageReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock<T extends StockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockDefaultArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DamageReport model
   */
  interface DamageReportFieldRefs {
    readonly id: FieldRef<"DamageReport", 'String'>
    readonly stockId: FieldRef<"DamageReport", 'String'>
    readonly workerId: FieldRef<"DamageReport", 'String'>
    readonly reason: FieldRef<"DamageReport", 'String'>
    readonly quantity: FieldRef<"DamageReport", 'Int'>
    readonly location: FieldRef<"DamageReport", 'String'>
    readonly reportedAt: FieldRef<"DamageReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DamageReport findUnique
   */
  export type DamageReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageReport
     */
    select?: DamageReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageReport
     */
    omit?: DamageReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageReportInclude<ExtArgs> | null
    /**
     * Filter, which DamageReport to fetch.
     */
    where: DamageReportWhereUniqueInput
  }

  /**
   * DamageReport findUniqueOrThrow
   */
  export type DamageReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageReport
     */
    select?: DamageReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageReport
     */
    omit?: DamageReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageReportInclude<ExtArgs> | null
    /**
     * Filter, which DamageReport to fetch.
     */
    where: DamageReportWhereUniqueInput
  }

  /**
   * DamageReport findFirst
   */
  export type DamageReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageReport
     */
    select?: DamageReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageReport
     */
    omit?: DamageReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageReportInclude<ExtArgs> | null
    /**
     * Filter, which DamageReport to fetch.
     */
    where?: DamageReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageReports to fetch.
     */
    orderBy?: DamageReportOrderByWithRelationInput | DamageReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DamageReports.
     */
    cursor?: DamageReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DamageReports.
     */
    distinct?: DamageReportScalarFieldEnum | DamageReportScalarFieldEnum[]
  }

  /**
   * DamageReport findFirstOrThrow
   */
  export type DamageReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageReport
     */
    select?: DamageReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageReport
     */
    omit?: DamageReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageReportInclude<ExtArgs> | null
    /**
     * Filter, which DamageReport to fetch.
     */
    where?: DamageReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageReports to fetch.
     */
    orderBy?: DamageReportOrderByWithRelationInput | DamageReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DamageReports.
     */
    cursor?: DamageReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DamageReports.
     */
    distinct?: DamageReportScalarFieldEnum | DamageReportScalarFieldEnum[]
  }

  /**
   * DamageReport findMany
   */
  export type DamageReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageReport
     */
    select?: DamageReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageReport
     */
    omit?: DamageReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageReportInclude<ExtArgs> | null
    /**
     * Filter, which DamageReports to fetch.
     */
    where?: DamageReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageReports to fetch.
     */
    orderBy?: DamageReportOrderByWithRelationInput | DamageReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DamageReports.
     */
    cursor?: DamageReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageReports.
     */
    skip?: number
    distinct?: DamageReportScalarFieldEnum | DamageReportScalarFieldEnum[]
  }

  /**
   * DamageReport create
   */
  export type DamageReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageReport
     */
    select?: DamageReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageReport
     */
    omit?: DamageReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageReportInclude<ExtArgs> | null
    /**
     * The data needed to create a DamageReport.
     */
    data: XOR<DamageReportCreateInput, DamageReportUncheckedCreateInput>
  }

  /**
   * DamageReport createMany
   */
  export type DamageReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DamageReports.
     */
    data: DamageReportCreateManyInput | DamageReportCreateManyInput[]
  }

  /**
   * DamageReport update
   */
  export type DamageReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageReport
     */
    select?: DamageReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageReport
     */
    omit?: DamageReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageReportInclude<ExtArgs> | null
    /**
     * The data needed to update a DamageReport.
     */
    data: XOR<DamageReportUpdateInput, DamageReportUncheckedUpdateInput>
    /**
     * Choose, which DamageReport to update.
     */
    where: DamageReportWhereUniqueInput
  }

  /**
   * DamageReport updateMany
   */
  export type DamageReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DamageReports.
     */
    data: XOR<DamageReportUpdateManyMutationInput, DamageReportUncheckedUpdateManyInput>
    /**
     * Filter which DamageReports to update
     */
    where?: DamageReportWhereInput
    /**
     * Limit how many DamageReports to update.
     */
    limit?: number
  }

  /**
   * DamageReport upsert
   */
  export type DamageReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageReport
     */
    select?: DamageReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageReport
     */
    omit?: DamageReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageReportInclude<ExtArgs> | null
    /**
     * The filter to search for the DamageReport to update in case it exists.
     */
    where: DamageReportWhereUniqueInput
    /**
     * In case the DamageReport found by the `where` argument doesn't exist, create a new DamageReport with this data.
     */
    create: XOR<DamageReportCreateInput, DamageReportUncheckedCreateInput>
    /**
     * In case the DamageReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DamageReportUpdateInput, DamageReportUncheckedUpdateInput>
  }

  /**
   * DamageReport delete
   */
  export type DamageReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageReport
     */
    select?: DamageReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageReport
     */
    omit?: DamageReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageReportInclude<ExtArgs> | null
    /**
     * Filter which DamageReport to delete.
     */
    where: DamageReportWhereUniqueInput
  }

  /**
   * DamageReport deleteMany
   */
  export type DamageReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DamageReports to delete
     */
    where?: DamageReportWhereInput
    /**
     * Limit how many DamageReports to delete.
     */
    limit?: number
  }

  /**
   * DamageReport findRaw
   */
  export type DamageReportFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DamageReport aggregateRaw
   */
  export type DamageReportAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DamageReport without action
   */
  export type DamageReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageReport
     */
    select?: DamageReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageReport
     */
    omit?: DamageReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageReportInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    location: string | null
    address: string | null
    assignedTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    location: string | null
    address: string | null
    assignedTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    location: number
    address: number
    assignedTo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    location?: true
    address?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    location?: true
    address?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    location?: true
    address?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    email: string | null
    phone: string
    location: string
    address: string | null
    assignedTo: string
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    location?: boolean
    address?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visits?: boolean | Customer$visitsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>



  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    location?: boolean
    address?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "location" | "address" | "assignedTo" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | Customer$visitsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      visits: Prisma.$CustomerVisitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      phone: string
      location: string
      address: string | null
      assignedTo: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * @param {CustomerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const customer = await prisma.customer.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CustomerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Customer.
     * @param {CustomerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const customer = await prisma.customer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CustomerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visits<T extends Customer$visitsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerVisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly location: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly assignedTo: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer findRaw
   */
  export type CustomerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Customer aggregateRaw
   */
  export type CustomerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Customer.visits
   */
  export type Customer$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerVisit
     */
    select?: CustomerVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerVisit
     */
    omit?: CustomerVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerVisitInclude<ExtArgs> | null
    where?: CustomerVisitWhereInput
    orderBy?: CustomerVisitOrderByWithRelationInput | CustomerVisitOrderByWithRelationInput[]
    cursor?: CustomerVisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerVisitScalarFieldEnum | CustomerVisitScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model CustomerVisit
   */

  export type AggregateCustomerVisit = {
    _count: CustomerVisitCountAggregateOutputType | null
    _min: CustomerVisitMinAggregateOutputType | null
    _max: CustomerVisitMaxAggregateOutputType | null
  }

  export type CustomerVisitMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    executiveId: string | null
    visitDate: Date | null
    location: string | null
    peoplePresent: string | null
    productsDiscussed: string | null
    reasonForVisit: string | null
    customerConcerns: string | null
    investigationStatus: string | null
    rootCause: string | null
    correctiveAction: string | null
    recommendations: string | null
    feedback: string | null
    reportCompletedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerVisitMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    executiveId: string | null
    visitDate: Date | null
    location: string | null
    peoplePresent: string | null
    productsDiscussed: string | null
    reasonForVisit: string | null
    customerConcerns: string | null
    investigationStatus: string | null
    rootCause: string | null
    correctiveAction: string | null
    recommendations: string | null
    feedback: string | null
    reportCompletedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerVisitCountAggregateOutputType = {
    id: number
    customerId: number
    executiveId: number
    visitDate: number
    location: number
    peoplePresent: number
    productsDiscussed: number
    reasonForVisit: number
    customerConcerns: number
    investigationStatus: number
    rootCause: number
    correctiveAction: number
    recommendations: number
    feedback: number
    reportCompletedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerVisitMinAggregateInputType = {
    id?: true
    customerId?: true
    executiveId?: true
    visitDate?: true
    location?: true
    peoplePresent?: true
    productsDiscussed?: true
    reasonForVisit?: true
    customerConcerns?: true
    investigationStatus?: true
    rootCause?: true
    correctiveAction?: true
    recommendations?: true
    feedback?: true
    reportCompletedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerVisitMaxAggregateInputType = {
    id?: true
    customerId?: true
    executiveId?: true
    visitDate?: true
    location?: true
    peoplePresent?: true
    productsDiscussed?: true
    reasonForVisit?: true
    customerConcerns?: true
    investigationStatus?: true
    rootCause?: true
    correctiveAction?: true
    recommendations?: true
    feedback?: true
    reportCompletedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerVisitCountAggregateInputType = {
    id?: true
    customerId?: true
    executiveId?: true
    visitDate?: true
    location?: true
    peoplePresent?: true
    productsDiscussed?: true
    reasonForVisit?: true
    customerConcerns?: true
    investigationStatus?: true
    rootCause?: true
    correctiveAction?: true
    recommendations?: true
    feedback?: true
    reportCompletedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerVisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerVisit to aggregate.
     */
    where?: CustomerVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerVisits to fetch.
     */
    orderBy?: CustomerVisitOrderByWithRelationInput | CustomerVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerVisits
    **/
    _count?: true | CustomerVisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerVisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerVisitMaxAggregateInputType
  }

  export type GetCustomerVisitAggregateType<T extends CustomerVisitAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerVisit[P]>
      : GetScalarType<T[P], AggregateCustomerVisit[P]>
  }




  export type CustomerVisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerVisitWhereInput
    orderBy?: CustomerVisitOrderByWithAggregationInput | CustomerVisitOrderByWithAggregationInput[]
    by: CustomerVisitScalarFieldEnum[] | CustomerVisitScalarFieldEnum
    having?: CustomerVisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerVisitCountAggregateInputType | true
    _min?: CustomerVisitMinAggregateInputType
    _max?: CustomerVisitMaxAggregateInputType
  }

  export type CustomerVisitGroupByOutputType = {
    id: string
    customerId: string
    executiveId: string
    visitDate: Date
    location: string
    peoplePresent: string | null
    productsDiscussed: string | null
    reasonForVisit: string | null
    customerConcerns: string | null
    investigationStatus: string | null
    rootCause: string | null
    correctiveAction: string | null
    recommendations: string | null
    feedback: string | null
    reportCompletedBy: string
    createdAt: Date
    updatedAt: Date
    _count: CustomerVisitCountAggregateOutputType | null
    _min: CustomerVisitMinAggregateOutputType | null
    _max: CustomerVisitMaxAggregateOutputType | null
  }

  type GetCustomerVisitGroupByPayload<T extends CustomerVisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerVisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerVisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerVisitGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerVisitGroupByOutputType[P]>
        }
      >
    >


  export type CustomerVisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    executiveId?: boolean
    visitDate?: boolean
    location?: boolean
    peoplePresent?: boolean
    productsDiscussed?: boolean
    reasonForVisit?: boolean
    customerConcerns?: boolean
    investigationStatus?: boolean
    rootCause?: boolean
    correctiveAction?: boolean
    recommendations?: boolean
    feedback?: boolean
    reportCompletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerVisit"]>



  export type CustomerVisitSelectScalar = {
    id?: boolean
    customerId?: boolean
    executiveId?: boolean
    visitDate?: boolean
    location?: boolean
    peoplePresent?: boolean
    productsDiscussed?: boolean
    reasonForVisit?: boolean
    customerConcerns?: boolean
    investigationStatus?: boolean
    rootCause?: boolean
    correctiveAction?: boolean
    recommendations?: boolean
    feedback?: boolean
    reportCompletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerVisitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "executiveId" | "visitDate" | "location" | "peoplePresent" | "productsDiscussed" | "reasonForVisit" | "customerConcerns" | "investigationStatus" | "rootCause" | "correctiveAction" | "recommendations" | "feedback" | "reportCompletedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["customerVisit"]>
  export type CustomerVisitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerVisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerVisit"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      executiveId: string
      visitDate: Date
      location: string
      peoplePresent: string | null
      productsDiscussed: string | null
      reasonForVisit: string | null
      customerConcerns: string | null
      investigationStatus: string | null
      rootCause: string | null
      correctiveAction: string | null
      recommendations: string | null
      feedback: string | null
      reportCompletedBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerVisit"]>
    composites: {}
  }

  type CustomerVisitGetPayload<S extends boolean | null | undefined | CustomerVisitDefaultArgs> = $Result.GetResult<Prisma.$CustomerVisitPayload, S>

  type CustomerVisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerVisitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerVisitCountAggregateInputType | true
    }

  export interface CustomerVisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerVisit'], meta: { name: 'CustomerVisit' } }
    /**
     * Find zero or one CustomerVisit that matches the filter.
     * @param {CustomerVisitFindUniqueArgs} args - Arguments to find a CustomerVisit
     * @example
     * // Get one CustomerVisit
     * const customerVisit = await prisma.customerVisit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerVisitFindUniqueArgs>(args: SelectSubset<T, CustomerVisitFindUniqueArgs<ExtArgs>>): Prisma__CustomerVisitClient<$Result.GetResult<Prisma.$CustomerVisitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerVisit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerVisitFindUniqueOrThrowArgs} args - Arguments to find a CustomerVisit
     * @example
     * // Get one CustomerVisit
     * const customerVisit = await prisma.customerVisit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerVisitFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerVisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerVisitClient<$Result.GetResult<Prisma.$CustomerVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerVisit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisitFindFirstArgs} args - Arguments to find a CustomerVisit
     * @example
     * // Get one CustomerVisit
     * const customerVisit = await prisma.customerVisit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerVisitFindFirstArgs>(args?: SelectSubset<T, CustomerVisitFindFirstArgs<ExtArgs>>): Prisma__CustomerVisitClient<$Result.GetResult<Prisma.$CustomerVisitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerVisit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisitFindFirstOrThrowArgs} args - Arguments to find a CustomerVisit
     * @example
     * // Get one CustomerVisit
     * const customerVisit = await prisma.customerVisit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerVisitFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerVisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerVisitClient<$Result.GetResult<Prisma.$CustomerVisitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerVisits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerVisits
     * const customerVisits = await prisma.customerVisit.findMany()
     * 
     * // Get first 10 CustomerVisits
     * const customerVisits = await prisma.customerVisit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerVisitWithIdOnly = await prisma.customerVisit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerVisitFindManyArgs>(args?: SelectSubset<T, CustomerVisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerVisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerVisit.
     * @param {CustomerVisitCreateArgs} args - Arguments to create a CustomerVisit.
     * @example
     * // Create one CustomerVisit
     * const CustomerVisit = await prisma.customerVisit.create({
     *   data: {
     *     // ... data to create a CustomerVisit
     *   }
     * })
     * 
     */
    create<T extends CustomerVisitCreateArgs>(args: SelectSubset<T, CustomerVisitCreateArgs<ExtArgs>>): Prisma__CustomerVisitClient<$Result.GetResult<Prisma.$CustomerVisitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerVisits.
     * @param {CustomerVisitCreateManyArgs} args - Arguments to create many CustomerVisits.
     * @example
     * // Create many CustomerVisits
     * const customerVisit = await prisma.customerVisit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerVisitCreateManyArgs>(args?: SelectSubset<T, CustomerVisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerVisit.
     * @param {CustomerVisitDeleteArgs} args - Arguments to delete one CustomerVisit.
     * @example
     * // Delete one CustomerVisit
     * const CustomerVisit = await prisma.customerVisit.delete({
     *   where: {
     *     // ... filter to delete one CustomerVisit
     *   }
     * })
     * 
     */
    delete<T extends CustomerVisitDeleteArgs>(args: SelectSubset<T, CustomerVisitDeleteArgs<ExtArgs>>): Prisma__CustomerVisitClient<$Result.GetResult<Prisma.$CustomerVisitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerVisit.
     * @param {CustomerVisitUpdateArgs} args - Arguments to update one CustomerVisit.
     * @example
     * // Update one CustomerVisit
     * const customerVisit = await prisma.customerVisit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerVisitUpdateArgs>(args: SelectSubset<T, CustomerVisitUpdateArgs<ExtArgs>>): Prisma__CustomerVisitClient<$Result.GetResult<Prisma.$CustomerVisitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerVisits.
     * @param {CustomerVisitDeleteManyArgs} args - Arguments to filter CustomerVisits to delete.
     * @example
     * // Delete a few CustomerVisits
     * const { count } = await prisma.customerVisit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerVisitDeleteManyArgs>(args?: SelectSubset<T, CustomerVisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerVisits
     * const customerVisit = await prisma.customerVisit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerVisitUpdateManyArgs>(args: SelectSubset<T, CustomerVisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerVisit.
     * @param {CustomerVisitUpsertArgs} args - Arguments to update or create a CustomerVisit.
     * @example
     * // Update or create a CustomerVisit
     * const customerVisit = await prisma.customerVisit.upsert({
     *   create: {
     *     // ... data to create a CustomerVisit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerVisit we want to update
     *   }
     * })
     */
    upsert<T extends CustomerVisitUpsertArgs>(args: SelectSubset<T, CustomerVisitUpsertArgs<ExtArgs>>): Prisma__CustomerVisitClient<$Result.GetResult<Prisma.$CustomerVisitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerVisits that matches the filter.
     * @param {CustomerVisitFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const customerVisit = await prisma.customerVisit.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CustomerVisitFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CustomerVisit.
     * @param {CustomerVisitAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const customerVisit = await prisma.customerVisit.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CustomerVisitAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CustomerVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisitCountArgs} args - Arguments to filter CustomerVisits to count.
     * @example
     * // Count the number of CustomerVisits
     * const count = await prisma.customerVisit.count({
     *   where: {
     *     // ... the filter for the CustomerVisits we want to count
     *   }
     * })
    **/
    count<T extends CustomerVisitCountArgs>(
      args?: Subset<T, CustomerVisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerVisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerVisitAggregateArgs>(args: Subset<T, CustomerVisitAggregateArgs>): Prisma.PrismaPromise<GetCustomerVisitAggregateType<T>>

    /**
     * Group by CustomerVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerVisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerVisitGroupByArgs['orderBy'] }
        : { orderBy?: CustomerVisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerVisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerVisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerVisit model
   */
  readonly fields: CustomerVisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerVisit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerVisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerVisit model
   */
  interface CustomerVisitFieldRefs {
    readonly id: FieldRef<"CustomerVisit", 'String'>
    readonly customerId: FieldRef<"CustomerVisit", 'String'>
    readonly executiveId: FieldRef<"CustomerVisit", 'String'>
    readonly visitDate: FieldRef<"CustomerVisit", 'DateTime'>
    readonly location: FieldRef<"CustomerVisit", 'String'>
    readonly peoplePresent: FieldRef<"CustomerVisit", 'String'>
    readonly productsDiscussed: FieldRef<"CustomerVisit", 'String'>
    readonly reasonForVisit: FieldRef<"CustomerVisit", 'String'>
    readonly customerConcerns: FieldRef<"CustomerVisit", 'String'>
    readonly investigationStatus: FieldRef<"CustomerVisit", 'String'>
    readonly rootCause: FieldRef<"CustomerVisit", 'String'>
    readonly correctiveAction: FieldRef<"CustomerVisit", 'String'>
    readonly recommendations: FieldRef<"CustomerVisit", 'String'>
    readonly feedback: FieldRef<"CustomerVisit", 'String'>
    readonly reportCompletedBy: FieldRef<"CustomerVisit", 'String'>
    readonly createdAt: FieldRef<"CustomerVisit", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerVisit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerVisit findUnique
   */
  export type CustomerVisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerVisit
     */
    select?: CustomerVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerVisit
     */
    omit?: CustomerVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerVisitInclude<ExtArgs> | null
    /**
     * Filter, which CustomerVisit to fetch.
     */
    where: CustomerVisitWhereUniqueInput
  }

  /**
   * CustomerVisit findUniqueOrThrow
   */
  export type CustomerVisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerVisit
     */
    select?: CustomerVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerVisit
     */
    omit?: CustomerVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerVisitInclude<ExtArgs> | null
    /**
     * Filter, which CustomerVisit to fetch.
     */
    where: CustomerVisitWhereUniqueInput
  }

  /**
   * CustomerVisit findFirst
   */
  export type CustomerVisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerVisit
     */
    select?: CustomerVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerVisit
     */
    omit?: CustomerVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerVisitInclude<ExtArgs> | null
    /**
     * Filter, which CustomerVisit to fetch.
     */
    where?: CustomerVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerVisits to fetch.
     */
    orderBy?: CustomerVisitOrderByWithRelationInput | CustomerVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerVisits.
     */
    cursor?: CustomerVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerVisits.
     */
    distinct?: CustomerVisitScalarFieldEnum | CustomerVisitScalarFieldEnum[]
  }

  /**
   * CustomerVisit findFirstOrThrow
   */
  export type CustomerVisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerVisit
     */
    select?: CustomerVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerVisit
     */
    omit?: CustomerVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerVisitInclude<ExtArgs> | null
    /**
     * Filter, which CustomerVisit to fetch.
     */
    where?: CustomerVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerVisits to fetch.
     */
    orderBy?: CustomerVisitOrderByWithRelationInput | CustomerVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerVisits.
     */
    cursor?: CustomerVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerVisits.
     */
    distinct?: CustomerVisitScalarFieldEnum | CustomerVisitScalarFieldEnum[]
  }

  /**
   * CustomerVisit findMany
   */
  export type CustomerVisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerVisit
     */
    select?: CustomerVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerVisit
     */
    omit?: CustomerVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerVisitInclude<ExtArgs> | null
    /**
     * Filter, which CustomerVisits to fetch.
     */
    where?: CustomerVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerVisits to fetch.
     */
    orderBy?: CustomerVisitOrderByWithRelationInput | CustomerVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerVisits.
     */
    cursor?: CustomerVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerVisits.
     */
    skip?: number
    distinct?: CustomerVisitScalarFieldEnum | CustomerVisitScalarFieldEnum[]
  }

  /**
   * CustomerVisit create
   */
  export type CustomerVisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerVisit
     */
    select?: CustomerVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerVisit
     */
    omit?: CustomerVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerVisitInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerVisit.
     */
    data: XOR<CustomerVisitCreateInput, CustomerVisitUncheckedCreateInput>
  }

  /**
   * CustomerVisit createMany
   */
  export type CustomerVisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerVisits.
     */
    data: CustomerVisitCreateManyInput | CustomerVisitCreateManyInput[]
  }

  /**
   * CustomerVisit update
   */
  export type CustomerVisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerVisit
     */
    select?: CustomerVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerVisit
     */
    omit?: CustomerVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerVisitInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerVisit.
     */
    data: XOR<CustomerVisitUpdateInput, CustomerVisitUncheckedUpdateInput>
    /**
     * Choose, which CustomerVisit to update.
     */
    where: CustomerVisitWhereUniqueInput
  }

  /**
   * CustomerVisit updateMany
   */
  export type CustomerVisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerVisits.
     */
    data: XOR<CustomerVisitUpdateManyMutationInput, CustomerVisitUncheckedUpdateManyInput>
    /**
     * Filter which CustomerVisits to update
     */
    where?: CustomerVisitWhereInput
    /**
     * Limit how many CustomerVisits to update.
     */
    limit?: number
  }

  /**
   * CustomerVisit upsert
   */
  export type CustomerVisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerVisit
     */
    select?: CustomerVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerVisit
     */
    omit?: CustomerVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerVisitInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerVisit to update in case it exists.
     */
    where: CustomerVisitWhereUniqueInput
    /**
     * In case the CustomerVisit found by the `where` argument doesn't exist, create a new CustomerVisit with this data.
     */
    create: XOR<CustomerVisitCreateInput, CustomerVisitUncheckedCreateInput>
    /**
     * In case the CustomerVisit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerVisitUpdateInput, CustomerVisitUncheckedUpdateInput>
  }

  /**
   * CustomerVisit delete
   */
  export type CustomerVisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerVisit
     */
    select?: CustomerVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerVisit
     */
    omit?: CustomerVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerVisitInclude<ExtArgs> | null
    /**
     * Filter which CustomerVisit to delete.
     */
    where: CustomerVisitWhereUniqueInput
  }

  /**
   * CustomerVisit deleteMany
   */
  export type CustomerVisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerVisits to delete
     */
    where?: CustomerVisitWhereInput
    /**
     * Limit how many CustomerVisits to delete.
     */
    limit?: number
  }

  /**
   * CustomerVisit findRaw
   */
  export type CustomerVisitFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CustomerVisit aggregateRaw
   */
  export type CustomerVisitAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CustomerVisit without action
   */
  export type CustomerVisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerVisit
     */
    select?: CustomerVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerVisit
     */
    omit?: CustomerVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerVisitInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    isRead?: true
    createdAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    isRead?: true
    createdAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string | null
    content: string
    isRead: boolean
    createdAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | ChatMessage$receiverArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>



  export type ChatMessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "receiverId" | "content" | "isRead" | "createdAt", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | ChatMessage$receiverArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string | null
      content: string
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * @param {ChatMessageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const chatMessage = await prisma.chatMessage.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ChatMessageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ChatMessage.
     * @param {ChatMessageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const chatMessage = await prisma.chatMessage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ChatMessageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends ChatMessage$receiverArgs<ExtArgs> = {}>(args?: Subset<T, ChatMessage$receiverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly senderId: FieldRef<"ChatMessage", 'String'>
    readonly receiverId: FieldRef<"ChatMessage", 'String'>
    readonly content: FieldRef<"ChatMessage", 'String'>
    readonly isRead: FieldRef<"ChatMessage", 'Boolean'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage findRaw
   */
  export type ChatMessageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ChatMessage aggregateRaw
   */
  export type ChatMessageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ChatMessage.receiver
   */
  export type ChatMessage$receiverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model CapturedImage
   */

  export type AggregateCapturedImage = {
    _count: CapturedImageCountAggregateOutputType | null
    _avg: CapturedImageAvgAggregateOutputType | null
    _sum: CapturedImageSumAggregateOutputType | null
    _min: CapturedImageMinAggregateOutputType | null
    _max: CapturedImageMaxAggregateOutputType | null
  }

  export type CapturedImageAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type CapturedImageSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type CapturedImageMinAggregateOutputType = {
    id: string | null
    executiveId: string | null
    imageData: Uint8Array | null
    latitude: number | null
    longitude: number | null
    description: string | null
    createdAt: Date | null
  }

  export type CapturedImageMaxAggregateOutputType = {
    id: string | null
    executiveId: string | null
    imageData: Uint8Array | null
    latitude: number | null
    longitude: number | null
    description: string | null
    createdAt: Date | null
  }

  export type CapturedImageCountAggregateOutputType = {
    id: number
    executiveId: number
    imageData: number
    latitude: number
    longitude: number
    description: number
    createdAt: number
    _all: number
  }


  export type CapturedImageAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CapturedImageSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CapturedImageMinAggregateInputType = {
    id?: true
    executiveId?: true
    imageData?: true
    latitude?: true
    longitude?: true
    description?: true
    createdAt?: true
  }

  export type CapturedImageMaxAggregateInputType = {
    id?: true
    executiveId?: true
    imageData?: true
    latitude?: true
    longitude?: true
    description?: true
    createdAt?: true
  }

  export type CapturedImageCountAggregateInputType = {
    id?: true
    executiveId?: true
    imageData?: true
    latitude?: true
    longitude?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type CapturedImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapturedImage to aggregate.
     */
    where?: CapturedImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapturedImages to fetch.
     */
    orderBy?: CapturedImageOrderByWithRelationInput | CapturedImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CapturedImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapturedImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapturedImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CapturedImages
    **/
    _count?: true | CapturedImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CapturedImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CapturedImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CapturedImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CapturedImageMaxAggregateInputType
  }

  export type GetCapturedImageAggregateType<T extends CapturedImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCapturedImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapturedImage[P]>
      : GetScalarType<T[P], AggregateCapturedImage[P]>
  }




  export type CapturedImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapturedImageWhereInput
    orderBy?: CapturedImageOrderByWithAggregationInput | CapturedImageOrderByWithAggregationInput[]
    by: CapturedImageScalarFieldEnum[] | CapturedImageScalarFieldEnum
    having?: CapturedImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CapturedImageCountAggregateInputType | true
    _avg?: CapturedImageAvgAggregateInputType
    _sum?: CapturedImageSumAggregateInputType
    _min?: CapturedImageMinAggregateInputType
    _max?: CapturedImageMaxAggregateInputType
  }

  export type CapturedImageGroupByOutputType = {
    id: string
    executiveId: string
    imageData: Uint8Array
    latitude: number | null
    longitude: number | null
    description: string | null
    createdAt: Date
    _count: CapturedImageCountAggregateOutputType | null
    _avg: CapturedImageAvgAggregateOutputType | null
    _sum: CapturedImageSumAggregateOutputType | null
    _min: CapturedImageMinAggregateOutputType | null
    _max: CapturedImageMaxAggregateOutputType | null
  }

  type GetCapturedImageGroupByPayload<T extends CapturedImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CapturedImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CapturedImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CapturedImageGroupByOutputType[P]>
            : GetScalarType<T[P], CapturedImageGroupByOutputType[P]>
        }
      >
    >


  export type CapturedImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executiveId?: boolean
    imageData?: boolean
    latitude?: boolean
    longitude?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["capturedImage"]>



  export type CapturedImageSelectScalar = {
    id?: boolean
    executiveId?: boolean
    imageData?: boolean
    latitude?: boolean
    longitude?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type CapturedImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "executiveId" | "imageData" | "latitude" | "longitude" | "description" | "createdAt", ExtArgs["result"]["capturedImage"]>

  export type $CapturedImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CapturedImage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executiveId: string
      imageData: Uint8Array
      latitude: number | null
      longitude: number | null
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["capturedImage"]>
    composites: {}
  }

  type CapturedImageGetPayload<S extends boolean | null | undefined | CapturedImageDefaultArgs> = $Result.GetResult<Prisma.$CapturedImagePayload, S>

  type CapturedImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CapturedImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CapturedImageCountAggregateInputType | true
    }

  export interface CapturedImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CapturedImage'], meta: { name: 'CapturedImage' } }
    /**
     * Find zero or one CapturedImage that matches the filter.
     * @param {CapturedImageFindUniqueArgs} args - Arguments to find a CapturedImage
     * @example
     * // Get one CapturedImage
     * const capturedImage = await prisma.capturedImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CapturedImageFindUniqueArgs>(args: SelectSubset<T, CapturedImageFindUniqueArgs<ExtArgs>>): Prisma__CapturedImageClient<$Result.GetResult<Prisma.$CapturedImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CapturedImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CapturedImageFindUniqueOrThrowArgs} args - Arguments to find a CapturedImage
     * @example
     * // Get one CapturedImage
     * const capturedImage = await prisma.capturedImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CapturedImageFindUniqueOrThrowArgs>(args: SelectSubset<T, CapturedImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CapturedImageClient<$Result.GetResult<Prisma.$CapturedImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CapturedImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapturedImageFindFirstArgs} args - Arguments to find a CapturedImage
     * @example
     * // Get one CapturedImage
     * const capturedImage = await prisma.capturedImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CapturedImageFindFirstArgs>(args?: SelectSubset<T, CapturedImageFindFirstArgs<ExtArgs>>): Prisma__CapturedImageClient<$Result.GetResult<Prisma.$CapturedImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CapturedImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapturedImageFindFirstOrThrowArgs} args - Arguments to find a CapturedImage
     * @example
     * // Get one CapturedImage
     * const capturedImage = await prisma.capturedImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CapturedImageFindFirstOrThrowArgs>(args?: SelectSubset<T, CapturedImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CapturedImageClient<$Result.GetResult<Prisma.$CapturedImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CapturedImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapturedImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CapturedImages
     * const capturedImages = await prisma.capturedImage.findMany()
     * 
     * // Get first 10 CapturedImages
     * const capturedImages = await prisma.capturedImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capturedImageWithIdOnly = await prisma.capturedImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CapturedImageFindManyArgs>(args?: SelectSubset<T, CapturedImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapturedImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CapturedImage.
     * @param {CapturedImageCreateArgs} args - Arguments to create a CapturedImage.
     * @example
     * // Create one CapturedImage
     * const CapturedImage = await prisma.capturedImage.create({
     *   data: {
     *     // ... data to create a CapturedImage
     *   }
     * })
     * 
     */
    create<T extends CapturedImageCreateArgs>(args: SelectSubset<T, CapturedImageCreateArgs<ExtArgs>>): Prisma__CapturedImageClient<$Result.GetResult<Prisma.$CapturedImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CapturedImages.
     * @param {CapturedImageCreateManyArgs} args - Arguments to create many CapturedImages.
     * @example
     * // Create many CapturedImages
     * const capturedImage = await prisma.capturedImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CapturedImageCreateManyArgs>(args?: SelectSubset<T, CapturedImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CapturedImage.
     * @param {CapturedImageDeleteArgs} args - Arguments to delete one CapturedImage.
     * @example
     * // Delete one CapturedImage
     * const CapturedImage = await prisma.capturedImage.delete({
     *   where: {
     *     // ... filter to delete one CapturedImage
     *   }
     * })
     * 
     */
    delete<T extends CapturedImageDeleteArgs>(args: SelectSubset<T, CapturedImageDeleteArgs<ExtArgs>>): Prisma__CapturedImageClient<$Result.GetResult<Prisma.$CapturedImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CapturedImage.
     * @param {CapturedImageUpdateArgs} args - Arguments to update one CapturedImage.
     * @example
     * // Update one CapturedImage
     * const capturedImage = await prisma.capturedImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CapturedImageUpdateArgs>(args: SelectSubset<T, CapturedImageUpdateArgs<ExtArgs>>): Prisma__CapturedImageClient<$Result.GetResult<Prisma.$CapturedImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CapturedImages.
     * @param {CapturedImageDeleteManyArgs} args - Arguments to filter CapturedImages to delete.
     * @example
     * // Delete a few CapturedImages
     * const { count } = await prisma.capturedImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CapturedImageDeleteManyArgs>(args?: SelectSubset<T, CapturedImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CapturedImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapturedImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CapturedImages
     * const capturedImage = await prisma.capturedImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CapturedImageUpdateManyArgs>(args: SelectSubset<T, CapturedImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CapturedImage.
     * @param {CapturedImageUpsertArgs} args - Arguments to update or create a CapturedImage.
     * @example
     * // Update or create a CapturedImage
     * const capturedImage = await prisma.capturedImage.upsert({
     *   create: {
     *     // ... data to create a CapturedImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CapturedImage we want to update
     *   }
     * })
     */
    upsert<T extends CapturedImageUpsertArgs>(args: SelectSubset<T, CapturedImageUpsertArgs<ExtArgs>>): Prisma__CapturedImageClient<$Result.GetResult<Prisma.$CapturedImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CapturedImages that matches the filter.
     * @param {CapturedImageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const capturedImage = await prisma.capturedImage.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CapturedImageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CapturedImage.
     * @param {CapturedImageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const capturedImage = await prisma.capturedImage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CapturedImageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CapturedImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapturedImageCountArgs} args - Arguments to filter CapturedImages to count.
     * @example
     * // Count the number of CapturedImages
     * const count = await prisma.capturedImage.count({
     *   where: {
     *     // ... the filter for the CapturedImages we want to count
     *   }
     * })
    **/
    count<T extends CapturedImageCountArgs>(
      args?: Subset<T, CapturedImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CapturedImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CapturedImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapturedImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CapturedImageAggregateArgs>(args: Subset<T, CapturedImageAggregateArgs>): Prisma.PrismaPromise<GetCapturedImageAggregateType<T>>

    /**
     * Group by CapturedImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapturedImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CapturedImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CapturedImageGroupByArgs['orderBy'] }
        : { orderBy?: CapturedImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CapturedImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapturedImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CapturedImage model
   */
  readonly fields: CapturedImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CapturedImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CapturedImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CapturedImage model
   */
  interface CapturedImageFieldRefs {
    readonly id: FieldRef<"CapturedImage", 'String'>
    readonly executiveId: FieldRef<"CapturedImage", 'String'>
    readonly imageData: FieldRef<"CapturedImage", 'Bytes'>
    readonly latitude: FieldRef<"CapturedImage", 'Float'>
    readonly longitude: FieldRef<"CapturedImage", 'Float'>
    readonly description: FieldRef<"CapturedImage", 'String'>
    readonly createdAt: FieldRef<"CapturedImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CapturedImage findUnique
   */
  export type CapturedImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapturedImage
     */
    select?: CapturedImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapturedImage
     */
    omit?: CapturedImageOmit<ExtArgs> | null
    /**
     * Filter, which CapturedImage to fetch.
     */
    where: CapturedImageWhereUniqueInput
  }

  /**
   * CapturedImage findUniqueOrThrow
   */
  export type CapturedImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapturedImage
     */
    select?: CapturedImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapturedImage
     */
    omit?: CapturedImageOmit<ExtArgs> | null
    /**
     * Filter, which CapturedImage to fetch.
     */
    where: CapturedImageWhereUniqueInput
  }

  /**
   * CapturedImage findFirst
   */
  export type CapturedImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapturedImage
     */
    select?: CapturedImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapturedImage
     */
    omit?: CapturedImageOmit<ExtArgs> | null
    /**
     * Filter, which CapturedImage to fetch.
     */
    where?: CapturedImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapturedImages to fetch.
     */
    orderBy?: CapturedImageOrderByWithRelationInput | CapturedImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapturedImages.
     */
    cursor?: CapturedImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapturedImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapturedImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapturedImages.
     */
    distinct?: CapturedImageScalarFieldEnum | CapturedImageScalarFieldEnum[]
  }

  /**
   * CapturedImage findFirstOrThrow
   */
  export type CapturedImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapturedImage
     */
    select?: CapturedImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapturedImage
     */
    omit?: CapturedImageOmit<ExtArgs> | null
    /**
     * Filter, which CapturedImage to fetch.
     */
    where?: CapturedImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapturedImages to fetch.
     */
    orderBy?: CapturedImageOrderByWithRelationInput | CapturedImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapturedImages.
     */
    cursor?: CapturedImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapturedImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapturedImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapturedImages.
     */
    distinct?: CapturedImageScalarFieldEnum | CapturedImageScalarFieldEnum[]
  }

  /**
   * CapturedImage findMany
   */
  export type CapturedImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapturedImage
     */
    select?: CapturedImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapturedImage
     */
    omit?: CapturedImageOmit<ExtArgs> | null
    /**
     * Filter, which CapturedImages to fetch.
     */
    where?: CapturedImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapturedImages to fetch.
     */
    orderBy?: CapturedImageOrderByWithRelationInput | CapturedImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CapturedImages.
     */
    cursor?: CapturedImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapturedImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapturedImages.
     */
    skip?: number
    distinct?: CapturedImageScalarFieldEnum | CapturedImageScalarFieldEnum[]
  }

  /**
   * CapturedImage create
   */
  export type CapturedImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapturedImage
     */
    select?: CapturedImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapturedImage
     */
    omit?: CapturedImageOmit<ExtArgs> | null
    /**
     * The data needed to create a CapturedImage.
     */
    data: XOR<CapturedImageCreateInput, CapturedImageUncheckedCreateInput>
  }

  /**
   * CapturedImage createMany
   */
  export type CapturedImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CapturedImages.
     */
    data: CapturedImageCreateManyInput | CapturedImageCreateManyInput[]
  }

  /**
   * CapturedImage update
   */
  export type CapturedImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapturedImage
     */
    select?: CapturedImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapturedImage
     */
    omit?: CapturedImageOmit<ExtArgs> | null
    /**
     * The data needed to update a CapturedImage.
     */
    data: XOR<CapturedImageUpdateInput, CapturedImageUncheckedUpdateInput>
    /**
     * Choose, which CapturedImage to update.
     */
    where: CapturedImageWhereUniqueInput
  }

  /**
   * CapturedImage updateMany
   */
  export type CapturedImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CapturedImages.
     */
    data: XOR<CapturedImageUpdateManyMutationInput, CapturedImageUncheckedUpdateManyInput>
    /**
     * Filter which CapturedImages to update
     */
    where?: CapturedImageWhereInput
    /**
     * Limit how many CapturedImages to update.
     */
    limit?: number
  }

  /**
   * CapturedImage upsert
   */
  export type CapturedImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapturedImage
     */
    select?: CapturedImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapturedImage
     */
    omit?: CapturedImageOmit<ExtArgs> | null
    /**
     * The filter to search for the CapturedImage to update in case it exists.
     */
    where: CapturedImageWhereUniqueInput
    /**
     * In case the CapturedImage found by the `where` argument doesn't exist, create a new CapturedImage with this data.
     */
    create: XOR<CapturedImageCreateInput, CapturedImageUncheckedCreateInput>
    /**
     * In case the CapturedImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CapturedImageUpdateInput, CapturedImageUncheckedUpdateInput>
  }

  /**
   * CapturedImage delete
   */
  export type CapturedImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapturedImage
     */
    select?: CapturedImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapturedImage
     */
    omit?: CapturedImageOmit<ExtArgs> | null
    /**
     * Filter which CapturedImage to delete.
     */
    where: CapturedImageWhereUniqueInput
  }

  /**
   * CapturedImage deleteMany
   */
  export type CapturedImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapturedImages to delete
     */
    where?: CapturedImageWhereInput
    /**
     * Limit how many CapturedImages to delete.
     */
    limit?: number
  }

  /**
   * CapturedImage findRaw
   */
  export type CapturedImageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CapturedImage aggregateRaw
   */
  export type CapturedImageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CapturedImage without action
   */
  export type CapturedImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapturedImage
     */
    select?: CapturedImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapturedImage
     */
    omit?: CapturedImageOmit<ExtArgs> | null
  }


  /**
   * Model Signature
   */

  export type AggregateSignature = {
    _count: SignatureCountAggregateOutputType | null
    _min: SignatureMinAggregateOutputType | null
    _max: SignatureMaxAggregateOutputType | null
  }

  export type SignatureMinAggregateOutputType = {
    id: string | null
    executiveId: string | null
    signatureData: Uint8Array | null
    context: string | null
    createdAt: Date | null
  }

  export type SignatureMaxAggregateOutputType = {
    id: string | null
    executiveId: string | null
    signatureData: Uint8Array | null
    context: string | null
    createdAt: Date | null
  }

  export type SignatureCountAggregateOutputType = {
    id: number
    executiveId: number
    signatureData: number
    context: number
    createdAt: number
    _all: number
  }


  export type SignatureMinAggregateInputType = {
    id?: true
    executiveId?: true
    signatureData?: true
    context?: true
    createdAt?: true
  }

  export type SignatureMaxAggregateInputType = {
    id?: true
    executiveId?: true
    signatureData?: true
    context?: true
    createdAt?: true
  }

  export type SignatureCountAggregateInputType = {
    id?: true
    executiveId?: true
    signatureData?: true
    context?: true
    createdAt?: true
    _all?: true
  }

  export type SignatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signature to aggregate.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Signatures
    **/
    _count?: true | SignatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignatureMaxAggregateInputType
  }

  export type GetSignatureAggregateType<T extends SignatureAggregateArgs> = {
        [P in keyof T & keyof AggregateSignature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignature[P]>
      : GetScalarType<T[P], AggregateSignature[P]>
  }




  export type SignatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignatureWhereInput
    orderBy?: SignatureOrderByWithAggregationInput | SignatureOrderByWithAggregationInput[]
    by: SignatureScalarFieldEnum[] | SignatureScalarFieldEnum
    having?: SignatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignatureCountAggregateInputType | true
    _min?: SignatureMinAggregateInputType
    _max?: SignatureMaxAggregateInputType
  }

  export type SignatureGroupByOutputType = {
    id: string
    executiveId: string
    signatureData: Uint8Array
    context: string | null
    createdAt: Date
    _count: SignatureCountAggregateOutputType | null
    _min: SignatureMinAggregateOutputType | null
    _max: SignatureMaxAggregateOutputType | null
  }

  type GetSignatureGroupByPayload<T extends SignatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignatureGroupByOutputType[P]>
            : GetScalarType<T[P], SignatureGroupByOutputType[P]>
        }
      >
    >


  export type SignatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executiveId?: boolean
    signatureData?: boolean
    context?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["signature"]>



  export type SignatureSelectScalar = {
    id?: boolean
    executiveId?: boolean
    signatureData?: boolean
    context?: boolean
    createdAt?: boolean
  }

  export type SignatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "executiveId" | "signatureData" | "context" | "createdAt", ExtArgs["result"]["signature"]>

  export type $SignaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Signature"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executiveId: string
      signatureData: Uint8Array
      context: string | null
      createdAt: Date
    }, ExtArgs["result"]["signature"]>
    composites: {}
  }

  type SignatureGetPayload<S extends boolean | null | undefined | SignatureDefaultArgs> = $Result.GetResult<Prisma.$SignaturePayload, S>

  type SignatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SignatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SignatureCountAggregateInputType | true
    }

  export interface SignatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Signature'], meta: { name: 'Signature' } }
    /**
     * Find zero or one Signature that matches the filter.
     * @param {SignatureFindUniqueArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignatureFindUniqueArgs>(args: SelectSubset<T, SignatureFindUniqueArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Signature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SignatureFindUniqueOrThrowArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignatureFindUniqueOrThrowArgs>(args: SelectSubset<T, SignatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFindFirstArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignatureFindFirstArgs>(args?: SelectSubset<T, SignatureFindFirstArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFindFirstOrThrowArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignatureFindFirstOrThrowArgs>(args?: SelectSubset<T, SignatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Signatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Signatures
     * const signatures = await prisma.signature.findMany()
     * 
     * // Get first 10 Signatures
     * const signatures = await prisma.signature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signatureWithIdOnly = await prisma.signature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SignatureFindManyArgs>(args?: SelectSubset<T, SignatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Signature.
     * @param {SignatureCreateArgs} args - Arguments to create a Signature.
     * @example
     * // Create one Signature
     * const Signature = await prisma.signature.create({
     *   data: {
     *     // ... data to create a Signature
     *   }
     * })
     * 
     */
    create<T extends SignatureCreateArgs>(args: SelectSubset<T, SignatureCreateArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Signatures.
     * @param {SignatureCreateManyArgs} args - Arguments to create many Signatures.
     * @example
     * // Create many Signatures
     * const signature = await prisma.signature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignatureCreateManyArgs>(args?: SelectSubset<T, SignatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Signature.
     * @param {SignatureDeleteArgs} args - Arguments to delete one Signature.
     * @example
     * // Delete one Signature
     * const Signature = await prisma.signature.delete({
     *   where: {
     *     // ... filter to delete one Signature
     *   }
     * })
     * 
     */
    delete<T extends SignatureDeleteArgs>(args: SelectSubset<T, SignatureDeleteArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Signature.
     * @param {SignatureUpdateArgs} args - Arguments to update one Signature.
     * @example
     * // Update one Signature
     * const signature = await prisma.signature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignatureUpdateArgs>(args: SelectSubset<T, SignatureUpdateArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Signatures.
     * @param {SignatureDeleteManyArgs} args - Arguments to filter Signatures to delete.
     * @example
     * // Delete a few Signatures
     * const { count } = await prisma.signature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignatureDeleteManyArgs>(args?: SelectSubset<T, SignatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Signatures
     * const signature = await prisma.signature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignatureUpdateManyArgs>(args: SelectSubset<T, SignatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Signature.
     * @param {SignatureUpsertArgs} args - Arguments to update or create a Signature.
     * @example
     * // Update or create a Signature
     * const signature = await prisma.signature.upsert({
     *   create: {
     *     // ... data to create a Signature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Signature we want to update
     *   }
     * })
     */
    upsert<T extends SignatureUpsertArgs>(args: SelectSubset<T, SignatureUpsertArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Signatures that matches the filter.
     * @param {SignatureFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const signature = await prisma.signature.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SignatureFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Signature.
     * @param {SignatureAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const signature = await prisma.signature.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SignatureAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Signatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureCountArgs} args - Arguments to filter Signatures to count.
     * @example
     * // Count the number of Signatures
     * const count = await prisma.signature.count({
     *   where: {
     *     // ... the filter for the Signatures we want to count
     *   }
     * })
    **/
    count<T extends SignatureCountArgs>(
      args?: Subset<T, SignatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Signature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignatureAggregateArgs>(args: Subset<T, SignatureAggregateArgs>): Prisma.PrismaPromise<GetSignatureAggregateType<T>>

    /**
     * Group by Signature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignatureGroupByArgs['orderBy'] }
        : { orderBy?: SignatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Signature model
   */
  readonly fields: SignatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Signature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Signature model
   */
  interface SignatureFieldRefs {
    readonly id: FieldRef<"Signature", 'String'>
    readonly executiveId: FieldRef<"Signature", 'String'>
    readonly signatureData: FieldRef<"Signature", 'Bytes'>
    readonly context: FieldRef<"Signature", 'String'>
    readonly createdAt: FieldRef<"Signature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Signature findUnique
   */
  export type SignatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature findUniqueOrThrow
   */
  export type SignatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature findFirst
   */
  export type SignatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signatures.
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signatures.
     */
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Signature findFirstOrThrow
   */
  export type SignatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signatures.
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signatures.
     */
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Signature findMany
   */
  export type SignatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Filter, which Signatures to fetch.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Signatures.
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Signature create
   */
  export type SignatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * The data needed to create a Signature.
     */
    data: XOR<SignatureCreateInput, SignatureUncheckedCreateInput>
  }

  /**
   * Signature createMany
   */
  export type SignatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Signatures.
     */
    data: SignatureCreateManyInput | SignatureCreateManyInput[]
  }

  /**
   * Signature update
   */
  export type SignatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * The data needed to update a Signature.
     */
    data: XOR<SignatureUpdateInput, SignatureUncheckedUpdateInput>
    /**
     * Choose, which Signature to update.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature updateMany
   */
  export type SignatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Signatures.
     */
    data: XOR<SignatureUpdateManyMutationInput, SignatureUncheckedUpdateManyInput>
    /**
     * Filter which Signatures to update
     */
    where?: SignatureWhereInput
    /**
     * Limit how many Signatures to update.
     */
    limit?: number
  }

  /**
   * Signature upsert
   */
  export type SignatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * The filter to search for the Signature to update in case it exists.
     */
    where: SignatureWhereUniqueInput
    /**
     * In case the Signature found by the `where` argument doesn't exist, create a new Signature with this data.
     */
    create: XOR<SignatureCreateInput, SignatureUncheckedCreateInput>
    /**
     * In case the Signature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignatureUpdateInput, SignatureUncheckedUpdateInput>
  }

  /**
   * Signature delete
   */
  export type SignatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Filter which Signature to delete.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature deleteMany
   */
  export type SignatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signatures to delete
     */
    where?: SignatureWhereInput
    /**
     * Limit how many Signatures to delete.
     */
    limit?: number
  }

  /**
   * Signature findRaw
   */
  export type SignatureFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Signature aggregateRaw
   */
  export type SignatureAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Signature without action
   */
  export type SignatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
  }


  /**
   * Model OfflineData
   */

  export type AggregateOfflineData = {
    _count: OfflineDataCountAggregateOutputType | null
    _min: OfflineDataMinAggregateOutputType | null
    _max: OfflineDataMaxAggregateOutputType | null
  }

  export type OfflineDataMinAggregateOutputType = {
    id: string | null
    executiveId: string | null
    dataType: string | null
    data: string | null
    synced: boolean | null
    createdAt: Date | null
    syncedAt: Date | null
  }

  export type OfflineDataMaxAggregateOutputType = {
    id: string | null
    executiveId: string | null
    dataType: string | null
    data: string | null
    synced: boolean | null
    createdAt: Date | null
    syncedAt: Date | null
  }

  export type OfflineDataCountAggregateOutputType = {
    id: number
    executiveId: number
    dataType: number
    data: number
    synced: number
    createdAt: number
    syncedAt: number
    _all: number
  }


  export type OfflineDataMinAggregateInputType = {
    id?: true
    executiveId?: true
    dataType?: true
    data?: true
    synced?: true
    createdAt?: true
    syncedAt?: true
  }

  export type OfflineDataMaxAggregateInputType = {
    id?: true
    executiveId?: true
    dataType?: true
    data?: true
    synced?: true
    createdAt?: true
    syncedAt?: true
  }

  export type OfflineDataCountAggregateInputType = {
    id?: true
    executiveId?: true
    dataType?: true
    data?: true
    synced?: true
    createdAt?: true
    syncedAt?: true
    _all?: true
  }

  export type OfflineDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfflineData to aggregate.
     */
    where?: OfflineDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfflineData to fetch.
     */
    orderBy?: OfflineDataOrderByWithRelationInput | OfflineDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfflineDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfflineData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfflineData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfflineData
    **/
    _count?: true | OfflineDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfflineDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfflineDataMaxAggregateInputType
  }

  export type GetOfflineDataAggregateType<T extends OfflineDataAggregateArgs> = {
        [P in keyof T & keyof AggregateOfflineData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfflineData[P]>
      : GetScalarType<T[P], AggregateOfflineData[P]>
  }




  export type OfflineDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfflineDataWhereInput
    orderBy?: OfflineDataOrderByWithAggregationInput | OfflineDataOrderByWithAggregationInput[]
    by: OfflineDataScalarFieldEnum[] | OfflineDataScalarFieldEnum
    having?: OfflineDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfflineDataCountAggregateInputType | true
    _min?: OfflineDataMinAggregateInputType
    _max?: OfflineDataMaxAggregateInputType
  }

  export type OfflineDataGroupByOutputType = {
    id: string
    executiveId: string
    dataType: string
    data: string
    synced: boolean
    createdAt: Date
    syncedAt: Date | null
    _count: OfflineDataCountAggregateOutputType | null
    _min: OfflineDataMinAggregateOutputType | null
    _max: OfflineDataMaxAggregateOutputType | null
  }

  type GetOfflineDataGroupByPayload<T extends OfflineDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfflineDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfflineDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfflineDataGroupByOutputType[P]>
            : GetScalarType<T[P], OfflineDataGroupByOutputType[P]>
        }
      >
    >


  export type OfflineDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executiveId?: boolean
    dataType?: boolean
    data?: boolean
    synced?: boolean
    createdAt?: boolean
    syncedAt?: boolean
  }, ExtArgs["result"]["offlineData"]>



  export type OfflineDataSelectScalar = {
    id?: boolean
    executiveId?: boolean
    dataType?: boolean
    data?: boolean
    synced?: boolean
    createdAt?: boolean
    syncedAt?: boolean
  }

  export type OfflineDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "executiveId" | "dataType" | "data" | "synced" | "createdAt" | "syncedAt", ExtArgs["result"]["offlineData"]>

  export type $OfflineDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OfflineData"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executiveId: string
      dataType: string
      data: string
      synced: boolean
      createdAt: Date
      syncedAt: Date | null
    }, ExtArgs["result"]["offlineData"]>
    composites: {}
  }

  type OfflineDataGetPayload<S extends boolean | null | undefined | OfflineDataDefaultArgs> = $Result.GetResult<Prisma.$OfflineDataPayload, S>

  type OfflineDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfflineDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfflineDataCountAggregateInputType | true
    }

  export interface OfflineDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfflineData'], meta: { name: 'OfflineData' } }
    /**
     * Find zero or one OfflineData that matches the filter.
     * @param {OfflineDataFindUniqueArgs} args - Arguments to find a OfflineData
     * @example
     * // Get one OfflineData
     * const offlineData = await prisma.offlineData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfflineDataFindUniqueArgs>(args: SelectSubset<T, OfflineDataFindUniqueArgs<ExtArgs>>): Prisma__OfflineDataClient<$Result.GetResult<Prisma.$OfflineDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OfflineData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfflineDataFindUniqueOrThrowArgs} args - Arguments to find a OfflineData
     * @example
     * // Get one OfflineData
     * const offlineData = await prisma.offlineData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfflineDataFindUniqueOrThrowArgs>(args: SelectSubset<T, OfflineDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfflineDataClient<$Result.GetResult<Prisma.$OfflineDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfflineData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfflineDataFindFirstArgs} args - Arguments to find a OfflineData
     * @example
     * // Get one OfflineData
     * const offlineData = await prisma.offlineData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfflineDataFindFirstArgs>(args?: SelectSubset<T, OfflineDataFindFirstArgs<ExtArgs>>): Prisma__OfflineDataClient<$Result.GetResult<Prisma.$OfflineDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfflineData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfflineDataFindFirstOrThrowArgs} args - Arguments to find a OfflineData
     * @example
     * // Get one OfflineData
     * const offlineData = await prisma.offlineData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfflineDataFindFirstOrThrowArgs>(args?: SelectSubset<T, OfflineDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfflineDataClient<$Result.GetResult<Prisma.$OfflineDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OfflineData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfflineDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfflineData
     * const offlineData = await prisma.offlineData.findMany()
     * 
     * // Get first 10 OfflineData
     * const offlineData = await prisma.offlineData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offlineDataWithIdOnly = await prisma.offlineData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfflineDataFindManyArgs>(args?: SelectSubset<T, OfflineDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfflineDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OfflineData.
     * @param {OfflineDataCreateArgs} args - Arguments to create a OfflineData.
     * @example
     * // Create one OfflineData
     * const OfflineData = await prisma.offlineData.create({
     *   data: {
     *     // ... data to create a OfflineData
     *   }
     * })
     * 
     */
    create<T extends OfflineDataCreateArgs>(args: SelectSubset<T, OfflineDataCreateArgs<ExtArgs>>): Prisma__OfflineDataClient<$Result.GetResult<Prisma.$OfflineDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OfflineData.
     * @param {OfflineDataCreateManyArgs} args - Arguments to create many OfflineData.
     * @example
     * // Create many OfflineData
     * const offlineData = await prisma.offlineData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfflineDataCreateManyArgs>(args?: SelectSubset<T, OfflineDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfflineData.
     * @param {OfflineDataDeleteArgs} args - Arguments to delete one OfflineData.
     * @example
     * // Delete one OfflineData
     * const OfflineData = await prisma.offlineData.delete({
     *   where: {
     *     // ... filter to delete one OfflineData
     *   }
     * })
     * 
     */
    delete<T extends OfflineDataDeleteArgs>(args: SelectSubset<T, OfflineDataDeleteArgs<ExtArgs>>): Prisma__OfflineDataClient<$Result.GetResult<Prisma.$OfflineDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OfflineData.
     * @param {OfflineDataUpdateArgs} args - Arguments to update one OfflineData.
     * @example
     * // Update one OfflineData
     * const offlineData = await prisma.offlineData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfflineDataUpdateArgs>(args: SelectSubset<T, OfflineDataUpdateArgs<ExtArgs>>): Prisma__OfflineDataClient<$Result.GetResult<Prisma.$OfflineDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OfflineData.
     * @param {OfflineDataDeleteManyArgs} args - Arguments to filter OfflineData to delete.
     * @example
     * // Delete a few OfflineData
     * const { count } = await prisma.offlineData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfflineDataDeleteManyArgs>(args?: SelectSubset<T, OfflineDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfflineData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfflineDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfflineData
     * const offlineData = await prisma.offlineData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfflineDataUpdateManyArgs>(args: SelectSubset<T, OfflineDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfflineData.
     * @param {OfflineDataUpsertArgs} args - Arguments to update or create a OfflineData.
     * @example
     * // Update or create a OfflineData
     * const offlineData = await prisma.offlineData.upsert({
     *   create: {
     *     // ... data to create a OfflineData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfflineData we want to update
     *   }
     * })
     */
    upsert<T extends OfflineDataUpsertArgs>(args: SelectSubset<T, OfflineDataUpsertArgs<ExtArgs>>): Prisma__OfflineDataClient<$Result.GetResult<Prisma.$OfflineDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OfflineData that matches the filter.
     * @param {OfflineDataFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const offlineData = await prisma.offlineData.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OfflineDataFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OfflineData.
     * @param {OfflineDataAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const offlineData = await prisma.offlineData.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OfflineDataAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of OfflineData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfflineDataCountArgs} args - Arguments to filter OfflineData to count.
     * @example
     * // Count the number of OfflineData
     * const count = await prisma.offlineData.count({
     *   where: {
     *     // ... the filter for the OfflineData we want to count
     *   }
     * })
    **/
    count<T extends OfflineDataCountArgs>(
      args?: Subset<T, OfflineDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfflineDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfflineData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfflineDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfflineDataAggregateArgs>(args: Subset<T, OfflineDataAggregateArgs>): Prisma.PrismaPromise<GetOfflineDataAggregateType<T>>

    /**
     * Group by OfflineData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfflineDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfflineDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfflineDataGroupByArgs['orderBy'] }
        : { orderBy?: OfflineDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfflineDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfflineDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfflineData model
   */
  readonly fields: OfflineDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfflineData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfflineDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OfflineData model
   */
  interface OfflineDataFieldRefs {
    readonly id: FieldRef<"OfflineData", 'String'>
    readonly executiveId: FieldRef<"OfflineData", 'String'>
    readonly dataType: FieldRef<"OfflineData", 'String'>
    readonly data: FieldRef<"OfflineData", 'String'>
    readonly synced: FieldRef<"OfflineData", 'Boolean'>
    readonly createdAt: FieldRef<"OfflineData", 'DateTime'>
    readonly syncedAt: FieldRef<"OfflineData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OfflineData findUnique
   */
  export type OfflineDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfflineData
     */
    select?: OfflineDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfflineData
     */
    omit?: OfflineDataOmit<ExtArgs> | null
    /**
     * Filter, which OfflineData to fetch.
     */
    where: OfflineDataWhereUniqueInput
  }

  /**
   * OfflineData findUniqueOrThrow
   */
  export type OfflineDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfflineData
     */
    select?: OfflineDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfflineData
     */
    omit?: OfflineDataOmit<ExtArgs> | null
    /**
     * Filter, which OfflineData to fetch.
     */
    where: OfflineDataWhereUniqueInput
  }

  /**
   * OfflineData findFirst
   */
  export type OfflineDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfflineData
     */
    select?: OfflineDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfflineData
     */
    omit?: OfflineDataOmit<ExtArgs> | null
    /**
     * Filter, which OfflineData to fetch.
     */
    where?: OfflineDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfflineData to fetch.
     */
    orderBy?: OfflineDataOrderByWithRelationInput | OfflineDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfflineData.
     */
    cursor?: OfflineDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfflineData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfflineData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfflineData.
     */
    distinct?: OfflineDataScalarFieldEnum | OfflineDataScalarFieldEnum[]
  }

  /**
   * OfflineData findFirstOrThrow
   */
  export type OfflineDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfflineData
     */
    select?: OfflineDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfflineData
     */
    omit?: OfflineDataOmit<ExtArgs> | null
    /**
     * Filter, which OfflineData to fetch.
     */
    where?: OfflineDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfflineData to fetch.
     */
    orderBy?: OfflineDataOrderByWithRelationInput | OfflineDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfflineData.
     */
    cursor?: OfflineDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfflineData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfflineData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfflineData.
     */
    distinct?: OfflineDataScalarFieldEnum | OfflineDataScalarFieldEnum[]
  }

  /**
   * OfflineData findMany
   */
  export type OfflineDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfflineData
     */
    select?: OfflineDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfflineData
     */
    omit?: OfflineDataOmit<ExtArgs> | null
    /**
     * Filter, which OfflineData to fetch.
     */
    where?: OfflineDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfflineData to fetch.
     */
    orderBy?: OfflineDataOrderByWithRelationInput | OfflineDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfflineData.
     */
    cursor?: OfflineDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfflineData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfflineData.
     */
    skip?: number
    distinct?: OfflineDataScalarFieldEnum | OfflineDataScalarFieldEnum[]
  }

  /**
   * OfflineData create
   */
  export type OfflineDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfflineData
     */
    select?: OfflineDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfflineData
     */
    omit?: OfflineDataOmit<ExtArgs> | null
    /**
     * The data needed to create a OfflineData.
     */
    data: XOR<OfflineDataCreateInput, OfflineDataUncheckedCreateInput>
  }

  /**
   * OfflineData createMany
   */
  export type OfflineDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfflineData.
     */
    data: OfflineDataCreateManyInput | OfflineDataCreateManyInput[]
  }

  /**
   * OfflineData update
   */
  export type OfflineDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfflineData
     */
    select?: OfflineDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfflineData
     */
    omit?: OfflineDataOmit<ExtArgs> | null
    /**
     * The data needed to update a OfflineData.
     */
    data: XOR<OfflineDataUpdateInput, OfflineDataUncheckedUpdateInput>
    /**
     * Choose, which OfflineData to update.
     */
    where: OfflineDataWhereUniqueInput
  }

  /**
   * OfflineData updateMany
   */
  export type OfflineDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfflineData.
     */
    data: XOR<OfflineDataUpdateManyMutationInput, OfflineDataUncheckedUpdateManyInput>
    /**
     * Filter which OfflineData to update
     */
    where?: OfflineDataWhereInput
    /**
     * Limit how many OfflineData to update.
     */
    limit?: number
  }

  /**
   * OfflineData upsert
   */
  export type OfflineDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfflineData
     */
    select?: OfflineDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfflineData
     */
    omit?: OfflineDataOmit<ExtArgs> | null
    /**
     * The filter to search for the OfflineData to update in case it exists.
     */
    where: OfflineDataWhereUniqueInput
    /**
     * In case the OfflineData found by the `where` argument doesn't exist, create a new OfflineData with this data.
     */
    create: XOR<OfflineDataCreateInput, OfflineDataUncheckedCreateInput>
    /**
     * In case the OfflineData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfflineDataUpdateInput, OfflineDataUncheckedUpdateInput>
  }

  /**
   * OfflineData delete
   */
  export type OfflineDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfflineData
     */
    select?: OfflineDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfflineData
     */
    omit?: OfflineDataOmit<ExtArgs> | null
    /**
     * Filter which OfflineData to delete.
     */
    where: OfflineDataWhereUniqueInput
  }

  /**
   * OfflineData deleteMany
   */
  export type OfflineDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfflineData to delete
     */
    where?: OfflineDataWhereInput
    /**
     * Limit how many OfflineData to delete.
     */
    limit?: number
  }

  /**
   * OfflineData findRaw
   */
  export type OfflineDataFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OfflineData aggregateRaw
   */
  export type OfflineDataAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OfflineData without action
   */
  export type OfflineDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfflineData
     */
    select?: OfflineDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfflineData
     */
    omit?: OfflineDataOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password: 'password',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    logoUrl: 'logoUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const SalesManagerScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type SalesManagerScalarFieldEnum = (typeof SalesManagerScalarFieldEnum)[keyof typeof SalesManagerScalarFieldEnum]


  export const PlumberScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type PlumberScalarFieldEnum = (typeof PlumberScalarFieldEnum)[keyof typeof PlumberScalarFieldEnum]


  export const PlumberAccountProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fullName: 'fullName',
    contactNumber: 'contactNumber',
    upiId: 'upiId',
    upiQrUrl: 'upiQrUrl',
    email: 'email',
    bankName: 'bankName',
    accountNumber: 'accountNumber',
    accountHolderName: 'accountHolderName',
    ifscCode: 'ifscCode',
    branchName: 'branchName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlumberAccountProfileScalarFieldEnum = (typeof PlumberAccountProfileScalarFieldEnum)[keyof typeof PlumberAccountProfileScalarFieldEnum]


  export const AccountantScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type AccountantScalarFieldEnum = (typeof AccountantScalarFieldEnum)[keyof typeof AccountantScalarFieldEnum]


  export const DistributorScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type DistributorScalarFieldEnum = (typeof DistributorScalarFieldEnum)[keyof typeof DistributorScalarFieldEnum]


  export const FieldExecutiveScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type FieldExecutiveScalarFieldEnum = (typeof FieldExecutiveScalarFieldEnum)[keyof typeof FieldExecutiveScalarFieldEnum]


  export const WorkerScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type WorkerScalarFieldEnum = (typeof WorkerScalarFieldEnum)[keyof typeof WorkerScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    stockQuantity: 'stockQuantity',
    warrantyPeriodInMonths: 'warrantyPeriodInMonths',
    categoryId: 'categoryId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const StockScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    status: 'status',
    location: 'location'
  };

  export type StockScalarFieldEnum = (typeof StockScalarFieldEnum)[keyof typeof StockScalarFieldEnum]


  export const WarrantyCardScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    serialNumber: 'serialNumber',
    purchaseDate: 'purchaseDate',
    expiryDate: 'expiryDate',
    scanQR: 'scanQR',
    validViaWarranIQ: 'validViaWarranIQ'
  };

  export type WarrantyCardScalarFieldEnum = (typeof WarrantyCardScalarFieldEnum)[keyof typeof WarrantyCardScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    checkIn: 'checkIn',
    checkOut: 'checkOut'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const CustomerFollowUpScalarFieldEnum: {
    id: 'id',
    executiveId: 'executiveId',
    customerName: 'customerName',
    contactDetails: 'contactDetails',
    feedback: 'feedback',
    status: 'status',
    nextFollowUpDate: 'nextFollowUpDate'
  };

  export type CustomerFollowUpScalarFieldEnum = (typeof CustomerFollowUpScalarFieldEnum)[keyof typeof CustomerFollowUpScalarFieldEnum]


  export const PointTransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    points: 'points',
    creditAmount: 'creditAmount',
    date: 'date',
    reason: 'reason',
    type: 'type'
  };

  export type PointTransactionScalarFieldEnum = (typeof PointTransactionScalarFieldEnum)[keyof typeof PointTransactionScalarFieldEnum]


  export const IncentiveScalarFieldEnum: {
    id: 'id',
    description: 'description',
    points: 'points',
    assignedId: 'assignedId',
    assignedAt: 'assignedAt'
  };

  export type IncentiveScalarFieldEnum = (typeof IncentiveScalarFieldEnum)[keyof typeof IncentiveScalarFieldEnum]


  export const DVRScalarFieldEnum: {
    id: 'id',
    executiveId: 'executiveId',
    feedback: 'feedback',
    location: 'location',
    status: 'status',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt'
  };

  export type DVRScalarFieldEnum = (typeof DVRScalarFieldEnum)[keyof typeof DVRScalarFieldEnum]


  export const DeliveryReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    product: 'product',
    quantity: 'quantity',
    isForecasted: 'isForecasted',
    qrRequested: 'qrRequested',
    submittedAt: 'submittedAt'
  };

  export type DeliveryReportScalarFieldEnum = (typeof DeliveryReportScalarFieldEnum)[keyof typeof DeliveryReportScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    orderDate: 'orderDate',
    promoCodeId: 'promoCodeId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    unitPrice: 'unitPrice'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    invoiceDate: 'invoiceDate',
    totalAmount: 'totalAmount',
    pdfUrl: 'pdfUrl',
    status: 'status',
    sentAt: 'sentAt',
    paidAt: 'paidAt',
    dueDate: 'dueDate'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const LiveLocationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    latitude: 'latitude',
    longitude: 'longitude',
    timeStamp: 'timeStamp'
  };

  export type LiveLocationScalarFieldEnum = (typeof LiveLocationScalarFieldEnum)[keyof typeof LiveLocationScalarFieldEnum]


  export const ShiftAlertScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    createdAt: 'createdAt',
    acknowledged: 'acknowledged'
  };

  export type ShiftAlertScalarFieldEnum = (typeof ShiftAlertScalarFieldEnum)[keyof typeof ShiftAlertScalarFieldEnum]


  export const RegisterWarrantyScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    serialNumber: 'serialNumber',
    purchaseDate: 'purchaseDate',
    warrantyMonths: 'warrantyMonths',
    sellerId: 'sellerId',
    registeredAt: 'registeredAt',
    qrImage: 'qrImage'
  };

  export type RegisterWarrantyScalarFieldEnum = (typeof RegisterWarrantyScalarFieldEnum)[keyof typeof RegisterWarrantyScalarFieldEnum]


  export const PostDeliveryReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    product: 'product',
    quantity: 'quantity',
    submittedAt: 'submittedAt'
  };

  export type PostDeliveryReportScalarFieldEnum = (typeof PostDeliveryReportScalarFieldEnum)[keyof typeof PostDeliveryReportScalarFieldEnum]


  export const CommissionedWorkScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    latitude: 'latitude',
    longitude: 'longitude',
    qrCode: 'qrCode',
    qrImage: 'qrImage',
    appliedAt: 'appliedAt'
  };

  export type CommissionedWorkScalarFieldEnum = (typeof CommissionedWorkScalarFieldEnum)[keyof typeof CommissionedWorkScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const CartItemScalarFieldEnum: {
    id: 'id',
    cartId: 'cartId',
    productId: 'productId',
    quantity: 'quantity',
    addedAt: 'addedAt'
  };

  export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


  export const PromoCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    discountType: 'discountType',
    discountValue: 'discountValue',
    minOrderAmount: 'minOrderAmount',
    maxDiscount: 'maxDiscount',
    usageLimit: 'usageLimit',
    usedCount: 'usedCount',
    status: 'status',
    validFrom: 'validFrom',
    validUntil: 'validUntil',
    createdAt: 'createdAt'
  };

  export type PromoCodeScalarFieldEnum = (typeof PromoCodeScalarFieldEnum)[keyof typeof PromoCodeScalarFieldEnum]


  export const AuditScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    details: 'details',
    timestamp: 'timestamp'
  };

  export type AuditScalarFieldEnum = (typeof AuditScalarFieldEnum)[keyof typeof AuditScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    message: 'message',
    userId: 'userId',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const FinancialLogScalarFieldEnum: {
    id: 'id',
    type: 'type',
    amount: 'amount',
    description: 'description',
    category: 'category',
    reference: 'reference',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FinancialLogScalarFieldEnum = (typeof FinancialLogScalarFieldEnum)[keyof typeof FinancialLogScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    dueDate: 'dueDate',
    executiveId: 'executiveId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const DamageReportScalarFieldEnum: {
    id: 'id',
    stockId: 'stockId',
    workerId: 'workerId',
    reason: 'reason',
    quantity: 'quantity',
    location: 'location',
    reportedAt: 'reportedAt'
  };

  export type DamageReportScalarFieldEnum = (typeof DamageReportScalarFieldEnum)[keyof typeof DamageReportScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    location: 'location',
    address: 'address',
    assignedTo: 'assignedTo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerVisitScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    executiveId: 'executiveId',
    visitDate: 'visitDate',
    location: 'location',
    peoplePresent: 'peoplePresent',
    productsDiscussed: 'productsDiscussed',
    reasonForVisit: 'reasonForVisit',
    customerConcerns: 'customerConcerns',
    investigationStatus: 'investigationStatus',
    rootCause: 'rootCause',
    correctiveAction: 'correctiveAction',
    recommendations: 'recommendations',
    feedback: 'feedback',
    reportCompletedBy: 'reportCompletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerVisitScalarFieldEnum = (typeof CustomerVisitScalarFieldEnum)[keyof typeof CustomerVisitScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const CapturedImageScalarFieldEnum: {
    id: 'id',
    executiveId: 'executiveId',
    imageData: 'imageData',
    latitude: 'latitude',
    longitude: 'longitude',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type CapturedImageScalarFieldEnum = (typeof CapturedImageScalarFieldEnum)[keyof typeof CapturedImageScalarFieldEnum]


  export const SignatureScalarFieldEnum: {
    id: 'id',
    executiveId: 'executiveId',
    signatureData: 'signatureData',
    context: 'context',
    createdAt: 'createdAt'
  };

  export type SignatureScalarFieldEnum = (typeof SignatureScalarFieldEnum)[keyof typeof SignatureScalarFieldEnum]


  export const OfflineDataScalarFieldEnum: {
    id: 'id',
    executiveId: 'executiveId',
    dataType: 'dataType',
    data: 'data',
    synced: 'synced',
    createdAt: 'createdAt',
    syncedAt: 'syncedAt'
  };

  export type OfflineDataScalarFieldEnum = (typeof OfflineDataScalarFieldEnum)[keyof typeof OfflineDataScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'StockStatus'
   */
  export type EnumStockStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockStatus'>
    


  /**
   * Reference to a field of type 'StockStatus[]'
   */
  export type ListEnumStockStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockStatus[]'>
    


  /**
   * Reference to a field of type 'FollowUpStatus'
   */
  export type EnumFollowUpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowUpStatus'>
    


  /**
   * Reference to a field of type 'FollowUpStatus[]'
   */
  export type ListEnumFollowUpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowUpStatus[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'CartStatus'
   */
  export type EnumCartStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CartStatus'>
    


  /**
   * Reference to a field of type 'CartStatus[]'
   */
  export type ListEnumCartStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CartStatus[]'>
    


  /**
   * Reference to a field of type 'PromoCodeStatus'
   */
  export type EnumPromoCodeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromoCodeStatus'>
    


  /**
   * Reference to a field of type 'PromoCodeStatus[]'
   */
  export type ListEnumPromoCodeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromoCodeStatus[]'>
    


  /**
   * Reference to a field of type 'FinancialLogType'
   */
  export type EnumFinancialLogTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialLogType'>
    


  /**
   * Reference to a field of type 'FinancialLogType[]'
   */
  export type ListEnumFinancialLogTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialLogType[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    salesManager?: XOR<SalesManagerNullableScalarRelationFilter, SalesManagerWhereInput> | null
    plumber?: XOR<PlumberNullableScalarRelationFilter, PlumberWhereInput> | null
    accountant?: XOR<AccountantNullableScalarRelationFilter, AccountantWhereInput> | null
    distributor?: XOR<DistributorNullableScalarRelationFilter, DistributorWhereInput> | null
    fieldExecutive?: XOR<FieldExecutiveNullableScalarRelationFilter, FieldExecutiveWhereInput> | null
    worker?: XOR<WorkerNullableScalarRelationFilter, WorkerWhereInput> | null
    accountProfile?: XOR<PlumberAccountProfileNullableScalarRelationFilter, PlumberAccountProfileWhereInput> | null
    attendances?: AttendanceListRelationFilter
    transactions?: PointTransactionListRelationFilter
    incentives?: IncentiveListRelationFilter
    deliveryReports?: DeliveryReportListRelationFilter
    orders?: OrderListRelationFilter
    liveLocations?: LiveLocationListRelationFilter
    ShiftAlert?: ShiftAlertListRelationFilter
    registeredWarranties?: RegisterWarrantyListRelationFilter
    postDeliveryReports?: PostDeliveryReportListRelationFilter
    commissionedWorks?: CommissionedWorkListRelationFilter
    carts?: CartListRelationFilter
    audits?: AuditListRelationFilter
    notifications?: NotificationListRelationFilter
    financialLogs?: FinancialLogListRelationFilter
    sentMessages?: ChatMessageListRelationFilter
    receivedMessages?: ChatMessageListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    admin?: AdminOrderByWithRelationInput
    salesManager?: SalesManagerOrderByWithRelationInput
    plumber?: PlumberOrderByWithRelationInput
    accountant?: AccountantOrderByWithRelationInput
    distributor?: DistributorOrderByWithRelationInput
    fieldExecutive?: FieldExecutiveOrderByWithRelationInput
    worker?: WorkerOrderByWithRelationInput
    accountProfile?: PlumberAccountProfileOrderByWithRelationInput
    attendances?: AttendanceOrderByRelationAggregateInput
    transactions?: PointTransactionOrderByRelationAggregateInput
    incentives?: IncentiveOrderByRelationAggregateInput
    deliveryReports?: DeliveryReportOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    liveLocations?: LiveLocationOrderByRelationAggregateInput
    ShiftAlert?: ShiftAlertOrderByRelationAggregateInput
    registeredWarranties?: RegisterWarrantyOrderByRelationAggregateInput
    postDeliveryReports?: PostDeliveryReportOrderByRelationAggregateInput
    commissionedWorks?: CommissionedWorkOrderByRelationAggregateInput
    carts?: CartOrderByRelationAggregateInput
    audits?: AuditOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    financialLogs?: FinancialLogOrderByRelationAggregateInput
    sentMessages?: ChatMessageOrderByRelationAggregateInput
    receivedMessages?: ChatMessageOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    salesManager?: XOR<SalesManagerNullableScalarRelationFilter, SalesManagerWhereInput> | null
    plumber?: XOR<PlumberNullableScalarRelationFilter, PlumberWhereInput> | null
    accountant?: XOR<AccountantNullableScalarRelationFilter, AccountantWhereInput> | null
    distributor?: XOR<DistributorNullableScalarRelationFilter, DistributorWhereInput> | null
    fieldExecutive?: XOR<FieldExecutiveNullableScalarRelationFilter, FieldExecutiveWhereInput> | null
    worker?: XOR<WorkerNullableScalarRelationFilter, WorkerWhereInput> | null
    accountProfile?: XOR<PlumberAccountProfileNullableScalarRelationFilter, PlumberAccountProfileWhereInput> | null
    attendances?: AttendanceListRelationFilter
    transactions?: PointTransactionListRelationFilter
    incentives?: IncentiveListRelationFilter
    deliveryReports?: DeliveryReportListRelationFilter
    orders?: OrderListRelationFilter
    liveLocations?: LiveLocationListRelationFilter
    ShiftAlert?: ShiftAlertListRelationFilter
    registeredWarranties?: RegisterWarrantyListRelationFilter
    postDeliveryReports?: PostDeliveryReportListRelationFilter
    commissionedWorks?: CommissionedWorkListRelationFilter
    carts?: CartListRelationFilter
    audits?: AuditListRelationFilter
    notifications?: NotificationListRelationFilter
    financialLogs?: FinancialLogListRelationFilter
    sentMessages?: ChatMessageListRelationFilter
    receivedMessages?: ChatMessageListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    description?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    admins?: AdminListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admins?: AdminOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    description?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    admins?: AdminListRelationFilter
  }, "id" | "name">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    description?: StringNullableWithAggregatesFilter<"Company"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Company"> | string | null
    isActive?: BoolWithAggregatesFilter<"Company"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    companyId?: StringNullableFilter<"Admin"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    companyId?: StringNullableFilter<"Admin"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
    companyId?: StringNullableWithAggregatesFilter<"Admin"> | string | null
  }

  export type SalesManagerWhereInput = {
    AND?: SalesManagerWhereInput | SalesManagerWhereInput[]
    OR?: SalesManagerWhereInput[]
    NOT?: SalesManagerWhereInput | SalesManagerWhereInput[]
    id?: StringFilter<"SalesManager"> | string
    userId?: StringFilter<"SalesManager"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SalesManagerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SalesManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SalesManagerWhereInput | SalesManagerWhereInput[]
    OR?: SalesManagerWhereInput[]
    NOT?: SalesManagerWhereInput | SalesManagerWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type SalesManagerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: SalesManagerCountOrderByAggregateInput
    _max?: SalesManagerMaxOrderByAggregateInput
    _min?: SalesManagerMinOrderByAggregateInput
  }

  export type SalesManagerScalarWhereWithAggregatesInput = {
    AND?: SalesManagerScalarWhereWithAggregatesInput | SalesManagerScalarWhereWithAggregatesInput[]
    OR?: SalesManagerScalarWhereWithAggregatesInput[]
    NOT?: SalesManagerScalarWhereWithAggregatesInput | SalesManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesManager"> | string
    userId?: StringWithAggregatesFilter<"SalesManager"> | string
  }

  export type PlumberWhereInput = {
    AND?: PlumberWhereInput | PlumberWhereInput[]
    OR?: PlumberWhereInput[]
    NOT?: PlumberWhereInput | PlumberWhereInput[]
    id?: StringFilter<"Plumber"> | string
    userId?: StringFilter<"Plumber"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PlumberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PlumberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PlumberWhereInput | PlumberWhereInput[]
    OR?: PlumberWhereInput[]
    NOT?: PlumberWhereInput | PlumberWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type PlumberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: PlumberCountOrderByAggregateInput
    _max?: PlumberMaxOrderByAggregateInput
    _min?: PlumberMinOrderByAggregateInput
  }

  export type PlumberScalarWhereWithAggregatesInput = {
    AND?: PlumberScalarWhereWithAggregatesInput | PlumberScalarWhereWithAggregatesInput[]
    OR?: PlumberScalarWhereWithAggregatesInput[]
    NOT?: PlumberScalarWhereWithAggregatesInput | PlumberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plumber"> | string
    userId?: StringWithAggregatesFilter<"Plumber"> | string
  }

  export type PlumberAccountProfileWhereInput = {
    AND?: PlumberAccountProfileWhereInput | PlumberAccountProfileWhereInput[]
    OR?: PlumberAccountProfileWhereInput[]
    NOT?: PlumberAccountProfileWhereInput | PlumberAccountProfileWhereInput[]
    id?: StringFilter<"PlumberAccountProfile"> | string
    userId?: StringFilter<"PlumberAccountProfile"> | string
    fullName?: StringFilter<"PlumberAccountProfile"> | string
    contactNumber?: StringFilter<"PlumberAccountProfile"> | string
    upiId?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    upiQrUrl?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    email?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    bankName?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    accountNumber?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    accountHolderName?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    ifscCode?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    branchName?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    createdAt?: DateTimeFilter<"PlumberAccountProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PlumberAccountProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PlumberAccountProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    contactNumber?: SortOrder
    upiId?: SortOrder
    upiQrUrl?: SortOrder
    email?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountHolderName?: SortOrder
    ifscCode?: SortOrder
    branchName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PlumberAccountProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PlumberAccountProfileWhereInput | PlumberAccountProfileWhereInput[]
    OR?: PlumberAccountProfileWhereInput[]
    NOT?: PlumberAccountProfileWhereInput | PlumberAccountProfileWhereInput[]
    fullName?: StringFilter<"PlumberAccountProfile"> | string
    contactNumber?: StringFilter<"PlumberAccountProfile"> | string
    upiId?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    upiQrUrl?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    email?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    bankName?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    accountNumber?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    accountHolderName?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    ifscCode?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    branchName?: StringNullableFilter<"PlumberAccountProfile"> | string | null
    createdAt?: DateTimeFilter<"PlumberAccountProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PlumberAccountProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type PlumberAccountProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    contactNumber?: SortOrder
    upiId?: SortOrder
    upiQrUrl?: SortOrder
    email?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountHolderName?: SortOrder
    ifscCode?: SortOrder
    branchName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlumberAccountProfileCountOrderByAggregateInput
    _max?: PlumberAccountProfileMaxOrderByAggregateInput
    _min?: PlumberAccountProfileMinOrderByAggregateInput
  }

  export type PlumberAccountProfileScalarWhereWithAggregatesInput = {
    AND?: PlumberAccountProfileScalarWhereWithAggregatesInput | PlumberAccountProfileScalarWhereWithAggregatesInput[]
    OR?: PlumberAccountProfileScalarWhereWithAggregatesInput[]
    NOT?: PlumberAccountProfileScalarWhereWithAggregatesInput | PlumberAccountProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlumberAccountProfile"> | string
    userId?: StringWithAggregatesFilter<"PlumberAccountProfile"> | string
    fullName?: StringWithAggregatesFilter<"PlumberAccountProfile"> | string
    contactNumber?: StringWithAggregatesFilter<"PlumberAccountProfile"> | string
    upiId?: StringNullableWithAggregatesFilter<"PlumberAccountProfile"> | string | null
    upiQrUrl?: StringNullableWithAggregatesFilter<"PlumberAccountProfile"> | string | null
    email?: StringNullableWithAggregatesFilter<"PlumberAccountProfile"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"PlumberAccountProfile"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"PlumberAccountProfile"> | string | null
    accountHolderName?: StringNullableWithAggregatesFilter<"PlumberAccountProfile"> | string | null
    ifscCode?: StringNullableWithAggregatesFilter<"PlumberAccountProfile"> | string | null
    branchName?: StringNullableWithAggregatesFilter<"PlumberAccountProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlumberAccountProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlumberAccountProfile"> | Date | string
  }

  export type AccountantWhereInput = {
    AND?: AccountantWhereInput | AccountantWhereInput[]
    OR?: AccountantWhereInput[]
    NOT?: AccountantWhereInput | AccountantWhereInput[]
    id?: StringFilter<"Accountant"> | string
    userId?: StringFilter<"Accountant"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountantOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AccountantWhereInput | AccountantWhereInput[]
    OR?: AccountantWhereInput[]
    NOT?: AccountantWhereInput | AccountantWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AccountantOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: AccountantCountOrderByAggregateInput
    _max?: AccountantMaxOrderByAggregateInput
    _min?: AccountantMinOrderByAggregateInput
  }

  export type AccountantScalarWhereWithAggregatesInput = {
    AND?: AccountantScalarWhereWithAggregatesInput | AccountantScalarWhereWithAggregatesInput[]
    OR?: AccountantScalarWhereWithAggregatesInput[]
    NOT?: AccountantScalarWhereWithAggregatesInput | AccountantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Accountant"> | string
    userId?: StringWithAggregatesFilter<"Accountant"> | string
  }

  export type DistributorWhereInput = {
    AND?: DistributorWhereInput | DistributorWhereInput[]
    OR?: DistributorWhereInput[]
    NOT?: DistributorWhereInput | DistributorWhereInput[]
    id?: StringFilter<"Distributor"> | string
    userId?: StringFilter<"Distributor"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DistributorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DistributorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: DistributorWhereInput | DistributorWhereInput[]
    OR?: DistributorWhereInput[]
    NOT?: DistributorWhereInput | DistributorWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type DistributorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: DistributorCountOrderByAggregateInput
    _max?: DistributorMaxOrderByAggregateInput
    _min?: DistributorMinOrderByAggregateInput
  }

  export type DistributorScalarWhereWithAggregatesInput = {
    AND?: DistributorScalarWhereWithAggregatesInput | DistributorScalarWhereWithAggregatesInput[]
    OR?: DistributorScalarWhereWithAggregatesInput[]
    NOT?: DistributorScalarWhereWithAggregatesInput | DistributorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Distributor"> | string
    userId?: StringWithAggregatesFilter<"Distributor"> | string
  }

  export type FieldExecutiveWhereInput = {
    AND?: FieldExecutiveWhereInput | FieldExecutiveWhereInput[]
    OR?: FieldExecutiveWhereInput[]
    NOT?: FieldExecutiveWhereInput | FieldExecutiveWhereInput[]
    id?: StringFilter<"FieldExecutive"> | string
    userId?: StringFilter<"FieldExecutive"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    followUps?: CustomerFollowUpListRelationFilter
    dvrReports?: DVRListRelationFilter
  }

  export type FieldExecutiveOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    followUps?: CustomerFollowUpOrderByRelationAggregateInput
    dvrReports?: DVROrderByRelationAggregateInput
  }

  export type FieldExecutiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: FieldExecutiveWhereInput | FieldExecutiveWhereInput[]
    OR?: FieldExecutiveWhereInput[]
    NOT?: FieldExecutiveWhereInput | FieldExecutiveWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    followUps?: CustomerFollowUpListRelationFilter
    dvrReports?: DVRListRelationFilter
  }, "id" | "userId">

  export type FieldExecutiveOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: FieldExecutiveCountOrderByAggregateInput
    _max?: FieldExecutiveMaxOrderByAggregateInput
    _min?: FieldExecutiveMinOrderByAggregateInput
  }

  export type FieldExecutiveScalarWhereWithAggregatesInput = {
    AND?: FieldExecutiveScalarWhereWithAggregatesInput | FieldExecutiveScalarWhereWithAggregatesInput[]
    OR?: FieldExecutiveScalarWhereWithAggregatesInput[]
    NOT?: FieldExecutiveScalarWhereWithAggregatesInput | FieldExecutiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FieldExecutive"> | string
    userId?: StringWithAggregatesFilter<"FieldExecutive"> | string
  }

  export type WorkerWhereInput = {
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    id?: StringFilter<"Worker"> | string
    userId?: StringFilter<"Worker"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WorkerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WorkerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type WorkerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: WorkerCountOrderByAggregateInput
    _max?: WorkerMaxOrderByAggregateInput
    _min?: WorkerMinOrderByAggregateInput
  }

  export type WorkerScalarWhereWithAggregatesInput = {
    AND?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    OR?: WorkerScalarWhereWithAggregatesInput[]
    NOT?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Worker"> | string
    userId?: StringWithAggregatesFilter<"Worker"> | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    stockQuantity?: IntFilter<"Product"> | number
    warrantyPeriodInMonths?: IntFilter<"Product"> | number
    categoryId?: StringNullableFilter<"Product"> | string | null
    stocks?: StockListRelationFilter
    warrantyCards?: WarrantyCardListRelationFilter
    orderItems?: OrderItemListRelationFilter
    registeredWarranties?: RegisterWarrantyListRelationFilter
    cartItems?: CartItemListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    stockQuantity?: SortOrder
    warrantyPeriodInMonths?: SortOrder
    categoryId?: SortOrder
    stocks?: StockOrderByRelationAggregateInput
    warrantyCards?: WarrantyCardOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    registeredWarranties?: RegisterWarrantyOrderByRelationAggregateInput
    cartItems?: CartItemOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    stockQuantity?: IntFilter<"Product"> | number
    warrantyPeriodInMonths?: IntFilter<"Product"> | number
    categoryId?: StringNullableFilter<"Product"> | string | null
    stocks?: StockListRelationFilter
    warrantyCards?: WarrantyCardListRelationFilter
    orderItems?: OrderItemListRelationFilter
    registeredWarranties?: RegisterWarrantyListRelationFilter
    cartItems?: CartItemListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    stockQuantity?: SortOrder
    warrantyPeriodInMonths?: SortOrder
    categoryId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    price?: FloatWithAggregatesFilter<"Product"> | number
    stockQuantity?: IntWithAggregatesFilter<"Product"> | number
    warrantyPeriodInMonths?: IntWithAggregatesFilter<"Product"> | number
    categoryId?: StringNullableWithAggregatesFilter<"Product"> | string | null
  }

  export type StockWhereInput = {
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    id?: StringFilter<"Stock"> | string
    productId?: StringFilter<"Stock"> | string
    status?: EnumStockStatusFilter<"Stock"> | $Enums.StockStatus
    location?: StringFilter<"Stock"> | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    damageReports?: DamageReportListRelationFilter
  }

  export type StockOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    status?: SortOrder
    location?: SortOrder
    product?: ProductOrderByWithRelationInput
    damageReports?: DamageReportOrderByRelationAggregateInput
  }

  export type StockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    productId?: StringFilter<"Stock"> | string
    status?: EnumStockStatusFilter<"Stock"> | $Enums.StockStatus
    location?: StringFilter<"Stock"> | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    damageReports?: DamageReportListRelationFilter
  }, "id">

  export type StockOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    status?: SortOrder
    location?: SortOrder
    _count?: StockCountOrderByAggregateInput
    _max?: StockMaxOrderByAggregateInput
    _min?: StockMinOrderByAggregateInput
  }

  export type StockScalarWhereWithAggregatesInput = {
    AND?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    OR?: StockScalarWhereWithAggregatesInput[]
    NOT?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stock"> | string
    productId?: StringWithAggregatesFilter<"Stock"> | string
    status?: EnumStockStatusWithAggregatesFilter<"Stock"> | $Enums.StockStatus
    location?: StringWithAggregatesFilter<"Stock"> | string
  }

  export type WarrantyCardWhereInput = {
    AND?: WarrantyCardWhereInput | WarrantyCardWhereInput[]
    OR?: WarrantyCardWhereInput[]
    NOT?: WarrantyCardWhereInput | WarrantyCardWhereInput[]
    id?: StringFilter<"WarrantyCard"> | string
    productId?: StringFilter<"WarrantyCard"> | string
    serialNumber?: StringFilter<"WarrantyCard"> | string
    purchaseDate?: DateTimeFilter<"WarrantyCard"> | Date | string
    expiryDate?: DateTimeFilter<"WarrantyCard"> | Date | string
    scanQR?: StringFilter<"WarrantyCard"> | string
    validViaWarranIQ?: StringFilter<"WarrantyCard"> | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type WarrantyCardOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    scanQR?: SortOrder
    validViaWarranIQ?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type WarrantyCardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WarrantyCardWhereInput | WarrantyCardWhereInput[]
    OR?: WarrantyCardWhereInput[]
    NOT?: WarrantyCardWhereInput | WarrantyCardWhereInput[]
    productId?: StringFilter<"WarrantyCard"> | string
    serialNumber?: StringFilter<"WarrantyCard"> | string
    purchaseDate?: DateTimeFilter<"WarrantyCard"> | Date | string
    expiryDate?: DateTimeFilter<"WarrantyCard"> | Date | string
    scanQR?: StringFilter<"WarrantyCard"> | string
    validViaWarranIQ?: StringFilter<"WarrantyCard"> | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type WarrantyCardOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    scanQR?: SortOrder
    validViaWarranIQ?: SortOrder
    _count?: WarrantyCardCountOrderByAggregateInput
    _max?: WarrantyCardMaxOrderByAggregateInput
    _min?: WarrantyCardMinOrderByAggregateInput
  }

  export type WarrantyCardScalarWhereWithAggregatesInput = {
    AND?: WarrantyCardScalarWhereWithAggregatesInput | WarrantyCardScalarWhereWithAggregatesInput[]
    OR?: WarrantyCardScalarWhereWithAggregatesInput[]
    NOT?: WarrantyCardScalarWhereWithAggregatesInput | WarrantyCardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarrantyCard"> | string
    productId?: StringWithAggregatesFilter<"WarrantyCard"> | string
    serialNumber?: StringWithAggregatesFilter<"WarrantyCard"> | string
    purchaseDate?: DateTimeWithAggregatesFilter<"WarrantyCard"> | Date | string
    expiryDate?: DateTimeWithAggregatesFilter<"WarrantyCard"> | Date | string
    scanQR?: StringWithAggregatesFilter<"WarrantyCard"> | string
    validViaWarranIQ?: StringWithAggregatesFilter<"WarrantyCard"> | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    userId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    checkIn?: DateTimeFilter<"Attendance"> | Date | string
    checkOut?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    userId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    checkIn?: DateTimeFilter<"Attendance"> | Date | string
    checkOut?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    userId?: StringWithAggregatesFilter<"Attendance"> | string
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    checkIn?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    checkOut?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
  }

  export type CustomerFollowUpWhereInput = {
    AND?: CustomerFollowUpWhereInput | CustomerFollowUpWhereInput[]
    OR?: CustomerFollowUpWhereInput[]
    NOT?: CustomerFollowUpWhereInput | CustomerFollowUpWhereInput[]
    id?: StringFilter<"CustomerFollowUp"> | string
    executiveId?: StringFilter<"CustomerFollowUp"> | string
    customerName?: StringFilter<"CustomerFollowUp"> | string
    contactDetails?: StringFilter<"CustomerFollowUp"> | string
    feedback?: StringFilter<"CustomerFollowUp"> | string
    status?: EnumFollowUpStatusFilter<"CustomerFollowUp"> | $Enums.FollowUpStatus
    nextFollowUpDate?: DateTimeFilter<"CustomerFollowUp"> | Date | string
    executive?: XOR<FieldExecutiveScalarRelationFilter, FieldExecutiveWhereInput>
  }

  export type CustomerFollowUpOrderByWithRelationInput = {
    id?: SortOrder
    executiveId?: SortOrder
    customerName?: SortOrder
    contactDetails?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    nextFollowUpDate?: SortOrder
    executive?: FieldExecutiveOrderByWithRelationInput
  }

  export type CustomerFollowUpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerFollowUpWhereInput | CustomerFollowUpWhereInput[]
    OR?: CustomerFollowUpWhereInput[]
    NOT?: CustomerFollowUpWhereInput | CustomerFollowUpWhereInput[]
    executiveId?: StringFilter<"CustomerFollowUp"> | string
    customerName?: StringFilter<"CustomerFollowUp"> | string
    contactDetails?: StringFilter<"CustomerFollowUp"> | string
    feedback?: StringFilter<"CustomerFollowUp"> | string
    status?: EnumFollowUpStatusFilter<"CustomerFollowUp"> | $Enums.FollowUpStatus
    nextFollowUpDate?: DateTimeFilter<"CustomerFollowUp"> | Date | string
    executive?: XOR<FieldExecutiveScalarRelationFilter, FieldExecutiveWhereInput>
  }, "id">

  export type CustomerFollowUpOrderByWithAggregationInput = {
    id?: SortOrder
    executiveId?: SortOrder
    customerName?: SortOrder
    contactDetails?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    nextFollowUpDate?: SortOrder
    _count?: CustomerFollowUpCountOrderByAggregateInput
    _max?: CustomerFollowUpMaxOrderByAggregateInput
    _min?: CustomerFollowUpMinOrderByAggregateInput
  }

  export type CustomerFollowUpScalarWhereWithAggregatesInput = {
    AND?: CustomerFollowUpScalarWhereWithAggregatesInput | CustomerFollowUpScalarWhereWithAggregatesInput[]
    OR?: CustomerFollowUpScalarWhereWithAggregatesInput[]
    NOT?: CustomerFollowUpScalarWhereWithAggregatesInput | CustomerFollowUpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerFollowUp"> | string
    executiveId?: StringWithAggregatesFilter<"CustomerFollowUp"> | string
    customerName?: StringWithAggregatesFilter<"CustomerFollowUp"> | string
    contactDetails?: StringWithAggregatesFilter<"CustomerFollowUp"> | string
    feedback?: StringWithAggregatesFilter<"CustomerFollowUp"> | string
    status?: EnumFollowUpStatusWithAggregatesFilter<"CustomerFollowUp"> | $Enums.FollowUpStatus
    nextFollowUpDate?: DateTimeWithAggregatesFilter<"CustomerFollowUp"> | Date | string
  }

  export type PointTransactionWhereInput = {
    AND?: PointTransactionWhereInput | PointTransactionWhereInput[]
    OR?: PointTransactionWhereInput[]
    NOT?: PointTransactionWhereInput | PointTransactionWhereInput[]
    id?: StringFilter<"PointTransaction"> | string
    userId?: StringFilter<"PointTransaction"> | string
    points?: IntFilter<"PointTransaction"> | number
    creditAmount?: FloatFilter<"PointTransaction"> | number
    date?: DateTimeFilter<"PointTransaction"> | Date | string
    reason?: StringFilter<"PointTransaction"> | string
    type?: EnumTransactionTypeFilter<"PointTransaction"> | $Enums.TransactionType
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PointTransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    creditAmount?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PointTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PointTransactionWhereInput | PointTransactionWhereInput[]
    OR?: PointTransactionWhereInput[]
    NOT?: PointTransactionWhereInput | PointTransactionWhereInput[]
    userId?: StringFilter<"PointTransaction"> | string
    points?: IntFilter<"PointTransaction"> | number
    creditAmount?: FloatFilter<"PointTransaction"> | number
    date?: DateTimeFilter<"PointTransaction"> | Date | string
    reason?: StringFilter<"PointTransaction"> | string
    type?: EnumTransactionTypeFilter<"PointTransaction"> | $Enums.TransactionType
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PointTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    creditAmount?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    _count?: PointTransactionCountOrderByAggregateInput
    _avg?: PointTransactionAvgOrderByAggregateInput
    _max?: PointTransactionMaxOrderByAggregateInput
    _min?: PointTransactionMinOrderByAggregateInput
    _sum?: PointTransactionSumOrderByAggregateInput
  }

  export type PointTransactionScalarWhereWithAggregatesInput = {
    AND?: PointTransactionScalarWhereWithAggregatesInput | PointTransactionScalarWhereWithAggregatesInput[]
    OR?: PointTransactionScalarWhereWithAggregatesInput[]
    NOT?: PointTransactionScalarWhereWithAggregatesInput | PointTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PointTransaction"> | string
    userId?: StringWithAggregatesFilter<"PointTransaction"> | string
    points?: IntWithAggregatesFilter<"PointTransaction"> | number
    creditAmount?: FloatWithAggregatesFilter<"PointTransaction"> | number
    date?: DateTimeWithAggregatesFilter<"PointTransaction"> | Date | string
    reason?: StringWithAggregatesFilter<"PointTransaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"PointTransaction"> | $Enums.TransactionType
  }

  export type IncentiveWhereInput = {
    AND?: IncentiveWhereInput | IncentiveWhereInput[]
    OR?: IncentiveWhereInput[]
    NOT?: IncentiveWhereInput | IncentiveWhereInput[]
    id?: StringFilter<"Incentive"> | string
    description?: StringFilter<"Incentive"> | string
    points?: IntFilter<"Incentive"> | number
    assignedId?: StringFilter<"Incentive"> | string
    assignedAt?: DateTimeFilter<"Incentive"> | Date | string
    assignedTo?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type IncentiveOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    points?: SortOrder
    assignedId?: SortOrder
    assignedAt?: SortOrder
    assignedTo?: UserOrderByWithRelationInput
  }

  export type IncentiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncentiveWhereInput | IncentiveWhereInput[]
    OR?: IncentiveWhereInput[]
    NOT?: IncentiveWhereInput | IncentiveWhereInput[]
    description?: StringFilter<"Incentive"> | string
    points?: IntFilter<"Incentive"> | number
    assignedId?: StringFilter<"Incentive"> | string
    assignedAt?: DateTimeFilter<"Incentive"> | Date | string
    assignedTo?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type IncentiveOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    points?: SortOrder
    assignedId?: SortOrder
    assignedAt?: SortOrder
    _count?: IncentiveCountOrderByAggregateInput
    _avg?: IncentiveAvgOrderByAggregateInput
    _max?: IncentiveMaxOrderByAggregateInput
    _min?: IncentiveMinOrderByAggregateInput
    _sum?: IncentiveSumOrderByAggregateInput
  }

  export type IncentiveScalarWhereWithAggregatesInput = {
    AND?: IncentiveScalarWhereWithAggregatesInput | IncentiveScalarWhereWithAggregatesInput[]
    OR?: IncentiveScalarWhereWithAggregatesInput[]
    NOT?: IncentiveScalarWhereWithAggregatesInput | IncentiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Incentive"> | string
    description?: StringWithAggregatesFilter<"Incentive"> | string
    points?: IntWithAggregatesFilter<"Incentive"> | number
    assignedId?: StringWithAggregatesFilter<"Incentive"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"Incentive"> | Date | string
  }

  export type DVRWhereInput = {
    AND?: DVRWhereInput | DVRWhereInput[]
    OR?: DVRWhereInput[]
    NOT?: DVRWhereInput | DVRWhereInput[]
    id?: StringFilter<"DVR"> | string
    executiveId?: StringFilter<"DVR"> | string
    feedback?: StringFilter<"DVR"> | string
    location?: StringFilter<"DVR"> | string
    status?: StringFilter<"DVR"> | string
    approvedBy?: StringNullableFilter<"DVR"> | string | null
    approvedAt?: DateTimeNullableFilter<"DVR"> | Date | string | null
    executive?: XOR<FieldExecutiveScalarRelationFilter, FieldExecutiveWhereInput>
  }

  export type DVROrderByWithRelationInput = {
    id?: SortOrder
    executiveId?: SortOrder
    feedback?: SortOrder
    location?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    executive?: FieldExecutiveOrderByWithRelationInput
  }

  export type DVRWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DVRWhereInput | DVRWhereInput[]
    OR?: DVRWhereInput[]
    NOT?: DVRWhereInput | DVRWhereInput[]
    executiveId?: StringFilter<"DVR"> | string
    feedback?: StringFilter<"DVR"> | string
    location?: StringFilter<"DVR"> | string
    status?: StringFilter<"DVR"> | string
    approvedBy?: StringNullableFilter<"DVR"> | string | null
    approvedAt?: DateTimeNullableFilter<"DVR"> | Date | string | null
    executive?: XOR<FieldExecutiveScalarRelationFilter, FieldExecutiveWhereInput>
  }, "id">

  export type DVROrderByWithAggregationInput = {
    id?: SortOrder
    executiveId?: SortOrder
    feedback?: SortOrder
    location?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    _count?: DVRCountOrderByAggregateInput
    _max?: DVRMaxOrderByAggregateInput
    _min?: DVRMinOrderByAggregateInput
  }

  export type DVRScalarWhereWithAggregatesInput = {
    AND?: DVRScalarWhereWithAggregatesInput | DVRScalarWhereWithAggregatesInput[]
    OR?: DVRScalarWhereWithAggregatesInput[]
    NOT?: DVRScalarWhereWithAggregatesInput | DVRScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DVR"> | string
    executiveId?: StringWithAggregatesFilter<"DVR"> | string
    feedback?: StringWithAggregatesFilter<"DVR"> | string
    location?: StringWithAggregatesFilter<"DVR"> | string
    status?: StringWithAggregatesFilter<"DVR"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"DVR"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"DVR"> | Date | string | null
  }

  export type DeliveryReportWhereInput = {
    AND?: DeliveryReportWhereInput | DeliveryReportWhereInput[]
    OR?: DeliveryReportWhereInput[]
    NOT?: DeliveryReportWhereInput | DeliveryReportWhereInput[]
    id?: StringFilter<"DeliveryReport"> | string
    userId?: StringFilter<"DeliveryReport"> | string
    product?: StringFilter<"DeliveryReport"> | string
    quantity?: IntFilter<"DeliveryReport"> | number
    isForecasted?: BoolFilter<"DeliveryReport"> | boolean
    qrRequested?: BoolFilter<"DeliveryReport"> | boolean
    submittedAt?: DateTimeFilter<"DeliveryReport"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeliveryReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    product?: SortOrder
    quantity?: SortOrder
    isForecasted?: SortOrder
    qrRequested?: SortOrder
    submittedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeliveryReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryReportWhereInput | DeliveryReportWhereInput[]
    OR?: DeliveryReportWhereInput[]
    NOT?: DeliveryReportWhereInput | DeliveryReportWhereInput[]
    userId?: StringFilter<"DeliveryReport"> | string
    product?: StringFilter<"DeliveryReport"> | string
    quantity?: IntFilter<"DeliveryReport"> | number
    isForecasted?: BoolFilter<"DeliveryReport"> | boolean
    qrRequested?: BoolFilter<"DeliveryReport"> | boolean
    submittedAt?: DateTimeFilter<"DeliveryReport"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DeliveryReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    product?: SortOrder
    quantity?: SortOrder
    isForecasted?: SortOrder
    qrRequested?: SortOrder
    submittedAt?: SortOrder
    _count?: DeliveryReportCountOrderByAggregateInput
    _avg?: DeliveryReportAvgOrderByAggregateInput
    _max?: DeliveryReportMaxOrderByAggregateInput
    _min?: DeliveryReportMinOrderByAggregateInput
    _sum?: DeliveryReportSumOrderByAggregateInput
  }

  export type DeliveryReportScalarWhereWithAggregatesInput = {
    AND?: DeliveryReportScalarWhereWithAggregatesInput | DeliveryReportScalarWhereWithAggregatesInput[]
    OR?: DeliveryReportScalarWhereWithAggregatesInput[]
    NOT?: DeliveryReportScalarWhereWithAggregatesInput | DeliveryReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryReport"> | string
    userId?: StringWithAggregatesFilter<"DeliveryReport"> | string
    product?: StringWithAggregatesFilter<"DeliveryReport"> | string
    quantity?: IntWithAggregatesFilter<"DeliveryReport"> | number
    isForecasted?: BoolWithAggregatesFilter<"DeliveryReport"> | boolean
    qrRequested?: BoolWithAggregatesFilter<"DeliveryReport"> | boolean
    submittedAt?: DateTimeWithAggregatesFilter<"DeliveryReport"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    orderDate?: DateTimeFilter<"Order"> | Date | string
    promoCodeId?: StringNullableFilter<"Order"> | string | null
    orderItems?: OrderItemListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    promoCode?: XOR<PromoCodeNullableScalarRelationFilter, PromoCodeWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    promoCodeId?: SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    promoCode?: PromoCodeOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    orderDate?: DateTimeFilter<"Order"> | Date | string
    promoCodeId?: StringNullableFilter<"Order"> | string | null
    orderItems?: OrderItemListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    promoCode?: XOR<PromoCodeNullableScalarRelationFilter, PromoCodeWhereInput> | null
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    promoCodeId?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    userId?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    orderDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    promoCodeId?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"OrderItem"> | number
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    orderId?: StringFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: FloatFilter<"Invoice"> | number
    pdfUrl?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    sentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    invoiceDate?: SortOrder
    totalAmount?: SortOrder
    pdfUrl?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    paidAt?: SortOrder
    dueDate?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: FloatFilter<"Invoice"> | number
    pdfUrl?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    sentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id" | "orderId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    invoiceDate?: SortOrder
    totalAmount?: SortOrder
    pdfUrl?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    paidAt?: SortOrder
    dueDate?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    orderId?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    totalAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    pdfUrl?: StringWithAggregatesFilter<"Invoice"> | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    sentAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
  }

  export type LiveLocationWhereInput = {
    AND?: LiveLocationWhereInput | LiveLocationWhereInput[]
    OR?: LiveLocationWhereInput[]
    NOT?: LiveLocationWhereInput | LiveLocationWhereInput[]
    id?: StringFilter<"LiveLocation"> | string
    userId?: StringFilter<"LiveLocation"> | string
    latitude?: FloatFilter<"LiveLocation"> | number
    longitude?: FloatFilter<"LiveLocation"> | number
    timeStamp?: DateTimeFilter<"LiveLocation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LiveLocationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timeStamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LiveLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LiveLocationWhereInput | LiveLocationWhereInput[]
    OR?: LiveLocationWhereInput[]
    NOT?: LiveLocationWhereInput | LiveLocationWhereInput[]
    userId?: StringFilter<"LiveLocation"> | string
    latitude?: FloatFilter<"LiveLocation"> | number
    longitude?: FloatFilter<"LiveLocation"> | number
    timeStamp?: DateTimeFilter<"LiveLocation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LiveLocationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timeStamp?: SortOrder
    _count?: LiveLocationCountOrderByAggregateInput
    _avg?: LiveLocationAvgOrderByAggregateInput
    _max?: LiveLocationMaxOrderByAggregateInput
    _min?: LiveLocationMinOrderByAggregateInput
    _sum?: LiveLocationSumOrderByAggregateInput
  }

  export type LiveLocationScalarWhereWithAggregatesInput = {
    AND?: LiveLocationScalarWhereWithAggregatesInput | LiveLocationScalarWhereWithAggregatesInput[]
    OR?: LiveLocationScalarWhereWithAggregatesInput[]
    NOT?: LiveLocationScalarWhereWithAggregatesInput | LiveLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LiveLocation"> | string
    userId?: StringWithAggregatesFilter<"LiveLocation"> | string
    latitude?: FloatWithAggregatesFilter<"LiveLocation"> | number
    longitude?: FloatWithAggregatesFilter<"LiveLocation"> | number
    timeStamp?: DateTimeWithAggregatesFilter<"LiveLocation"> | Date | string
  }

  export type ShiftAlertWhereInput = {
    AND?: ShiftAlertWhereInput | ShiftAlertWhereInput[]
    OR?: ShiftAlertWhereInput[]
    NOT?: ShiftAlertWhereInput | ShiftAlertWhereInput[]
    id?: StringFilter<"ShiftAlert"> | string
    userId?: StringFilter<"ShiftAlert"> | string
    message?: StringFilter<"ShiftAlert"> | string
    createdAt?: DateTimeFilter<"ShiftAlert"> | Date | string
    acknowledged?: BoolFilter<"ShiftAlert"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ShiftAlertOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    acknowledged?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ShiftAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftAlertWhereInput | ShiftAlertWhereInput[]
    OR?: ShiftAlertWhereInput[]
    NOT?: ShiftAlertWhereInput | ShiftAlertWhereInput[]
    userId?: StringFilter<"ShiftAlert"> | string
    message?: StringFilter<"ShiftAlert"> | string
    createdAt?: DateTimeFilter<"ShiftAlert"> | Date | string
    acknowledged?: BoolFilter<"ShiftAlert"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ShiftAlertOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    acknowledged?: SortOrder
    _count?: ShiftAlertCountOrderByAggregateInput
    _max?: ShiftAlertMaxOrderByAggregateInput
    _min?: ShiftAlertMinOrderByAggregateInput
  }

  export type ShiftAlertScalarWhereWithAggregatesInput = {
    AND?: ShiftAlertScalarWhereWithAggregatesInput | ShiftAlertScalarWhereWithAggregatesInput[]
    OR?: ShiftAlertScalarWhereWithAggregatesInput[]
    NOT?: ShiftAlertScalarWhereWithAggregatesInput | ShiftAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShiftAlert"> | string
    userId?: StringWithAggregatesFilter<"ShiftAlert"> | string
    message?: StringWithAggregatesFilter<"ShiftAlert"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ShiftAlert"> | Date | string
    acknowledged?: BoolWithAggregatesFilter<"ShiftAlert"> | boolean
  }

  export type RegisterWarrantyWhereInput = {
    AND?: RegisterWarrantyWhereInput | RegisterWarrantyWhereInput[]
    OR?: RegisterWarrantyWhereInput[]
    NOT?: RegisterWarrantyWhereInput | RegisterWarrantyWhereInput[]
    id?: StringFilter<"RegisterWarranty"> | string
    productId?: StringFilter<"RegisterWarranty"> | string
    serialNumber?: StringFilter<"RegisterWarranty"> | string
    purchaseDate?: DateTimeFilter<"RegisterWarranty"> | Date | string
    warrantyMonths?: IntFilter<"RegisterWarranty"> | number
    sellerId?: StringFilter<"RegisterWarranty"> | string
    registeredAt?: DateTimeFilter<"RegisterWarranty"> | Date | string
    qrImage?: StringNullableFilter<"RegisterWarranty"> | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RegisterWarrantyOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    warrantyMonths?: SortOrder
    sellerId?: SortOrder
    registeredAt?: SortOrder
    qrImage?: SortOrder
    product?: ProductOrderByWithRelationInput
    seller?: UserOrderByWithRelationInput
  }

  export type RegisterWarrantyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serialNumber?: string
    AND?: RegisterWarrantyWhereInput | RegisterWarrantyWhereInput[]
    OR?: RegisterWarrantyWhereInput[]
    NOT?: RegisterWarrantyWhereInput | RegisterWarrantyWhereInput[]
    productId?: StringFilter<"RegisterWarranty"> | string
    purchaseDate?: DateTimeFilter<"RegisterWarranty"> | Date | string
    warrantyMonths?: IntFilter<"RegisterWarranty"> | number
    sellerId?: StringFilter<"RegisterWarranty"> | string
    registeredAt?: DateTimeFilter<"RegisterWarranty"> | Date | string
    qrImage?: StringNullableFilter<"RegisterWarranty"> | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "serialNumber">

  export type RegisterWarrantyOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    warrantyMonths?: SortOrder
    sellerId?: SortOrder
    registeredAt?: SortOrder
    qrImage?: SortOrder
    _count?: RegisterWarrantyCountOrderByAggregateInput
    _avg?: RegisterWarrantyAvgOrderByAggregateInput
    _max?: RegisterWarrantyMaxOrderByAggregateInput
    _min?: RegisterWarrantyMinOrderByAggregateInput
    _sum?: RegisterWarrantySumOrderByAggregateInput
  }

  export type RegisterWarrantyScalarWhereWithAggregatesInput = {
    AND?: RegisterWarrantyScalarWhereWithAggregatesInput | RegisterWarrantyScalarWhereWithAggregatesInput[]
    OR?: RegisterWarrantyScalarWhereWithAggregatesInput[]
    NOT?: RegisterWarrantyScalarWhereWithAggregatesInput | RegisterWarrantyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RegisterWarranty"> | string
    productId?: StringWithAggregatesFilter<"RegisterWarranty"> | string
    serialNumber?: StringWithAggregatesFilter<"RegisterWarranty"> | string
    purchaseDate?: DateTimeWithAggregatesFilter<"RegisterWarranty"> | Date | string
    warrantyMonths?: IntWithAggregatesFilter<"RegisterWarranty"> | number
    sellerId?: StringWithAggregatesFilter<"RegisterWarranty"> | string
    registeredAt?: DateTimeWithAggregatesFilter<"RegisterWarranty"> | Date | string
    qrImage?: StringNullableWithAggregatesFilter<"RegisterWarranty"> | string | null
  }

  export type PostDeliveryReportWhereInput = {
    AND?: PostDeliveryReportWhereInput | PostDeliveryReportWhereInput[]
    OR?: PostDeliveryReportWhereInput[]
    NOT?: PostDeliveryReportWhereInput | PostDeliveryReportWhereInput[]
    id?: StringFilter<"PostDeliveryReport"> | string
    userId?: StringFilter<"PostDeliveryReport"> | string
    product?: StringFilter<"PostDeliveryReport"> | string
    quantity?: IntFilter<"PostDeliveryReport"> | number
    submittedAt?: DateTimeFilter<"PostDeliveryReport"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PostDeliveryReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    product?: SortOrder
    quantity?: SortOrder
    submittedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PostDeliveryReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostDeliveryReportWhereInput | PostDeliveryReportWhereInput[]
    OR?: PostDeliveryReportWhereInput[]
    NOT?: PostDeliveryReportWhereInput | PostDeliveryReportWhereInput[]
    userId?: StringFilter<"PostDeliveryReport"> | string
    product?: StringFilter<"PostDeliveryReport"> | string
    quantity?: IntFilter<"PostDeliveryReport"> | number
    submittedAt?: DateTimeFilter<"PostDeliveryReport"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PostDeliveryReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    product?: SortOrder
    quantity?: SortOrder
    submittedAt?: SortOrder
    _count?: PostDeliveryReportCountOrderByAggregateInput
    _avg?: PostDeliveryReportAvgOrderByAggregateInput
    _max?: PostDeliveryReportMaxOrderByAggregateInput
    _min?: PostDeliveryReportMinOrderByAggregateInput
    _sum?: PostDeliveryReportSumOrderByAggregateInput
  }

  export type PostDeliveryReportScalarWhereWithAggregatesInput = {
    AND?: PostDeliveryReportScalarWhereWithAggregatesInput | PostDeliveryReportScalarWhereWithAggregatesInput[]
    OR?: PostDeliveryReportScalarWhereWithAggregatesInput[]
    NOT?: PostDeliveryReportScalarWhereWithAggregatesInput | PostDeliveryReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostDeliveryReport"> | string
    userId?: StringWithAggregatesFilter<"PostDeliveryReport"> | string
    product?: StringWithAggregatesFilter<"PostDeliveryReport"> | string
    quantity?: IntWithAggregatesFilter<"PostDeliveryReport"> | number
    submittedAt?: DateTimeWithAggregatesFilter<"PostDeliveryReport"> | Date | string
  }

  export type CommissionedWorkWhereInput = {
    AND?: CommissionedWorkWhereInput | CommissionedWorkWhereInput[]
    OR?: CommissionedWorkWhereInput[]
    NOT?: CommissionedWorkWhereInput | CommissionedWorkWhereInput[]
    id?: StringFilter<"CommissionedWork"> | string
    userId?: StringFilter<"CommissionedWork"> | string
    latitude?: FloatFilter<"CommissionedWork"> | number
    longitude?: FloatFilter<"CommissionedWork"> | number
    qrCode?: StringFilter<"CommissionedWork"> | string
    qrImage?: BytesFilter<"CommissionedWork"> | Uint8Array
    appliedAt?: DateTimeFilter<"CommissionedWork"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommissionedWorkOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    qrCode?: SortOrder
    qrImage?: SortOrder
    appliedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CommissionedWorkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommissionedWorkWhereInput | CommissionedWorkWhereInput[]
    OR?: CommissionedWorkWhereInput[]
    NOT?: CommissionedWorkWhereInput | CommissionedWorkWhereInput[]
    userId?: StringFilter<"CommissionedWork"> | string
    latitude?: FloatFilter<"CommissionedWork"> | number
    longitude?: FloatFilter<"CommissionedWork"> | number
    qrCode?: StringFilter<"CommissionedWork"> | string
    qrImage?: BytesFilter<"CommissionedWork"> | Uint8Array
    appliedAt?: DateTimeFilter<"CommissionedWork"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CommissionedWorkOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    qrCode?: SortOrder
    qrImage?: SortOrder
    appliedAt?: SortOrder
    _count?: CommissionedWorkCountOrderByAggregateInput
    _avg?: CommissionedWorkAvgOrderByAggregateInput
    _max?: CommissionedWorkMaxOrderByAggregateInput
    _min?: CommissionedWorkMinOrderByAggregateInput
    _sum?: CommissionedWorkSumOrderByAggregateInput
  }

  export type CommissionedWorkScalarWhereWithAggregatesInput = {
    AND?: CommissionedWorkScalarWhereWithAggregatesInput | CommissionedWorkScalarWhereWithAggregatesInput[]
    OR?: CommissionedWorkScalarWhereWithAggregatesInput[]
    NOT?: CommissionedWorkScalarWhereWithAggregatesInput | CommissionedWorkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommissionedWork"> | string
    userId?: StringWithAggregatesFilter<"CommissionedWork"> | string
    latitude?: FloatWithAggregatesFilter<"CommissionedWork"> | number
    longitude?: FloatWithAggregatesFilter<"CommissionedWork"> | number
    qrCode?: StringWithAggregatesFilter<"CommissionedWork"> | string
    qrImage?: BytesWithAggregatesFilter<"CommissionedWork"> | Uint8Array
    appliedAt?: DateTimeWithAggregatesFilter<"CommissionedWork"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
  }, "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringFilter<"Cart"> | string
    status?: EnumCartStatusFilter<"Cart"> | $Enums.CartStatus
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: CartItemListRelationFilter
  }

  export type CartOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    items?: CartItemOrderByRelationAggregateInput
  }

  export type CartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    status?: EnumCartStatusFilter<"Cart"> | $Enums.CartStatus
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: CartItemListRelationFilter
  }, "id" | "userId">

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartCountOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    OR?: CartScalarWhereWithAggregatesInput[]
    NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cart"> | string
    userId?: StringWithAggregatesFilter<"Cart"> | string
    status?: EnumCartStatusWithAggregatesFilter<"Cart"> | $Enums.CartStatus
    createdAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
  }

  export type CartItemWhereInput = {
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    addedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type CartItemOrderByWithRelationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    addedAt?: SortOrder
    cart?: CartOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type CartItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    addedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type CartItemOrderByWithAggregationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    addedAt?: SortOrder
    _count?: CartItemCountOrderByAggregateInput
    _avg?: CartItemAvgOrderByAggregateInput
    _max?: CartItemMaxOrderByAggregateInput
    _min?: CartItemMinOrderByAggregateInput
    _sum?: CartItemSumOrderByAggregateInput
  }

  export type CartItemScalarWhereWithAggregatesInput = {
    AND?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    OR?: CartItemScalarWhereWithAggregatesInput[]
    NOT?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CartItem"> | string
    cartId?: StringWithAggregatesFilter<"CartItem"> | string
    productId?: StringWithAggregatesFilter<"CartItem"> | string
    quantity?: IntWithAggregatesFilter<"CartItem"> | number
    addedAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
  }

  export type PromoCodeWhereInput = {
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    id?: StringFilter<"PromoCode"> | string
    code?: StringFilter<"PromoCode"> | string
    description?: StringFilter<"PromoCode"> | string
    discountType?: StringFilter<"PromoCode"> | string
    discountValue?: FloatFilter<"PromoCode"> | number
    minOrderAmount?: FloatNullableFilter<"PromoCode"> | number | null
    maxDiscount?: FloatNullableFilter<"PromoCode"> | number | null
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    usedCount?: IntFilter<"PromoCode"> | number
    status?: EnumPromoCodeStatusFilter<"PromoCode"> | $Enums.PromoCodeStatus
    validFrom?: DateTimeFilter<"PromoCode"> | Date | string
    validUntil?: DateTimeFilter<"PromoCode"> | Date | string
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    orders?: OrderListRelationFilter
  }

  export type PromoCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minOrderAmount?: SortOrder
    maxDiscount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    status?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
  }

  export type PromoCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    description?: StringFilter<"PromoCode"> | string
    discountType?: StringFilter<"PromoCode"> | string
    discountValue?: FloatFilter<"PromoCode"> | number
    minOrderAmount?: FloatNullableFilter<"PromoCode"> | number | null
    maxDiscount?: FloatNullableFilter<"PromoCode"> | number | null
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    usedCount?: IntFilter<"PromoCode"> | number
    status?: EnumPromoCodeStatusFilter<"PromoCode"> | $Enums.PromoCodeStatus
    validFrom?: DateTimeFilter<"PromoCode"> | Date | string
    validUntil?: DateTimeFilter<"PromoCode"> | Date | string
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    orders?: OrderListRelationFilter
  }, "id" | "code">

  export type PromoCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minOrderAmount?: SortOrder
    maxDiscount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    status?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    _count?: PromoCodeCountOrderByAggregateInput
    _avg?: PromoCodeAvgOrderByAggregateInput
    _max?: PromoCodeMaxOrderByAggregateInput
    _min?: PromoCodeMinOrderByAggregateInput
    _sum?: PromoCodeSumOrderByAggregateInput
  }

  export type PromoCodeScalarWhereWithAggregatesInput = {
    AND?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    OR?: PromoCodeScalarWhereWithAggregatesInput[]
    NOT?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromoCode"> | string
    code?: StringWithAggregatesFilter<"PromoCode"> | string
    description?: StringWithAggregatesFilter<"PromoCode"> | string
    discountType?: StringWithAggregatesFilter<"PromoCode"> | string
    discountValue?: FloatWithAggregatesFilter<"PromoCode"> | number
    minOrderAmount?: FloatNullableWithAggregatesFilter<"PromoCode"> | number | null
    maxDiscount?: FloatNullableWithAggregatesFilter<"PromoCode"> | number | null
    usageLimit?: IntNullableWithAggregatesFilter<"PromoCode"> | number | null
    usedCount?: IntWithAggregatesFilter<"PromoCode"> | number
    status?: EnumPromoCodeStatusWithAggregatesFilter<"PromoCode"> | $Enums.PromoCodeStatus
    validFrom?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
    validUntil?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
  }

  export type AuditWhereInput = {
    AND?: AuditWhereInput | AuditWhereInput[]
    OR?: AuditWhereInput[]
    NOT?: AuditWhereInput | AuditWhereInput[]
    id?: StringFilter<"Audit"> | string
    userId?: StringFilter<"Audit"> | string
    action?: StringFilter<"Audit"> | string
    resource?: StringNullableFilter<"Audit"> | string | null
    details?: StringNullableFilter<"Audit"> | string | null
    timestamp?: DateTimeFilter<"Audit"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditWhereInput | AuditWhereInput[]
    OR?: AuditWhereInput[]
    NOT?: AuditWhereInput | AuditWhereInput[]
    userId?: StringFilter<"Audit"> | string
    action?: StringFilter<"Audit"> | string
    resource?: StringNullableFilter<"Audit"> | string | null
    details?: StringNullableFilter<"Audit"> | string | null
    timestamp?: DateTimeFilter<"Audit"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    _count?: AuditCountOrderByAggregateInput
    _max?: AuditMaxOrderByAggregateInput
    _min?: AuditMinOrderByAggregateInput
  }

  export type AuditScalarWhereWithAggregatesInput = {
    AND?: AuditScalarWhereWithAggregatesInput | AuditScalarWhereWithAggregatesInput[]
    OR?: AuditScalarWhereWithAggregatesInput[]
    NOT?: AuditScalarWhereWithAggregatesInput | AuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Audit"> | string
    userId?: StringWithAggregatesFilter<"Audit"> | string
    action?: StringWithAggregatesFilter<"Audit"> | string
    resource?: StringNullableWithAggregatesFilter<"Audit"> | string | null
    details?: StringNullableWithAggregatesFilter<"Audit"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Audit"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type FinancialLogWhereInput = {
    AND?: FinancialLogWhereInput | FinancialLogWhereInput[]
    OR?: FinancialLogWhereInput[]
    NOT?: FinancialLogWhereInput | FinancialLogWhereInput[]
    id?: StringFilter<"FinancialLog"> | string
    type?: EnumFinancialLogTypeFilter<"FinancialLog"> | $Enums.FinancialLogType
    amount?: FloatFilter<"FinancialLog"> | number
    description?: StringFilter<"FinancialLog"> | string
    category?: StringNullableFilter<"FinancialLog"> | string | null
    reference?: StringNullableFilter<"FinancialLog"> | string | null
    createdBy?: StringFilter<"FinancialLog"> | string
    createdAt?: DateTimeFilter<"FinancialLog"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialLog"> | Date | string
    createdByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FinancialLogOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    category?: SortOrder
    reference?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdByUser?: UserOrderByWithRelationInput
  }

  export type FinancialLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FinancialLogWhereInput | FinancialLogWhereInput[]
    OR?: FinancialLogWhereInput[]
    NOT?: FinancialLogWhereInput | FinancialLogWhereInput[]
    type?: EnumFinancialLogTypeFilter<"FinancialLog"> | $Enums.FinancialLogType
    amount?: FloatFilter<"FinancialLog"> | number
    description?: StringFilter<"FinancialLog"> | string
    category?: StringNullableFilter<"FinancialLog"> | string | null
    reference?: StringNullableFilter<"FinancialLog"> | string | null
    createdBy?: StringFilter<"FinancialLog"> | string
    createdAt?: DateTimeFilter<"FinancialLog"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialLog"> | Date | string
    createdByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FinancialLogOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    category?: SortOrder
    reference?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FinancialLogCountOrderByAggregateInput
    _avg?: FinancialLogAvgOrderByAggregateInput
    _max?: FinancialLogMaxOrderByAggregateInput
    _min?: FinancialLogMinOrderByAggregateInput
    _sum?: FinancialLogSumOrderByAggregateInput
  }

  export type FinancialLogScalarWhereWithAggregatesInput = {
    AND?: FinancialLogScalarWhereWithAggregatesInput | FinancialLogScalarWhereWithAggregatesInput[]
    OR?: FinancialLogScalarWhereWithAggregatesInput[]
    NOT?: FinancialLogScalarWhereWithAggregatesInput | FinancialLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinancialLog"> | string
    type?: EnumFinancialLogTypeWithAggregatesFilter<"FinancialLog"> | $Enums.FinancialLogType
    amount?: FloatWithAggregatesFilter<"FinancialLog"> | number
    description?: StringWithAggregatesFilter<"FinancialLog"> | string
    category?: StringNullableWithAggregatesFilter<"FinancialLog"> | string | null
    reference?: StringNullableWithAggregatesFilter<"FinancialLog"> | string | null
    createdBy?: StringWithAggregatesFilter<"FinancialLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FinancialLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FinancialLog"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    executiveId?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    executiveId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    executiveId?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    executiveId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringWithAggregatesFilter<"Task"> | string
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    executiveId?: StringWithAggregatesFilter<"Task"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type DamageReportWhereInput = {
    AND?: DamageReportWhereInput | DamageReportWhereInput[]
    OR?: DamageReportWhereInput[]
    NOT?: DamageReportWhereInput | DamageReportWhereInput[]
    id?: StringFilter<"DamageReport"> | string
    stockId?: StringFilter<"DamageReport"> | string
    workerId?: StringFilter<"DamageReport"> | string
    reason?: StringFilter<"DamageReport"> | string
    quantity?: IntFilter<"DamageReport"> | number
    location?: StringFilter<"DamageReport"> | string
    reportedAt?: DateTimeFilter<"DamageReport"> | Date | string
    stock?: XOR<StockScalarRelationFilter, StockWhereInput>
  }

  export type DamageReportOrderByWithRelationInput = {
    id?: SortOrder
    stockId?: SortOrder
    workerId?: SortOrder
    reason?: SortOrder
    quantity?: SortOrder
    location?: SortOrder
    reportedAt?: SortOrder
    stock?: StockOrderByWithRelationInput
  }

  export type DamageReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DamageReportWhereInput | DamageReportWhereInput[]
    OR?: DamageReportWhereInput[]
    NOT?: DamageReportWhereInput | DamageReportWhereInput[]
    stockId?: StringFilter<"DamageReport"> | string
    workerId?: StringFilter<"DamageReport"> | string
    reason?: StringFilter<"DamageReport"> | string
    quantity?: IntFilter<"DamageReport"> | number
    location?: StringFilter<"DamageReport"> | string
    reportedAt?: DateTimeFilter<"DamageReport"> | Date | string
    stock?: XOR<StockScalarRelationFilter, StockWhereInput>
  }, "id">

  export type DamageReportOrderByWithAggregationInput = {
    id?: SortOrder
    stockId?: SortOrder
    workerId?: SortOrder
    reason?: SortOrder
    quantity?: SortOrder
    location?: SortOrder
    reportedAt?: SortOrder
    _count?: DamageReportCountOrderByAggregateInput
    _avg?: DamageReportAvgOrderByAggregateInput
    _max?: DamageReportMaxOrderByAggregateInput
    _min?: DamageReportMinOrderByAggregateInput
    _sum?: DamageReportSumOrderByAggregateInput
  }

  export type DamageReportScalarWhereWithAggregatesInput = {
    AND?: DamageReportScalarWhereWithAggregatesInput | DamageReportScalarWhereWithAggregatesInput[]
    OR?: DamageReportScalarWhereWithAggregatesInput[]
    NOT?: DamageReportScalarWhereWithAggregatesInput | DamageReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DamageReport"> | string
    stockId?: StringWithAggregatesFilter<"DamageReport"> | string
    workerId?: StringWithAggregatesFilter<"DamageReport"> | string
    reason?: StringWithAggregatesFilter<"DamageReport"> | string
    quantity?: IntWithAggregatesFilter<"DamageReport"> | number
    location?: StringWithAggregatesFilter<"DamageReport"> | string
    reportedAt?: DateTimeWithAggregatesFilter<"DamageReport"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringFilter<"Customer"> | string
    location?: StringFilter<"Customer"> | string
    address?: StringNullableFilter<"Customer"> | string | null
    assignedTo?: StringFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    visits?: CustomerVisitListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    address?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: CustomerVisitOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringFilter<"Customer"> | string
    location?: StringFilter<"Customer"> | string
    address?: StringNullableFilter<"Customer"> | string | null
    assignedTo?: StringFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    visits?: CustomerVisitListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    address?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringWithAggregatesFilter<"Customer"> | string
    location?: StringWithAggregatesFilter<"Customer"> | string
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    assignedTo?: StringWithAggregatesFilter<"Customer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type CustomerVisitWhereInput = {
    AND?: CustomerVisitWhereInput | CustomerVisitWhereInput[]
    OR?: CustomerVisitWhereInput[]
    NOT?: CustomerVisitWhereInput | CustomerVisitWhereInput[]
    id?: StringFilter<"CustomerVisit"> | string
    customerId?: StringFilter<"CustomerVisit"> | string
    executiveId?: StringFilter<"CustomerVisit"> | string
    visitDate?: DateTimeFilter<"CustomerVisit"> | Date | string
    location?: StringFilter<"CustomerVisit"> | string
    peoplePresent?: StringNullableFilter<"CustomerVisit"> | string | null
    productsDiscussed?: StringNullableFilter<"CustomerVisit"> | string | null
    reasonForVisit?: StringNullableFilter<"CustomerVisit"> | string | null
    customerConcerns?: StringNullableFilter<"CustomerVisit"> | string | null
    investigationStatus?: StringNullableFilter<"CustomerVisit"> | string | null
    rootCause?: StringNullableFilter<"CustomerVisit"> | string | null
    correctiveAction?: StringNullableFilter<"CustomerVisit"> | string | null
    recommendations?: StringNullableFilter<"CustomerVisit"> | string | null
    feedback?: StringNullableFilter<"CustomerVisit"> | string | null
    reportCompletedBy?: StringFilter<"CustomerVisit"> | string
    createdAt?: DateTimeFilter<"CustomerVisit"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerVisit"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerVisitOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    executiveId?: SortOrder
    visitDate?: SortOrder
    location?: SortOrder
    peoplePresent?: SortOrder
    productsDiscussed?: SortOrder
    reasonForVisit?: SortOrder
    customerConcerns?: SortOrder
    investigationStatus?: SortOrder
    rootCause?: SortOrder
    correctiveAction?: SortOrder
    recommendations?: SortOrder
    feedback?: SortOrder
    reportCompletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerVisitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerVisitWhereInput | CustomerVisitWhereInput[]
    OR?: CustomerVisitWhereInput[]
    NOT?: CustomerVisitWhereInput | CustomerVisitWhereInput[]
    customerId?: StringFilter<"CustomerVisit"> | string
    executiveId?: StringFilter<"CustomerVisit"> | string
    visitDate?: DateTimeFilter<"CustomerVisit"> | Date | string
    location?: StringFilter<"CustomerVisit"> | string
    peoplePresent?: StringNullableFilter<"CustomerVisit"> | string | null
    productsDiscussed?: StringNullableFilter<"CustomerVisit"> | string | null
    reasonForVisit?: StringNullableFilter<"CustomerVisit"> | string | null
    customerConcerns?: StringNullableFilter<"CustomerVisit"> | string | null
    investigationStatus?: StringNullableFilter<"CustomerVisit"> | string | null
    rootCause?: StringNullableFilter<"CustomerVisit"> | string | null
    correctiveAction?: StringNullableFilter<"CustomerVisit"> | string | null
    recommendations?: StringNullableFilter<"CustomerVisit"> | string | null
    feedback?: StringNullableFilter<"CustomerVisit"> | string | null
    reportCompletedBy?: StringFilter<"CustomerVisit"> | string
    createdAt?: DateTimeFilter<"CustomerVisit"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerVisit"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type CustomerVisitOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    executiveId?: SortOrder
    visitDate?: SortOrder
    location?: SortOrder
    peoplePresent?: SortOrder
    productsDiscussed?: SortOrder
    reasonForVisit?: SortOrder
    customerConcerns?: SortOrder
    investigationStatus?: SortOrder
    rootCause?: SortOrder
    correctiveAction?: SortOrder
    recommendations?: SortOrder
    feedback?: SortOrder
    reportCompletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerVisitCountOrderByAggregateInput
    _max?: CustomerVisitMaxOrderByAggregateInput
    _min?: CustomerVisitMinOrderByAggregateInput
  }

  export type CustomerVisitScalarWhereWithAggregatesInput = {
    AND?: CustomerVisitScalarWhereWithAggregatesInput | CustomerVisitScalarWhereWithAggregatesInput[]
    OR?: CustomerVisitScalarWhereWithAggregatesInput[]
    NOT?: CustomerVisitScalarWhereWithAggregatesInput | CustomerVisitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerVisit"> | string
    customerId?: StringWithAggregatesFilter<"CustomerVisit"> | string
    executiveId?: StringWithAggregatesFilter<"CustomerVisit"> | string
    visitDate?: DateTimeWithAggregatesFilter<"CustomerVisit"> | Date | string
    location?: StringWithAggregatesFilter<"CustomerVisit"> | string
    peoplePresent?: StringNullableWithAggregatesFilter<"CustomerVisit"> | string | null
    productsDiscussed?: StringNullableWithAggregatesFilter<"CustomerVisit"> | string | null
    reasonForVisit?: StringNullableWithAggregatesFilter<"CustomerVisit"> | string | null
    customerConcerns?: StringNullableWithAggregatesFilter<"CustomerVisit"> | string | null
    investigationStatus?: StringNullableWithAggregatesFilter<"CustomerVisit"> | string | null
    rootCause?: StringNullableWithAggregatesFilter<"CustomerVisit"> | string | null
    correctiveAction?: StringNullableWithAggregatesFilter<"CustomerVisit"> | string | null
    recommendations?: StringNullableWithAggregatesFilter<"CustomerVisit"> | string | null
    feedback?: StringNullableWithAggregatesFilter<"CustomerVisit"> | string | null
    reportCompletedBy?: StringWithAggregatesFilter<"CustomerVisit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomerVisit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerVisit"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    senderId?: StringFilter<"ChatMessage"> | string
    receiverId?: StringNullableFilter<"ChatMessage"> | string | null
    content?: StringFilter<"ChatMessage"> | string
    isRead?: BoolFilter<"ChatMessage"> | boolean
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    senderId?: StringFilter<"ChatMessage"> | string
    receiverId?: StringNullableFilter<"ChatMessage"> | string | null
    content?: StringFilter<"ChatMessage"> | string
    isRead?: BoolFilter<"ChatMessage"> | boolean
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    senderId?: StringWithAggregatesFilter<"ChatMessage"> | string
    receiverId?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    content?: StringWithAggregatesFilter<"ChatMessage"> | string
    isRead?: BoolWithAggregatesFilter<"ChatMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type CapturedImageWhereInput = {
    AND?: CapturedImageWhereInput | CapturedImageWhereInput[]
    OR?: CapturedImageWhereInput[]
    NOT?: CapturedImageWhereInput | CapturedImageWhereInput[]
    id?: StringFilter<"CapturedImage"> | string
    executiveId?: StringFilter<"CapturedImage"> | string
    imageData?: BytesFilter<"CapturedImage"> | Uint8Array
    latitude?: FloatNullableFilter<"CapturedImage"> | number | null
    longitude?: FloatNullableFilter<"CapturedImage"> | number | null
    description?: StringNullableFilter<"CapturedImage"> | string | null
    createdAt?: DateTimeFilter<"CapturedImage"> | Date | string
  }

  export type CapturedImageOrderByWithRelationInput = {
    id?: SortOrder
    executiveId?: SortOrder
    imageData?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type CapturedImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CapturedImageWhereInput | CapturedImageWhereInput[]
    OR?: CapturedImageWhereInput[]
    NOT?: CapturedImageWhereInput | CapturedImageWhereInput[]
    executiveId?: StringFilter<"CapturedImage"> | string
    imageData?: BytesFilter<"CapturedImage"> | Uint8Array
    latitude?: FloatNullableFilter<"CapturedImage"> | number | null
    longitude?: FloatNullableFilter<"CapturedImage"> | number | null
    description?: StringNullableFilter<"CapturedImage"> | string | null
    createdAt?: DateTimeFilter<"CapturedImage"> | Date | string
  }, "id">

  export type CapturedImageOrderByWithAggregationInput = {
    id?: SortOrder
    executiveId?: SortOrder
    imageData?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: CapturedImageCountOrderByAggregateInput
    _avg?: CapturedImageAvgOrderByAggregateInput
    _max?: CapturedImageMaxOrderByAggregateInput
    _min?: CapturedImageMinOrderByAggregateInput
    _sum?: CapturedImageSumOrderByAggregateInput
  }

  export type CapturedImageScalarWhereWithAggregatesInput = {
    AND?: CapturedImageScalarWhereWithAggregatesInput | CapturedImageScalarWhereWithAggregatesInput[]
    OR?: CapturedImageScalarWhereWithAggregatesInput[]
    NOT?: CapturedImageScalarWhereWithAggregatesInput | CapturedImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CapturedImage"> | string
    executiveId?: StringWithAggregatesFilter<"CapturedImage"> | string
    imageData?: BytesWithAggregatesFilter<"CapturedImage"> | Uint8Array
    latitude?: FloatNullableWithAggregatesFilter<"CapturedImage"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"CapturedImage"> | number | null
    description?: StringNullableWithAggregatesFilter<"CapturedImage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CapturedImage"> | Date | string
  }

  export type SignatureWhereInput = {
    AND?: SignatureWhereInput | SignatureWhereInput[]
    OR?: SignatureWhereInput[]
    NOT?: SignatureWhereInput | SignatureWhereInput[]
    id?: StringFilter<"Signature"> | string
    executiveId?: StringFilter<"Signature"> | string
    signatureData?: BytesFilter<"Signature"> | Uint8Array
    context?: StringNullableFilter<"Signature"> | string | null
    createdAt?: DateTimeFilter<"Signature"> | Date | string
  }

  export type SignatureOrderByWithRelationInput = {
    id?: SortOrder
    executiveId?: SortOrder
    signatureData?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
  }

  export type SignatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SignatureWhereInput | SignatureWhereInput[]
    OR?: SignatureWhereInput[]
    NOT?: SignatureWhereInput | SignatureWhereInput[]
    executiveId?: StringFilter<"Signature"> | string
    signatureData?: BytesFilter<"Signature"> | Uint8Array
    context?: StringNullableFilter<"Signature"> | string | null
    createdAt?: DateTimeFilter<"Signature"> | Date | string
  }, "id">

  export type SignatureOrderByWithAggregationInput = {
    id?: SortOrder
    executiveId?: SortOrder
    signatureData?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
    _count?: SignatureCountOrderByAggregateInput
    _max?: SignatureMaxOrderByAggregateInput
    _min?: SignatureMinOrderByAggregateInput
  }

  export type SignatureScalarWhereWithAggregatesInput = {
    AND?: SignatureScalarWhereWithAggregatesInput | SignatureScalarWhereWithAggregatesInput[]
    OR?: SignatureScalarWhereWithAggregatesInput[]
    NOT?: SignatureScalarWhereWithAggregatesInput | SignatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Signature"> | string
    executiveId?: StringWithAggregatesFilter<"Signature"> | string
    signatureData?: BytesWithAggregatesFilter<"Signature"> | Uint8Array
    context?: StringNullableWithAggregatesFilter<"Signature"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Signature"> | Date | string
  }

  export type OfflineDataWhereInput = {
    AND?: OfflineDataWhereInput | OfflineDataWhereInput[]
    OR?: OfflineDataWhereInput[]
    NOT?: OfflineDataWhereInput | OfflineDataWhereInput[]
    id?: StringFilter<"OfflineData"> | string
    executiveId?: StringFilter<"OfflineData"> | string
    dataType?: StringFilter<"OfflineData"> | string
    data?: StringFilter<"OfflineData"> | string
    synced?: BoolFilter<"OfflineData"> | boolean
    createdAt?: DateTimeFilter<"OfflineData"> | Date | string
    syncedAt?: DateTimeNullableFilter<"OfflineData"> | Date | string | null
  }

  export type OfflineDataOrderByWithRelationInput = {
    id?: SortOrder
    executiveId?: SortOrder
    dataType?: SortOrder
    data?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    syncedAt?: SortOrder
  }

  export type OfflineDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfflineDataWhereInput | OfflineDataWhereInput[]
    OR?: OfflineDataWhereInput[]
    NOT?: OfflineDataWhereInput | OfflineDataWhereInput[]
    executiveId?: StringFilter<"OfflineData"> | string
    dataType?: StringFilter<"OfflineData"> | string
    data?: StringFilter<"OfflineData"> | string
    synced?: BoolFilter<"OfflineData"> | boolean
    createdAt?: DateTimeFilter<"OfflineData"> | Date | string
    syncedAt?: DateTimeNullableFilter<"OfflineData"> | Date | string | null
  }, "id">

  export type OfflineDataOrderByWithAggregationInput = {
    id?: SortOrder
    executiveId?: SortOrder
    dataType?: SortOrder
    data?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    syncedAt?: SortOrder
    _count?: OfflineDataCountOrderByAggregateInput
    _max?: OfflineDataMaxOrderByAggregateInput
    _min?: OfflineDataMinOrderByAggregateInput
  }

  export type OfflineDataScalarWhereWithAggregatesInput = {
    AND?: OfflineDataScalarWhereWithAggregatesInput | OfflineDataScalarWhereWithAggregatesInput[]
    OR?: OfflineDataScalarWhereWithAggregatesInput[]
    NOT?: OfflineDataScalarWhereWithAggregatesInput | OfflineDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfflineData"> | string
    executiveId?: StringWithAggregatesFilter<"OfflineData"> | string
    dataType?: StringWithAggregatesFilter<"OfflineData"> | string
    data?: StringWithAggregatesFilter<"OfflineData"> | string
    synced?: BoolWithAggregatesFilter<"OfflineData"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OfflineData"> | Date | string
    syncedAt?: DateTimeNullableWithAggregatesFilter<"OfflineData"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type UserUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: AdminCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: AdminUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: AdminUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: AdminUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutAdminInput
    company?: CompanyCreateNestedOneWithoutAdminsInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
    companyId?: string | null
  }

  export type AdminUpdateInput = {
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    company?: CompanyUpdateOneWithoutAdminsNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
    companyId?: string | null
  }

  export type AdminUpdateManyMutationInput = {

  }

  export type AdminUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesManagerCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutSalesManagerInput
  }

  export type SalesManagerUncheckedCreateInput = {
    id?: string
    userId: string
  }

  export type SalesManagerUpdateInput = {
    user?: UserUpdateOneRequiredWithoutSalesManagerNestedInput
  }

  export type SalesManagerUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SalesManagerCreateManyInput = {
    id?: string
    userId: string
  }

  export type SalesManagerUpdateManyMutationInput = {

  }

  export type SalesManagerUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PlumberCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutPlumberInput
  }

  export type PlumberUncheckedCreateInput = {
    id?: string
    userId: string
  }

  export type PlumberUpdateInput = {
    user?: UserUpdateOneRequiredWithoutPlumberNestedInput
  }

  export type PlumberUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PlumberCreateManyInput = {
    id?: string
    userId: string
  }

  export type PlumberUpdateManyMutationInput = {

  }

  export type PlumberUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PlumberAccountProfileCreateInput = {
    id?: string
    fullName: string
    contactNumber: string
    upiId?: string | null
    upiQrUrl?: string | null
    email?: string | null
    bankName?: string | null
    accountNumber?: string | null
    accountHolderName?: string | null
    ifscCode?: string | null
    branchName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountProfileInput
  }

  export type PlumberAccountProfileUncheckedCreateInput = {
    id?: string
    userId: string
    fullName: string
    contactNumber: string
    upiId?: string | null
    upiQrUrl?: string | null
    email?: string | null
    bankName?: string | null
    accountNumber?: string | null
    accountHolderName?: string | null
    ifscCode?: string | null
    branchName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlumberAccountProfileUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    upiQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountProfileNestedInput
  }

  export type PlumberAccountProfileUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    upiQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlumberAccountProfileCreateManyInput = {
    id?: string
    userId: string
    fullName: string
    contactNumber: string
    upiId?: string | null
    upiQrUrl?: string | null
    email?: string | null
    bankName?: string | null
    accountNumber?: string | null
    accountHolderName?: string | null
    ifscCode?: string | null
    branchName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlumberAccountProfileUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    upiQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlumberAccountProfileUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    upiQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountantCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutAccountantInput
  }

  export type AccountantUncheckedCreateInput = {
    id?: string
    userId: string
  }

  export type AccountantUpdateInput = {
    user?: UserUpdateOneRequiredWithoutAccountantNestedInput
  }

  export type AccountantUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountantCreateManyInput = {
    id?: string
    userId: string
  }

  export type AccountantUpdateManyMutationInput = {

  }

  export type AccountantUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DistributorCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutDistributorInput
  }

  export type DistributorUncheckedCreateInput = {
    id?: string
    userId: string
  }

  export type DistributorUpdateInput = {
    user?: UserUpdateOneRequiredWithoutDistributorNestedInput
  }

  export type DistributorUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DistributorCreateManyInput = {
    id?: string
    userId: string
  }

  export type DistributorUpdateManyMutationInput = {

  }

  export type DistributorUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldExecutiveCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutFieldExecutiveInput
    followUps?: CustomerFollowUpCreateNestedManyWithoutExecutiveInput
    dvrReports?: DVRCreateNestedManyWithoutExecutiveInput
  }

  export type FieldExecutiveUncheckedCreateInput = {
    id?: string
    userId: string
    followUps?: CustomerFollowUpUncheckedCreateNestedManyWithoutExecutiveInput
    dvrReports?: DVRUncheckedCreateNestedManyWithoutExecutiveInput
  }

  export type FieldExecutiveUpdateInput = {
    user?: UserUpdateOneRequiredWithoutFieldExecutiveNestedInput
    followUps?: CustomerFollowUpUpdateManyWithoutExecutiveNestedInput
    dvrReports?: DVRUpdateManyWithoutExecutiveNestedInput
  }

  export type FieldExecutiveUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    followUps?: CustomerFollowUpUncheckedUpdateManyWithoutExecutiveNestedInput
    dvrReports?: DVRUncheckedUpdateManyWithoutExecutiveNestedInput
  }

  export type FieldExecutiveCreateManyInput = {
    id?: string
    userId: string
  }

  export type FieldExecutiveUpdateManyMutationInput = {

  }

  export type FieldExecutiveUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkerCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutWorkerInput
  }

  export type WorkerUncheckedCreateInput = {
    id?: string
    userId: string
  }

  export type WorkerUpdateInput = {
    user?: UserUpdateOneRequiredWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkerCreateManyInput = {
    id?: string
    userId: string
  }

  export type WorkerUpdateManyMutationInput = {

  }

  export type WorkerUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    stocks?: StockCreateNestedManyWithoutProductInput
    warrantyCards?: WarrantyCardCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    categoryId?: string | null
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    warrantyCards?: WarrantyCardUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    stocks?: StockUpdateManyWithoutProductNestedInput
    warrantyCards?: WarrantyCardUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    stocks?: StockUncheckedUpdateManyWithoutProductNestedInput
    warrantyCards?: WarrantyCardUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    categoryId?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockCreateInput = {
    id?: string
    status: $Enums.StockStatus
    location: string
    product: ProductCreateNestedOneWithoutStocksInput
    damageReports?: DamageReportCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateInput = {
    id?: string
    productId: string
    status: $Enums.StockStatus
    location: string
    damageReports?: DamageReportUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockUpdateInput = {
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    location?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutStocksNestedInput
    damageReports?: DamageReportUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateInput = {
    productId?: StringFieldUpdateOperationsInput | string
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    location?: StringFieldUpdateOperationsInput | string
    damageReports?: DamageReportUncheckedUpdateManyWithoutStockNestedInput
  }

  export type StockCreateManyInput = {
    id?: string
    productId: string
    status: $Enums.StockStatus
    location: string
  }

  export type StockUpdateManyMutationInput = {
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    location?: StringFieldUpdateOperationsInput | string
  }

  export type StockUncheckedUpdateManyInput = {
    productId?: StringFieldUpdateOperationsInput | string
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    location?: StringFieldUpdateOperationsInput | string
  }

  export type WarrantyCardCreateInput = {
    id?: string
    serialNumber: string
    purchaseDate: Date | string
    expiryDate: Date | string
    scanQR: string
    validViaWarranIQ: string
    product: ProductCreateNestedOneWithoutWarrantyCardsInput
  }

  export type WarrantyCardUncheckedCreateInput = {
    id?: string
    productId: string
    serialNumber: string
    purchaseDate: Date | string
    expiryDate: Date | string
    scanQR: string
    validViaWarranIQ: string
  }

  export type WarrantyCardUpdateInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scanQR?: StringFieldUpdateOperationsInput | string
    validViaWarranIQ?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutWarrantyCardsNestedInput
  }

  export type WarrantyCardUncheckedUpdateInput = {
    productId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scanQR?: StringFieldUpdateOperationsInput | string
    validViaWarranIQ?: StringFieldUpdateOperationsInput | string
  }

  export type WarrantyCardCreateManyInput = {
    id?: string
    productId: string
    serialNumber: string
    purchaseDate: Date | string
    expiryDate: Date | string
    scanQR: string
    validViaWarranIQ: string
  }

  export type WarrantyCardUpdateManyMutationInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scanQR?: StringFieldUpdateOperationsInput | string
    validViaWarranIQ?: StringFieldUpdateOperationsInput | string
  }

  export type WarrantyCardUncheckedUpdateManyInput = {
    productId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scanQR?: StringFieldUpdateOperationsInput | string
    validViaWarranIQ?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceCreateInput = {
    id?: string
    date: Date | string
    checkIn: Date | string
    checkOut?: Date | string | null
    user: UserCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    checkIn: Date | string
    checkOut?: Date | string | null
  }

  export type AttendanceUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    checkIn: Date | string
    checkOut?: Date | string | null
  }

  export type AttendanceUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerFollowUpCreateInput = {
    id?: string
    customerName: string
    contactDetails: string
    feedback: string
    status: $Enums.FollowUpStatus
    nextFollowUpDate: Date | string
    executive: FieldExecutiveCreateNestedOneWithoutFollowUpsInput
  }

  export type CustomerFollowUpUncheckedCreateInput = {
    id?: string
    executiveId: string
    customerName: string
    contactDetails: string
    feedback: string
    status: $Enums.FollowUpStatus
    nextFollowUpDate: Date | string
  }

  export type CustomerFollowUpUpdateInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    contactDetails?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
    nextFollowUpDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executive?: FieldExecutiveUpdateOneRequiredWithoutFollowUpsNestedInput
  }

  export type CustomerFollowUpUncheckedUpdateInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    contactDetails?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
    nextFollowUpDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerFollowUpCreateManyInput = {
    id?: string
    executiveId: string
    customerName: string
    contactDetails: string
    feedback: string
    status: $Enums.FollowUpStatus
    nextFollowUpDate: Date | string
  }

  export type CustomerFollowUpUpdateManyMutationInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    contactDetails?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
    nextFollowUpDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerFollowUpUncheckedUpdateManyInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    contactDetails?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
    nextFollowUpDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointTransactionCreateInput = {
    id?: string
    points: number
    creditAmount: number
    date: Date | string
    reason: string
    type: $Enums.TransactionType
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type PointTransactionUncheckedCreateInput = {
    id?: string
    userId: string
    points: number
    creditAmount: number
    date: Date | string
    reason: string
    type: $Enums.TransactionType
  }

  export type PointTransactionUpdateInput = {
    points?: IntFieldUpdateOperationsInput | number
    creditAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type PointTransactionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    creditAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
  }

  export type PointTransactionCreateManyInput = {
    id?: string
    userId: string
    points: number
    creditAmount: number
    date: Date | string
    reason: string
    type: $Enums.TransactionType
  }

  export type PointTransactionUpdateManyMutationInput = {
    points?: IntFieldUpdateOperationsInput | number
    creditAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
  }

  export type PointTransactionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    creditAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
  }

  export type IncentiveCreateInput = {
    id?: string
    description: string
    points: number
    assignedAt: Date | string
    assignedTo: UserCreateNestedOneWithoutIncentivesInput
  }

  export type IncentiveUncheckedCreateInput = {
    id?: string
    description: string
    points: number
    assignedId: string
    assignedAt: Date | string
  }

  export type IncentiveUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneRequiredWithoutIncentivesNestedInput
  }

  export type IncentiveUncheckedUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    assignedId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncentiveCreateManyInput = {
    id?: string
    description: string
    points: number
    assignedId: string
    assignedAt: Date | string
  }

  export type IncentiveUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncentiveUncheckedUpdateManyInput = {
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    assignedId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DVRCreateInput = {
    id?: string
    feedback: string
    location: string
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    executive: FieldExecutiveCreateNestedOneWithoutDvrReportsInput
  }

  export type DVRUncheckedCreateInput = {
    id?: string
    executiveId: string
    feedback: string
    location: string
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
  }

  export type DVRUpdateInput = {
    feedback?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executive?: FieldExecutiveUpdateOneRequiredWithoutDvrReportsNestedInput
  }

  export type DVRUncheckedUpdateInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DVRCreateManyInput = {
    id?: string
    executiveId: string
    feedback: string
    location: string
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
  }

  export type DVRUpdateManyMutationInput = {
    feedback?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DVRUncheckedUpdateManyInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryReportCreateInput = {
    id?: string
    product: string
    quantity: number
    isForecasted: boolean
    qrRequested?: boolean
    submittedAt: Date | string
    user: UserCreateNestedOneWithoutDeliveryReportsInput
  }

  export type DeliveryReportUncheckedCreateInput = {
    id?: string
    userId: string
    product: string
    quantity: number
    isForecasted: boolean
    qrRequested?: boolean
    submittedAt: Date | string
  }

  export type DeliveryReportUpdateInput = {
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isForecasted?: BoolFieldUpdateOperationsInput | boolean
    qrRequested?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeliveryReportsNestedInput
  }

  export type DeliveryReportUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isForecasted?: BoolFieldUpdateOperationsInput | boolean
    qrRequested?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryReportCreateManyInput = {
    id?: string
    userId: string
    product: string
    quantity: number
    isForecasted: boolean
    qrRequested?: boolean
    submittedAt: Date | string
  }

  export type DeliveryReportUpdateManyMutationInput = {
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isForecasted?: BoolFieldUpdateOperationsInput | boolean
    qrRequested?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryReportUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isForecasted?: BoolFieldUpdateOperationsInput | boolean
    qrRequested?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    status: $Enums.OrderStatus
    orderDate: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    user: UserCreateNestedOneWithoutOrdersInput
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    userId: string
    status: $Enums.OrderStatus
    orderDate: Date | string
    promoCodeId?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    userId: string
    status: $Enums.OrderStatus
    orderDate: Date | string
    promoCodeId?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: number
    order: OrderCreateNestedOneWithoutOrderItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productId: string
    quantity: number
    unitPrice: number
  }

  export type OrderItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productId: string
    quantity: number
    unitPrice: number
  }

  export type OrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceDate: Date | string
    totalAmount: number
    pdfUrl: string
    status?: $Enums.InvoiceStatus
    sentAt?: Date | string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
    order: OrderCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    orderId: string
    invoiceDate: Date | string
    totalAmount: number
    pdfUrl: string
    status?: $Enums.InvoiceStatus
    sentAt?: Date | string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
  }

  export type InvoiceUpdateInput = {
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceCreateManyInput = {
    id?: string
    orderId: string
    invoiceDate: Date | string
    totalAmount: number
    pdfUrl: string
    status?: $Enums.InvoiceStatus
    sentAt?: Date | string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LiveLocationCreateInput = {
    id?: string
    latitude: number
    longitude: number
    timeStamp: Date | string
    user: UserCreateNestedOneWithoutLiveLocationsInput
  }

  export type LiveLocationUncheckedCreateInput = {
    id?: string
    userId: string
    latitude: number
    longitude: number
    timeStamp: Date | string
  }

  export type LiveLocationUpdateInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLiveLocationsNestedInput
  }

  export type LiveLocationUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveLocationCreateManyInput = {
    id?: string
    userId: string
    latitude: number
    longitude: number
    timeStamp: Date | string
  }

  export type LiveLocationUpdateManyMutationInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveLocationUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAlertCreateInput = {
    id?: string
    message: string
    createdAt?: Date | string
    acknowledged?: boolean
    user: UserCreateNestedOneWithoutShiftAlertInput
  }

  export type ShiftAlertUncheckedCreateInput = {
    id?: string
    userId: string
    message: string
    createdAt?: Date | string
    acknowledged?: boolean
  }

  export type ShiftAlertUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutShiftAlertNestedInput
  }

  export type ShiftAlertUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShiftAlertCreateManyInput = {
    id?: string
    userId: string
    message: string
    createdAt?: Date | string
    acknowledged?: boolean
  }

  export type ShiftAlertUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShiftAlertUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegisterWarrantyCreateInput = {
    id?: string
    serialNumber: string
    purchaseDate: Date | string
    warrantyMonths: number
    registeredAt?: Date | string
    qrImage?: string | null
    product: ProductCreateNestedOneWithoutRegisteredWarrantiesInput
    seller: UserCreateNestedOneWithoutRegisteredWarrantiesInput
  }

  export type RegisterWarrantyUncheckedCreateInput = {
    id?: string
    productId: string
    serialNumber: string
    purchaseDate: Date | string
    warrantyMonths: number
    sellerId: string
    registeredAt?: Date | string
    qrImage?: string | null
  }

  export type RegisterWarrantyUpdateInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyMonths?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrImage?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutRegisteredWarrantiesNestedInput
    seller?: UserUpdateOneRequiredWithoutRegisteredWarrantiesNestedInput
  }

  export type RegisterWarrantyUncheckedUpdateInput = {
    productId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyMonths?: IntFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegisterWarrantyCreateManyInput = {
    id?: string
    productId: string
    serialNumber: string
    purchaseDate: Date | string
    warrantyMonths: number
    sellerId: string
    registeredAt?: Date | string
    qrImage?: string | null
  }

  export type RegisterWarrantyUpdateManyMutationInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyMonths?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegisterWarrantyUncheckedUpdateManyInput = {
    productId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyMonths?: IntFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostDeliveryReportCreateInput = {
    id?: string
    product: string
    quantity: number
    submittedAt?: Date | string
    user: UserCreateNestedOneWithoutPostDeliveryReportsInput
  }

  export type PostDeliveryReportUncheckedCreateInput = {
    id?: string
    userId: string
    product: string
    quantity: number
    submittedAt?: Date | string
  }

  export type PostDeliveryReportUpdateInput = {
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPostDeliveryReportsNestedInput
  }

  export type PostDeliveryReportUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostDeliveryReportCreateManyInput = {
    id?: string
    userId: string
    product: string
    quantity: number
    submittedAt?: Date | string
  }

  export type PostDeliveryReportUpdateManyMutationInput = {
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostDeliveryReportUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionedWorkCreateInput = {
    id?: string
    latitude: number
    longitude: number
    qrCode: string
    qrImage: Uint8Array
    appliedAt?: Date | string
    user: UserCreateNestedOneWithoutCommissionedWorksInput
  }

  export type CommissionedWorkUncheckedCreateInput = {
    id?: string
    userId: string
    latitude: number
    longitude: number
    qrCode: string
    qrImage: Uint8Array
    appliedAt?: Date | string
  }

  export type CommissionedWorkUpdateInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    qrCode?: StringFieldUpdateOperationsInput | string
    qrImage?: BytesFieldUpdateOperationsInput | Uint8Array
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommissionedWorksNestedInput
  }

  export type CommissionedWorkUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    qrCode?: StringFieldUpdateOperationsInput | string
    qrImage?: BytesFieldUpdateOperationsInput | Uint8Array
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionedWorkCreateManyInput = {
    id?: string
    userId: string
    latitude: number
    longitude: number
    qrCode: string
    qrImage: Uint8Array
    appliedAt?: Date | string
  }

  export type CommissionedWorkUpdateManyMutationInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    qrCode?: StringFieldUpdateOperationsInput | string
    qrImage?: BytesFieldUpdateOperationsInput | Uint8Array
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionedWorkUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    qrCode?: StringFieldUpdateOperationsInput | string
    qrImage?: BytesFieldUpdateOperationsInput | Uint8Array
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartCreateInput = {
    id?: string
    status?: $Enums.CartStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCartsInput
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.CartStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartUpdateInput = {
    status?: EnumCartStatusFieldUpdateOperationsInput | $Enums.CartStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCartsNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumCartStatusFieldUpdateOperationsInput | $Enums.CartStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.CartStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartUpdateManyMutationInput = {
    status?: EnumCartStatusFieldUpdateOperationsInput | $Enums.CartStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumCartStatusFieldUpdateOperationsInput | $Enums.CartStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateInput = {
    id?: string
    quantity: number
    addedAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateInput = {
    id?: string
    cartId: string
    productId: string
    quantity: number
    addedAt?: Date | string
  }

  export type CartItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyInput = {
    id?: string
    cartId: string
    productId: string
    quantity: number
    addedAt?: Date | string
  }

  export type CartItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeCreateInput = {
    id?: string
    code: string
    description: string
    discountType: string
    discountValue: number
    minOrderAmount?: number | null
    maxDiscount?: number | null
    usageLimit?: number | null
    usedCount?: number
    status?: $Enums.PromoCodeStatus
    validFrom: Date | string
    validUntil: Date | string
    createdAt?: Date | string
    orders?: OrderCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUncheckedCreateInput = {
    id?: string
    code: string
    description: string
    discountType: string
    discountValue: number
    minOrderAmount?: number | null
    maxDiscount?: number | null
    usageLimit?: number | null
    usedCount?: number
    status?: $Enums.PromoCodeStatus
    validFrom: Date | string
    validUntil: Date | string
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    minOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPromoCodeStatusFieldUpdateOperationsInput | $Enums.PromoCodeStatus
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    minOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPromoCodeStatusFieldUpdateOperationsInput | $Enums.PromoCodeStatus
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeCreateManyInput = {
    id?: string
    code: string
    description: string
    discountType: string
    discountValue: number
    minOrderAmount?: number | null
    maxDiscount?: number | null
    usageLimit?: number | null
    usedCount?: number
    status?: $Enums.PromoCodeStatus
    validFrom: Date | string
    validUntil: Date | string
    createdAt?: Date | string
  }

  export type PromoCodeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    minOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPromoCodeStatusFieldUpdateOperationsInput | $Enums.PromoCodeStatus
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    minOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPromoCodeStatusFieldUpdateOperationsInput | $Enums.PromoCodeStatus
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditCreateInput = {
    id?: string
    action: string
    resource?: string | null
    details?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutAuditsInput
  }

  export type AuditUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    resource?: string | null
    details?: string | null
    timestamp?: Date | string
  }

  export type AuditUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditsNestedInput
  }

  export type AuditUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditCreateManyInput = {
    id?: string
    userId: string
    action: string
    resource?: string | null
    details?: string | null
    timestamp?: Date | string
  }

  export type AuditUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: string
    message: string
    userId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: string
    message: string
    userId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialLogCreateInput = {
    id?: string
    type: $Enums.FinancialLogType
    amount: number
    description: string
    category?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUser: UserCreateNestedOneWithoutFinancialLogsInput
  }

  export type FinancialLogUncheckedCreateInput = {
    id?: string
    type: $Enums.FinancialLogType
    amount: number
    description: string
    category?: string | null
    reference?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialLogUpdateInput = {
    type?: EnumFinancialLogTypeFieldUpdateOperationsInput | $Enums.FinancialLogType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneRequiredWithoutFinancialLogsNestedInput
  }

  export type FinancialLogUncheckedUpdateInput = {
    type?: EnumFinancialLogTypeFieldUpdateOperationsInput | $Enums.FinancialLogType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialLogCreateManyInput = {
    id?: string
    type: $Enums.FinancialLogType
    amount: number
    description: string
    category?: string | null
    reference?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialLogUpdateManyMutationInput = {
    type?: EnumFinancialLogTypeFieldUpdateOperationsInput | $Enums.FinancialLogType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialLogUncheckedUpdateManyInput = {
    type?: EnumFinancialLogTypeFieldUpdateOperationsInput | $Enums.FinancialLogType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    executiveId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    executiveId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executiveId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executiveId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    executiveId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executiveId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executiveId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DamageReportCreateInput = {
    id?: string
    workerId: string
    reason: string
    quantity: number
    location: string
    reportedAt?: Date | string
    stock: StockCreateNestedOneWithoutDamageReportsInput
  }

  export type DamageReportUncheckedCreateInput = {
    id?: string
    stockId: string
    workerId: string
    reason: string
    quantity: number
    location: string
    reportedAt?: Date | string
  }

  export type DamageReportUpdateInput = {
    workerId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutDamageReportsNestedInput
  }

  export type DamageReportUncheckedUpdateInput = {
    stockId?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DamageReportCreateManyInput = {
    id?: string
    stockId: string
    workerId: string
    reason: string
    quantity: number
    location: string
    reportedAt?: Date | string
  }

  export type DamageReportUpdateManyMutationInput = {
    workerId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DamageReportUncheckedUpdateManyInput = {
    stockId?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone: string
    location: string
    address?: string | null
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: CustomerVisitCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone: string
    location: string
    address?: string | null
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: CustomerVisitUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: CustomerVisitUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: CustomerVisitUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    phone: string
    location: string
    address?: string | null
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerVisitCreateInput = {
    id?: string
    executiveId: string
    visitDate: Date | string
    location: string
    peoplePresent?: string | null
    productsDiscussed?: string | null
    reasonForVisit?: string | null
    customerConcerns?: string | null
    investigationStatus?: string | null
    rootCause?: string | null
    correctiveAction?: string | null
    recommendations?: string | null
    feedback?: string | null
    reportCompletedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutVisitsInput
  }

  export type CustomerVisitUncheckedCreateInput = {
    id?: string
    customerId: string
    executiveId: string
    visitDate: Date | string
    location: string
    peoplePresent?: string | null
    productsDiscussed?: string | null
    reasonForVisit?: string | null
    customerConcerns?: string | null
    investigationStatus?: string | null
    rootCause?: string | null
    correctiveAction?: string | null
    recommendations?: string | null
    feedback?: string | null
    reportCompletedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerVisitUpdateInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    peoplePresent?: NullableStringFieldUpdateOperationsInput | string | null
    productsDiscussed?: NullableStringFieldUpdateOperationsInput | string | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    customerConcerns?: NullableStringFieldUpdateOperationsInput | string | null
    investigationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveAction?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompletedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutVisitsNestedInput
  }

  export type CustomerVisitUncheckedUpdateInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    executiveId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    peoplePresent?: NullableStringFieldUpdateOperationsInput | string | null
    productsDiscussed?: NullableStringFieldUpdateOperationsInput | string | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    customerConcerns?: NullableStringFieldUpdateOperationsInput | string | null
    investigationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveAction?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompletedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerVisitCreateManyInput = {
    id?: string
    customerId: string
    executiveId: string
    visitDate: Date | string
    location: string
    peoplePresent?: string | null
    productsDiscussed?: string | null
    reasonForVisit?: string | null
    customerConcerns?: string | null
    investigationStatus?: string | null
    rootCause?: string | null
    correctiveAction?: string | null
    recommendations?: string | null
    feedback?: string | null
    reportCompletedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerVisitUpdateManyMutationInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    peoplePresent?: NullableStringFieldUpdateOperationsInput | string | null
    productsDiscussed?: NullableStringFieldUpdateOperationsInput | string | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    customerConcerns?: NullableStringFieldUpdateOperationsInput | string | null
    investigationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveAction?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompletedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerVisitUncheckedUpdateManyInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    executiveId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    peoplePresent?: NullableStringFieldUpdateOperationsInput | string | null
    productsDiscussed?: NullableStringFieldUpdateOperationsInput | string | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    customerConcerns?: NullableStringFieldUpdateOperationsInput | string | null
    investigationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveAction?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompletedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver?: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    senderId: string
    receiverId?: string | null
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneWithoutReceivedMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    senderId: string
    receiverId?: string | null
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapturedImageCreateInput = {
    id?: string
    executiveId: string
    imageData: Uint8Array
    latitude?: number | null
    longitude?: number | null
    description?: string | null
    createdAt?: Date | string
  }

  export type CapturedImageUncheckedCreateInput = {
    id?: string
    executiveId: string
    imageData: Uint8Array
    latitude?: number | null
    longitude?: number | null
    description?: string | null
    createdAt?: Date | string
  }

  export type CapturedImageUpdateInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Uint8Array
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapturedImageUncheckedUpdateInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Uint8Array
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapturedImageCreateManyInput = {
    id?: string
    executiveId: string
    imageData: Uint8Array
    latitude?: number | null
    longitude?: number | null
    description?: string | null
    createdAt?: Date | string
  }

  export type CapturedImageUpdateManyMutationInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Uint8Array
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapturedImageUncheckedUpdateManyInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Uint8Array
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureCreateInput = {
    id?: string
    executiveId: string
    signatureData: Uint8Array
    context?: string | null
    createdAt?: Date | string
  }

  export type SignatureUncheckedCreateInput = {
    id?: string
    executiveId: string
    signatureData: Uint8Array
    context?: string | null
    createdAt?: Date | string
  }

  export type SignatureUpdateInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    signatureData?: BytesFieldUpdateOperationsInput | Uint8Array
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureUncheckedUpdateInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    signatureData?: BytesFieldUpdateOperationsInput | Uint8Array
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureCreateManyInput = {
    id?: string
    executiveId: string
    signatureData: Uint8Array
    context?: string | null
    createdAt?: Date | string
  }

  export type SignatureUpdateManyMutationInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    signatureData?: BytesFieldUpdateOperationsInput | Uint8Array
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureUncheckedUpdateManyInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    signatureData?: BytesFieldUpdateOperationsInput | Uint8Array
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfflineDataCreateInput = {
    id?: string
    executiveId: string
    dataType: string
    data: string
    synced?: boolean
    createdAt?: Date | string
    syncedAt?: Date | string | null
  }

  export type OfflineDataUncheckedCreateInput = {
    id?: string
    executiveId: string
    dataType: string
    data: string
    synced?: boolean
    createdAt?: Date | string
    syncedAt?: Date | string | null
  }

  export type OfflineDataUpdateInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfflineDataUncheckedUpdateInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfflineDataCreateManyInput = {
    id?: string
    executiveId: string
    dataType: string
    data: string
    synced?: boolean
    createdAt?: Date | string
    syncedAt?: Date | string | null
  }

  export type OfflineDataUpdateManyMutationInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfflineDataUncheckedUpdateManyInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type SalesManagerNullableScalarRelationFilter = {
    is?: SalesManagerWhereInput | null
    isNot?: SalesManagerWhereInput | null
  }

  export type PlumberNullableScalarRelationFilter = {
    is?: PlumberWhereInput | null
    isNot?: PlumberWhereInput | null
  }

  export type AccountantNullableScalarRelationFilter = {
    is?: AccountantWhereInput | null
    isNot?: AccountantWhereInput | null
  }

  export type DistributorNullableScalarRelationFilter = {
    is?: DistributorWhereInput | null
    isNot?: DistributorWhereInput | null
  }

  export type FieldExecutiveNullableScalarRelationFilter = {
    is?: FieldExecutiveWhereInput | null
    isNot?: FieldExecutiveWhereInput | null
  }

  export type WorkerNullableScalarRelationFilter = {
    is?: WorkerWhereInput | null
    isNot?: WorkerWhereInput | null
  }

  export type PlumberAccountProfileNullableScalarRelationFilter = {
    is?: PlumberAccountProfileWhereInput | null
    isNot?: PlumberAccountProfileWhereInput | null
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type PointTransactionListRelationFilter = {
    every?: PointTransactionWhereInput
    some?: PointTransactionWhereInput
    none?: PointTransactionWhereInput
  }

  export type IncentiveListRelationFilter = {
    every?: IncentiveWhereInput
    some?: IncentiveWhereInput
    none?: IncentiveWhereInput
  }

  export type DeliveryReportListRelationFilter = {
    every?: DeliveryReportWhereInput
    some?: DeliveryReportWhereInput
    none?: DeliveryReportWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type LiveLocationListRelationFilter = {
    every?: LiveLocationWhereInput
    some?: LiveLocationWhereInput
    none?: LiveLocationWhereInput
  }

  export type ShiftAlertListRelationFilter = {
    every?: ShiftAlertWhereInput
    some?: ShiftAlertWhereInput
    none?: ShiftAlertWhereInput
  }

  export type RegisterWarrantyListRelationFilter = {
    every?: RegisterWarrantyWhereInput
    some?: RegisterWarrantyWhereInput
    none?: RegisterWarrantyWhereInput
  }

  export type PostDeliveryReportListRelationFilter = {
    every?: PostDeliveryReportWhereInput
    some?: PostDeliveryReportWhereInput
    none?: PostDeliveryReportWhereInput
  }

  export type CommissionedWorkListRelationFilter = {
    every?: CommissionedWorkWhereInput
    some?: CommissionedWorkWhereInput
    none?: CommissionedWorkWhereInput
  }

  export type CartListRelationFilter = {
    every?: CartWhereInput
    some?: CartWhereInput
    none?: CartWhereInput
  }

  export type AuditListRelationFilter = {
    every?: AuditWhereInput
    some?: AuditWhereInput
    none?: AuditWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type FinancialLogListRelationFilter = {
    every?: FinancialLogWhereInput
    some?: FinancialLogWhereInput
    none?: FinancialLogWhereInput
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PointTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncentiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiveLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegisterWarrantyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostDeliveryReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommissionedWorkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type SalesManagerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SalesManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SalesManagerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PlumberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PlumberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PlumberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PlumberAccountProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    contactNumber?: SortOrder
    upiId?: SortOrder
    upiQrUrl?: SortOrder
    email?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountHolderName?: SortOrder
    ifscCode?: SortOrder
    branchName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlumberAccountProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    contactNumber?: SortOrder
    upiId?: SortOrder
    upiQrUrl?: SortOrder
    email?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountHolderName?: SortOrder
    ifscCode?: SortOrder
    branchName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlumberAccountProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    contactNumber?: SortOrder
    upiId?: SortOrder
    upiQrUrl?: SortOrder
    email?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountHolderName?: SortOrder
    ifscCode?: SortOrder
    branchName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountantCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AccountantMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AccountantMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DistributorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DistributorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DistributorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CustomerFollowUpListRelationFilter = {
    every?: CustomerFollowUpWhereInput
    some?: CustomerFollowUpWhereInput
    none?: CustomerFollowUpWhereInput
  }

  export type DVRListRelationFilter = {
    every?: DVRWhereInput
    some?: DVRWhereInput
    none?: DVRWhereInput
  }

  export type CustomerFollowUpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DVROrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FieldExecutiveCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FieldExecutiveMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FieldExecutiveMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type WorkerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type WorkerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type WorkerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StockListRelationFilter = {
    every?: StockWhereInput
    some?: StockWhereInput
    none?: StockWhereInput
  }

  export type WarrantyCardListRelationFilter = {
    every?: WarrantyCardWhereInput
    some?: WarrantyCardWhereInput
    none?: WarrantyCardWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type CartItemListRelationFilter = {
    every?: CartItemWhereInput
    some?: CartItemWhereInput
    none?: CartItemWhereInput
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type StockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarrantyCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    stockQuantity?: SortOrder
    warrantyPeriodInMonths?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    stockQuantity?: SortOrder
    warrantyPeriodInMonths?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    stockQuantity?: SortOrder
    warrantyPeriodInMonths?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    stockQuantity?: SortOrder
    warrantyPeriodInMonths?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    stockQuantity?: SortOrder
    warrantyPeriodInMonths?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumStockStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StockStatus | EnumStockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockStatus[] | ListEnumStockStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockStatus[] | ListEnumStockStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStockStatusFilter<$PrismaModel> | $Enums.StockStatus
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type DamageReportListRelationFilter = {
    every?: DamageReportWhereInput
    some?: DamageReportWhereInput
    none?: DamageReportWhereInput
  }

  export type DamageReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    status?: SortOrder
    location?: SortOrder
  }

  export type StockMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    status?: SortOrder
    location?: SortOrder
  }

  export type StockMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    status?: SortOrder
    location?: SortOrder
  }

  export type EnumStockStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockStatus | EnumStockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockStatus[] | ListEnumStockStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockStatus[] | ListEnumStockStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStockStatusWithAggregatesFilter<$PrismaModel> | $Enums.StockStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockStatusFilter<$PrismaModel>
    _max?: NestedEnumStockStatusFilter<$PrismaModel>
  }

  export type WarrantyCardCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    scanQR?: SortOrder
    validViaWarranIQ?: SortOrder
  }

  export type WarrantyCardMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    scanQR?: SortOrder
    validViaWarranIQ?: SortOrder
  }

  export type WarrantyCardMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    scanQR?: SortOrder
    validViaWarranIQ?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumFollowUpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowUpStatus | EnumFollowUpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowUpStatusFilter<$PrismaModel> | $Enums.FollowUpStatus
  }

  export type FieldExecutiveScalarRelationFilter = {
    is?: FieldExecutiveWhereInput
    isNot?: FieldExecutiveWhereInput
  }

  export type CustomerFollowUpCountOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    customerName?: SortOrder
    contactDetails?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    nextFollowUpDate?: SortOrder
  }

  export type CustomerFollowUpMaxOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    customerName?: SortOrder
    contactDetails?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    nextFollowUpDate?: SortOrder
  }

  export type CustomerFollowUpMinOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    customerName?: SortOrder
    contactDetails?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    nextFollowUpDate?: SortOrder
  }

  export type EnumFollowUpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowUpStatus | EnumFollowUpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowUpStatusWithAggregatesFilter<$PrismaModel> | $Enums.FollowUpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFollowUpStatusFilter<$PrismaModel>
    _max?: NestedEnumFollowUpStatusFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type PointTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    creditAmount?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    type?: SortOrder
  }

  export type PointTransactionAvgOrderByAggregateInput = {
    points?: SortOrder
    creditAmount?: SortOrder
  }

  export type PointTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    creditAmount?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    type?: SortOrder
  }

  export type PointTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    creditAmount?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    type?: SortOrder
  }

  export type PointTransactionSumOrderByAggregateInput = {
    points?: SortOrder
    creditAmount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type IncentiveCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    points?: SortOrder
    assignedId?: SortOrder
    assignedAt?: SortOrder
  }

  export type IncentiveAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type IncentiveMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    points?: SortOrder
    assignedId?: SortOrder
    assignedAt?: SortOrder
  }

  export type IncentiveMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    points?: SortOrder
    assignedId?: SortOrder
    assignedAt?: SortOrder
  }

  export type IncentiveSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type DVRCountOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    feedback?: SortOrder
    location?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
  }

  export type DVRMaxOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    feedback?: SortOrder
    location?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
  }

  export type DVRMinOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    feedback?: SortOrder
    location?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
  }

  export type DeliveryReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    product?: SortOrder
    quantity?: SortOrder
    isForecasted?: SortOrder
    qrRequested?: SortOrder
    submittedAt?: SortOrder
  }

  export type DeliveryReportAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type DeliveryReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    product?: SortOrder
    quantity?: SortOrder
    isForecasted?: SortOrder
    qrRequested?: SortOrder
    submittedAt?: SortOrder
  }

  export type DeliveryReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    product?: SortOrder
    quantity?: SortOrder
    isForecasted?: SortOrder
    qrRequested?: SortOrder
    submittedAt?: SortOrder
  }

  export type DeliveryReportSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PromoCodeNullableScalarRelationFilter = {
    is?: PromoCodeWhereInput | null
    isNot?: PromoCodeWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    promoCodeId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    promoCodeId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    promoCodeId?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    invoiceDate?: SortOrder
    totalAmount?: SortOrder
    pdfUrl?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    paidAt?: SortOrder
    dueDate?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    invoiceDate?: SortOrder
    totalAmount?: SortOrder
    pdfUrl?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    paidAt?: SortOrder
    dueDate?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    invoiceDate?: SortOrder
    totalAmount?: SortOrder
    pdfUrl?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    paidAt?: SortOrder
    dueDate?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type LiveLocationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timeStamp?: SortOrder
  }

  export type LiveLocationAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LiveLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timeStamp?: SortOrder
  }

  export type LiveLocationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timeStamp?: SortOrder
  }

  export type LiveLocationSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type ShiftAlertCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    acknowledged?: SortOrder
  }

  export type ShiftAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    acknowledged?: SortOrder
  }

  export type ShiftAlertMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    acknowledged?: SortOrder
  }

  export type RegisterWarrantyCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    warrantyMonths?: SortOrder
    sellerId?: SortOrder
    registeredAt?: SortOrder
    qrImage?: SortOrder
  }

  export type RegisterWarrantyAvgOrderByAggregateInput = {
    warrantyMonths?: SortOrder
  }

  export type RegisterWarrantyMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    warrantyMonths?: SortOrder
    sellerId?: SortOrder
    registeredAt?: SortOrder
    qrImage?: SortOrder
  }

  export type RegisterWarrantyMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    warrantyMonths?: SortOrder
    sellerId?: SortOrder
    registeredAt?: SortOrder
    qrImage?: SortOrder
  }

  export type RegisterWarrantySumOrderByAggregateInput = {
    warrantyMonths?: SortOrder
  }

  export type PostDeliveryReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    product?: SortOrder
    quantity?: SortOrder
    submittedAt?: SortOrder
  }

  export type PostDeliveryReportAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type PostDeliveryReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    product?: SortOrder
    quantity?: SortOrder
    submittedAt?: SortOrder
  }

  export type PostDeliveryReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    product?: SortOrder
    quantity?: SortOrder
    submittedAt?: SortOrder
  }

  export type PostDeliveryReportSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type CommissionedWorkCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    qrCode?: SortOrder
    qrImage?: SortOrder
    appliedAt?: SortOrder
  }

  export type CommissionedWorkAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type CommissionedWorkMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    qrCode?: SortOrder
    qrImage?: SortOrder
    appliedAt?: SortOrder
  }

  export type CommissionedWorkMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    qrCode?: SortOrder
    qrImage?: SortOrder
    appliedAt?: SortOrder
  }

  export type CommissionedWorkSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCartStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CartStatus | EnumCartStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CartStatus[] | ListEnumCartStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CartStatus[] | ListEnumCartStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCartStatusFilter<$PrismaModel> | $Enums.CartStatus
  }

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCartStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CartStatus | EnumCartStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CartStatus[] | ListEnumCartStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CartStatus[] | ListEnumCartStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCartStatusWithAggregatesFilter<$PrismaModel> | $Enums.CartStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCartStatusFilter<$PrismaModel>
    _max?: NestedEnumCartStatusFilter<$PrismaModel>
  }

  export type CartScalarRelationFilter = {
    is?: CartWhereInput
    isNot?: CartWhereInput
  }

  export type CartItemCountOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    addedAt?: SortOrder
  }

  export type CartItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CartItemMaxOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    addedAt?: SortOrder
  }

  export type CartItemMinOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    addedAt?: SortOrder
  }

  export type CartItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type EnumPromoCodeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoCodeStatus | EnumPromoCodeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PromoCodeStatus[] | ListEnumPromoCodeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromoCodeStatus[] | ListEnumPromoCodeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPromoCodeStatusFilter<$PrismaModel> | $Enums.PromoCodeStatus
  }

  export type PromoCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minOrderAmount?: SortOrder
    maxDiscount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    status?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeAvgOrderByAggregateInput = {
    discountValue?: SortOrder
    minOrderAmount?: SortOrder
    maxDiscount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
  }

  export type PromoCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minOrderAmount?: SortOrder
    maxDiscount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    status?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minOrderAmount?: SortOrder
    maxDiscount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    status?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeSumOrderByAggregateInput = {
    discountValue?: SortOrder
    minOrderAmount?: SortOrder
    maxDiscount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumPromoCodeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoCodeStatus | EnumPromoCodeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PromoCodeStatus[] | ListEnumPromoCodeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromoCodeStatus[] | ListEnumPromoCodeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPromoCodeStatusWithAggregatesFilter<$PrismaModel> | $Enums.PromoCodeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromoCodeStatusFilter<$PrismaModel>
    _max?: NestedEnumPromoCodeStatusFilter<$PrismaModel>
  }

  export type AuditCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFinancialLogTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialLogType | EnumFinancialLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialLogType[] | ListEnumFinancialLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialLogType[] | ListEnumFinancialLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialLogTypeFilter<$PrismaModel> | $Enums.FinancialLogType
  }

  export type FinancialLogCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    category?: SortOrder
    reference?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialLogAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FinancialLogMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    category?: SortOrder
    reference?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialLogMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    category?: SortOrder
    reference?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialLogSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumFinancialLogTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialLogType | EnumFinancialLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialLogType[] | ListEnumFinancialLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialLogType[] | ListEnumFinancialLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialLogTypeWithAggregatesFilter<$PrismaModel> | $Enums.FinancialLogType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinancialLogTypeFilter<$PrismaModel>
    _max?: NestedEnumFinancialLogTypeFilter<$PrismaModel>
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    executiveId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    executiveId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    executiveId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type StockScalarRelationFilter = {
    is?: StockWhereInput
    isNot?: StockWhereInput
  }

  export type DamageReportCountOrderByAggregateInput = {
    id?: SortOrder
    stockId?: SortOrder
    workerId?: SortOrder
    reason?: SortOrder
    quantity?: SortOrder
    location?: SortOrder
    reportedAt?: SortOrder
  }

  export type DamageReportAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type DamageReportMaxOrderByAggregateInput = {
    id?: SortOrder
    stockId?: SortOrder
    workerId?: SortOrder
    reason?: SortOrder
    quantity?: SortOrder
    location?: SortOrder
    reportedAt?: SortOrder
  }

  export type DamageReportMinOrderByAggregateInput = {
    id?: SortOrder
    stockId?: SortOrder
    workerId?: SortOrder
    reason?: SortOrder
    quantity?: SortOrder
    location?: SortOrder
    reportedAt?: SortOrder
  }

  export type DamageReportSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CustomerVisitListRelationFilter = {
    every?: CustomerVisitWhereInput
    some?: CustomerVisitWhereInput
    none?: CustomerVisitWhereInput
  }

  export type CustomerVisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    address?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    address?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    address?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type CustomerVisitCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    executiveId?: SortOrder
    visitDate?: SortOrder
    location?: SortOrder
    peoplePresent?: SortOrder
    productsDiscussed?: SortOrder
    reasonForVisit?: SortOrder
    customerConcerns?: SortOrder
    investigationStatus?: SortOrder
    rootCause?: SortOrder
    correctiveAction?: SortOrder
    recommendations?: SortOrder
    feedback?: SortOrder
    reportCompletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerVisitMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    executiveId?: SortOrder
    visitDate?: SortOrder
    location?: SortOrder
    peoplePresent?: SortOrder
    productsDiscussed?: SortOrder
    reasonForVisit?: SortOrder
    customerConcerns?: SortOrder
    investigationStatus?: SortOrder
    rootCause?: SortOrder
    correctiveAction?: SortOrder
    recommendations?: SortOrder
    feedback?: SortOrder
    reportCompletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerVisitMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    executiveId?: SortOrder
    visitDate?: SortOrder
    location?: SortOrder
    peoplePresent?: SortOrder
    productsDiscussed?: SortOrder
    reasonForVisit?: SortOrder
    customerConcerns?: SortOrder
    investigationStatus?: SortOrder
    rootCause?: SortOrder
    correctiveAction?: SortOrder
    recommendations?: SortOrder
    feedback?: SortOrder
    reportCompletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type CapturedImageCountOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    imageData?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type CapturedImageAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type CapturedImageMaxOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    imageData?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type CapturedImageMinOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    imageData?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type CapturedImageSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type SignatureCountOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    signatureData?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
  }

  export type SignatureMaxOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    signatureData?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
  }

  export type SignatureMinOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    signatureData?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
  }

  export type OfflineDataCountOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    dataType?: SortOrder
    data?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    syncedAt?: SortOrder
  }

  export type OfflineDataMaxOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    dataType?: SortOrder
    data?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    syncedAt?: SortOrder
  }

  export type OfflineDataMinOrderByAggregateInput = {
    id?: SortOrder
    executiveId?: SortOrder
    dataType?: SortOrder
    data?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    syncedAt?: SortOrder
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type SalesManagerCreateNestedOneWithoutUserInput = {
    create?: XOR<SalesManagerCreateWithoutUserInput, SalesManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: SalesManagerCreateOrConnectWithoutUserInput
    connect?: SalesManagerWhereUniqueInput
  }

  export type PlumberCreateNestedOneWithoutUserInput = {
    create?: XOR<PlumberCreateWithoutUserInput, PlumberUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlumberCreateOrConnectWithoutUserInput
    connect?: PlumberWhereUniqueInput
  }

  export type AccountantCreateNestedOneWithoutUserInput = {
    create?: XOR<AccountantCreateWithoutUserInput, AccountantUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountantCreateOrConnectWithoutUserInput
    connect?: AccountantWhereUniqueInput
  }

  export type DistributorCreateNestedOneWithoutUserInput = {
    create?: XOR<DistributorCreateWithoutUserInput, DistributorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutUserInput
    connect?: DistributorWhereUniqueInput
  }

  export type FieldExecutiveCreateNestedOneWithoutUserInput = {
    create?: XOR<FieldExecutiveCreateWithoutUserInput, FieldExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutUserInput
    connect?: FieldExecutiveWhereUniqueInput
  }

  export type WorkerCreateNestedOneWithoutUserInput = {
    create?: XOR<WorkerCreateWithoutUserInput, WorkerUncheckedCreateWithoutUserInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutUserInput
    connect?: WorkerWhereUniqueInput
  }

  export type PlumberAccountProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<PlumberAccountProfileCreateWithoutUserInput, PlumberAccountProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlumberAccountProfileCreateOrConnectWithoutUserInput
    connect?: PlumberAccountProfileWhereUniqueInput
  }

  export type AttendanceCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type PointTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<PointTransactionCreateWithoutUserInput, PointTransactionUncheckedCreateWithoutUserInput> | PointTransactionCreateWithoutUserInput[] | PointTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutUserInput | PointTransactionCreateOrConnectWithoutUserInput[]
    createMany?: PointTransactionCreateManyUserInputEnvelope
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
  }

  export type IncentiveCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<IncentiveCreateWithoutAssignedToInput, IncentiveUncheckedCreateWithoutAssignedToInput> | IncentiveCreateWithoutAssignedToInput[] | IncentiveUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: IncentiveCreateOrConnectWithoutAssignedToInput | IncentiveCreateOrConnectWithoutAssignedToInput[]
    createMany?: IncentiveCreateManyAssignedToInputEnvelope
    connect?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
  }

  export type DeliveryReportCreateNestedManyWithoutUserInput = {
    create?: XOR<DeliveryReportCreateWithoutUserInput, DeliveryReportUncheckedCreateWithoutUserInput> | DeliveryReportCreateWithoutUserInput[] | DeliveryReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeliveryReportCreateOrConnectWithoutUserInput | DeliveryReportCreateOrConnectWithoutUserInput[]
    createMany?: DeliveryReportCreateManyUserInputEnvelope
    connect?: DeliveryReportWhereUniqueInput | DeliveryReportWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type LiveLocationCreateNestedManyWithoutUserInput = {
    create?: XOR<LiveLocationCreateWithoutUserInput, LiveLocationUncheckedCreateWithoutUserInput> | LiveLocationCreateWithoutUserInput[] | LiveLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LiveLocationCreateOrConnectWithoutUserInput | LiveLocationCreateOrConnectWithoutUserInput[]
    createMany?: LiveLocationCreateManyUserInputEnvelope
    connect?: LiveLocationWhereUniqueInput | LiveLocationWhereUniqueInput[]
  }

  export type ShiftAlertCreateNestedManyWithoutUserInput = {
    create?: XOR<ShiftAlertCreateWithoutUserInput, ShiftAlertUncheckedCreateWithoutUserInput> | ShiftAlertCreateWithoutUserInput[] | ShiftAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftAlertCreateOrConnectWithoutUserInput | ShiftAlertCreateOrConnectWithoutUserInput[]
    createMany?: ShiftAlertCreateManyUserInputEnvelope
    connect?: ShiftAlertWhereUniqueInput | ShiftAlertWhereUniqueInput[]
  }

  export type RegisterWarrantyCreateNestedManyWithoutSellerInput = {
    create?: XOR<RegisterWarrantyCreateWithoutSellerInput, RegisterWarrantyUncheckedCreateWithoutSellerInput> | RegisterWarrantyCreateWithoutSellerInput[] | RegisterWarrantyUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: RegisterWarrantyCreateOrConnectWithoutSellerInput | RegisterWarrantyCreateOrConnectWithoutSellerInput[]
    createMany?: RegisterWarrantyCreateManySellerInputEnvelope
    connect?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
  }

  export type PostDeliveryReportCreateNestedManyWithoutUserInput = {
    create?: XOR<PostDeliveryReportCreateWithoutUserInput, PostDeliveryReportUncheckedCreateWithoutUserInput> | PostDeliveryReportCreateWithoutUserInput[] | PostDeliveryReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostDeliveryReportCreateOrConnectWithoutUserInput | PostDeliveryReportCreateOrConnectWithoutUserInput[]
    createMany?: PostDeliveryReportCreateManyUserInputEnvelope
    connect?: PostDeliveryReportWhereUniqueInput | PostDeliveryReportWhereUniqueInput[]
  }

  export type CommissionedWorkCreateNestedManyWithoutUserInput = {
    create?: XOR<CommissionedWorkCreateWithoutUserInput, CommissionedWorkUncheckedCreateWithoutUserInput> | CommissionedWorkCreateWithoutUserInput[] | CommissionedWorkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommissionedWorkCreateOrConnectWithoutUserInput | CommissionedWorkCreateOrConnectWithoutUserInput[]
    createMany?: CommissionedWorkCreateManyUserInputEnvelope
    connect?: CommissionedWorkWhereUniqueInput | CommissionedWorkWhereUniqueInput[]
  }

  export type CartCreateNestedManyWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type AuditCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditCreateWithoutUserInput, AuditUncheckedCreateWithoutUserInput> | AuditCreateWithoutUserInput[] | AuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutUserInput | AuditCreateOrConnectWithoutUserInput[]
    createMany?: AuditCreateManyUserInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FinancialLogCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<FinancialLogCreateWithoutCreatedByUserInput, FinancialLogUncheckedCreateWithoutCreatedByUserInput> | FinancialLogCreateWithoutCreatedByUserInput[] | FinancialLogUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: FinancialLogCreateOrConnectWithoutCreatedByUserInput | FinancialLogCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: FinancialLogCreateManyCreatedByUserInputEnvelope
    connect?: FinancialLogWhereUniqueInput | FinancialLogWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type SalesManagerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SalesManagerCreateWithoutUserInput, SalesManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: SalesManagerCreateOrConnectWithoutUserInput
    connect?: SalesManagerWhereUniqueInput
  }

  export type PlumberUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PlumberCreateWithoutUserInput, PlumberUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlumberCreateOrConnectWithoutUserInput
    connect?: PlumberWhereUniqueInput
  }

  export type AccountantUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AccountantCreateWithoutUserInput, AccountantUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountantCreateOrConnectWithoutUserInput
    connect?: AccountantWhereUniqueInput
  }

  export type DistributorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DistributorCreateWithoutUserInput, DistributorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutUserInput
    connect?: DistributorWhereUniqueInput
  }

  export type FieldExecutiveUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<FieldExecutiveCreateWithoutUserInput, FieldExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutUserInput
    connect?: FieldExecutiveWhereUniqueInput
  }

  export type WorkerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WorkerCreateWithoutUserInput, WorkerUncheckedCreateWithoutUserInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutUserInput
    connect?: WorkerWhereUniqueInput
  }

  export type PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PlumberAccountProfileCreateWithoutUserInput, PlumberAccountProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlumberAccountProfileCreateOrConnectWithoutUserInput
    connect?: PlumberAccountProfileWhereUniqueInput
  }

  export type AttendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type PointTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PointTransactionCreateWithoutUserInput, PointTransactionUncheckedCreateWithoutUserInput> | PointTransactionCreateWithoutUserInput[] | PointTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutUserInput | PointTransactionCreateOrConnectWithoutUserInput[]
    createMany?: PointTransactionCreateManyUserInputEnvelope
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
  }

  export type IncentiveUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<IncentiveCreateWithoutAssignedToInput, IncentiveUncheckedCreateWithoutAssignedToInput> | IncentiveCreateWithoutAssignedToInput[] | IncentiveUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: IncentiveCreateOrConnectWithoutAssignedToInput | IncentiveCreateOrConnectWithoutAssignedToInput[]
    createMany?: IncentiveCreateManyAssignedToInputEnvelope
    connect?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
  }

  export type DeliveryReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeliveryReportCreateWithoutUserInput, DeliveryReportUncheckedCreateWithoutUserInput> | DeliveryReportCreateWithoutUserInput[] | DeliveryReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeliveryReportCreateOrConnectWithoutUserInput | DeliveryReportCreateOrConnectWithoutUserInput[]
    createMany?: DeliveryReportCreateManyUserInputEnvelope
    connect?: DeliveryReportWhereUniqueInput | DeliveryReportWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type LiveLocationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LiveLocationCreateWithoutUserInput, LiveLocationUncheckedCreateWithoutUserInput> | LiveLocationCreateWithoutUserInput[] | LiveLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LiveLocationCreateOrConnectWithoutUserInput | LiveLocationCreateOrConnectWithoutUserInput[]
    createMany?: LiveLocationCreateManyUserInputEnvelope
    connect?: LiveLocationWhereUniqueInput | LiveLocationWhereUniqueInput[]
  }

  export type ShiftAlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShiftAlertCreateWithoutUserInput, ShiftAlertUncheckedCreateWithoutUserInput> | ShiftAlertCreateWithoutUserInput[] | ShiftAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftAlertCreateOrConnectWithoutUserInput | ShiftAlertCreateOrConnectWithoutUserInput[]
    createMany?: ShiftAlertCreateManyUserInputEnvelope
    connect?: ShiftAlertWhereUniqueInput | ShiftAlertWhereUniqueInput[]
  }

  export type RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<RegisterWarrantyCreateWithoutSellerInput, RegisterWarrantyUncheckedCreateWithoutSellerInput> | RegisterWarrantyCreateWithoutSellerInput[] | RegisterWarrantyUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: RegisterWarrantyCreateOrConnectWithoutSellerInput | RegisterWarrantyCreateOrConnectWithoutSellerInput[]
    createMany?: RegisterWarrantyCreateManySellerInputEnvelope
    connect?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
  }

  export type PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostDeliveryReportCreateWithoutUserInput, PostDeliveryReportUncheckedCreateWithoutUserInput> | PostDeliveryReportCreateWithoutUserInput[] | PostDeliveryReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostDeliveryReportCreateOrConnectWithoutUserInput | PostDeliveryReportCreateOrConnectWithoutUserInput[]
    createMany?: PostDeliveryReportCreateManyUserInputEnvelope
    connect?: PostDeliveryReportWhereUniqueInput | PostDeliveryReportWhereUniqueInput[]
  }

  export type CommissionedWorkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommissionedWorkCreateWithoutUserInput, CommissionedWorkUncheckedCreateWithoutUserInput> | CommissionedWorkCreateWithoutUserInput[] | CommissionedWorkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommissionedWorkCreateOrConnectWithoutUserInput | CommissionedWorkCreateOrConnectWithoutUserInput[]
    createMany?: CommissionedWorkCreateManyUserInputEnvelope
    connect?: CommissionedWorkWhereUniqueInput | CommissionedWorkWhereUniqueInput[]
  }

  export type CartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type AuditUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditCreateWithoutUserInput, AuditUncheckedCreateWithoutUserInput> | AuditCreateWithoutUserInput[] | AuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutUserInput | AuditCreateOrConnectWithoutUserInput[]
    createMany?: AuditCreateManyUserInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<FinancialLogCreateWithoutCreatedByUserInput, FinancialLogUncheckedCreateWithoutCreatedByUserInput> | FinancialLogCreateWithoutCreatedByUserInput[] | FinancialLogUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: FinancialLogCreateOrConnectWithoutCreatedByUserInput | FinancialLogCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: FinancialLogCreateManyCreatedByUserInputEnvelope
    connect?: FinancialLogWhereUniqueInput | FinancialLogWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type SalesManagerUpdateOneWithoutUserNestedInput = {
    create?: XOR<SalesManagerCreateWithoutUserInput, SalesManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: SalesManagerCreateOrConnectWithoutUserInput
    upsert?: SalesManagerUpsertWithoutUserInput
    disconnect?: SalesManagerWhereInput | boolean
    delete?: SalesManagerWhereInput | boolean
    connect?: SalesManagerWhereUniqueInput
    update?: XOR<XOR<SalesManagerUpdateToOneWithWhereWithoutUserInput, SalesManagerUpdateWithoutUserInput>, SalesManagerUncheckedUpdateWithoutUserInput>
  }

  export type PlumberUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlumberCreateWithoutUserInput, PlumberUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlumberCreateOrConnectWithoutUserInput
    upsert?: PlumberUpsertWithoutUserInput
    disconnect?: PlumberWhereInput | boolean
    delete?: PlumberWhereInput | boolean
    connect?: PlumberWhereUniqueInput
    update?: XOR<XOR<PlumberUpdateToOneWithWhereWithoutUserInput, PlumberUpdateWithoutUserInput>, PlumberUncheckedUpdateWithoutUserInput>
  }

  export type AccountantUpdateOneWithoutUserNestedInput = {
    create?: XOR<AccountantCreateWithoutUserInput, AccountantUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountantCreateOrConnectWithoutUserInput
    upsert?: AccountantUpsertWithoutUserInput
    disconnect?: AccountantWhereInput | boolean
    delete?: AccountantWhereInput | boolean
    connect?: AccountantWhereUniqueInput
    update?: XOR<XOR<AccountantUpdateToOneWithWhereWithoutUserInput, AccountantUpdateWithoutUserInput>, AccountantUncheckedUpdateWithoutUserInput>
  }

  export type DistributorUpdateOneWithoutUserNestedInput = {
    create?: XOR<DistributorCreateWithoutUserInput, DistributorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutUserInput
    upsert?: DistributorUpsertWithoutUserInput
    disconnect?: DistributorWhereInput | boolean
    delete?: DistributorWhereInput | boolean
    connect?: DistributorWhereUniqueInput
    update?: XOR<XOR<DistributorUpdateToOneWithWhereWithoutUserInput, DistributorUpdateWithoutUserInput>, DistributorUncheckedUpdateWithoutUserInput>
  }

  export type FieldExecutiveUpdateOneWithoutUserNestedInput = {
    create?: XOR<FieldExecutiveCreateWithoutUserInput, FieldExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutUserInput
    upsert?: FieldExecutiveUpsertWithoutUserInput
    disconnect?: FieldExecutiveWhereInput | boolean
    delete?: FieldExecutiveWhereInput | boolean
    connect?: FieldExecutiveWhereUniqueInput
    update?: XOR<XOR<FieldExecutiveUpdateToOneWithWhereWithoutUserInput, FieldExecutiveUpdateWithoutUserInput>, FieldExecutiveUncheckedUpdateWithoutUserInput>
  }

  export type WorkerUpdateOneWithoutUserNestedInput = {
    create?: XOR<WorkerCreateWithoutUserInput, WorkerUncheckedCreateWithoutUserInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutUserInput
    upsert?: WorkerUpsertWithoutUserInput
    disconnect?: WorkerWhereInput | boolean
    delete?: WorkerWhereInput | boolean
    connect?: WorkerWhereUniqueInput
    update?: XOR<XOR<WorkerUpdateToOneWithWhereWithoutUserInput, WorkerUpdateWithoutUserInput>, WorkerUncheckedUpdateWithoutUserInput>
  }

  export type PlumberAccountProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlumberAccountProfileCreateWithoutUserInput, PlumberAccountProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlumberAccountProfileCreateOrConnectWithoutUserInput
    upsert?: PlumberAccountProfileUpsertWithoutUserInput
    disconnect?: PlumberAccountProfileWhereInput | boolean
    delete?: PlumberAccountProfileWhereInput | boolean
    connect?: PlumberAccountProfileWhereUniqueInput
    update?: XOR<XOR<PlumberAccountProfileUpdateToOneWithWhereWithoutUserInput, PlumberAccountProfileUpdateWithoutUserInput>, PlumberAccountProfileUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type PointTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointTransactionCreateWithoutUserInput, PointTransactionUncheckedCreateWithoutUserInput> | PointTransactionCreateWithoutUserInput[] | PointTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutUserInput | PointTransactionCreateOrConnectWithoutUserInput[]
    upsert?: PointTransactionUpsertWithWhereUniqueWithoutUserInput | PointTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointTransactionCreateManyUserInputEnvelope
    set?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    disconnect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    delete?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    update?: PointTransactionUpdateWithWhereUniqueWithoutUserInput | PointTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointTransactionUpdateManyWithWhereWithoutUserInput | PointTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
  }

  export type IncentiveUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<IncentiveCreateWithoutAssignedToInput, IncentiveUncheckedCreateWithoutAssignedToInput> | IncentiveCreateWithoutAssignedToInput[] | IncentiveUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: IncentiveCreateOrConnectWithoutAssignedToInput | IncentiveCreateOrConnectWithoutAssignedToInput[]
    upsert?: IncentiveUpsertWithWhereUniqueWithoutAssignedToInput | IncentiveUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: IncentiveCreateManyAssignedToInputEnvelope
    set?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    disconnect?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    delete?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    connect?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    update?: IncentiveUpdateWithWhereUniqueWithoutAssignedToInput | IncentiveUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: IncentiveUpdateManyWithWhereWithoutAssignedToInput | IncentiveUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: IncentiveScalarWhereInput | IncentiveScalarWhereInput[]
  }

  export type DeliveryReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeliveryReportCreateWithoutUserInput, DeliveryReportUncheckedCreateWithoutUserInput> | DeliveryReportCreateWithoutUserInput[] | DeliveryReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeliveryReportCreateOrConnectWithoutUserInput | DeliveryReportCreateOrConnectWithoutUserInput[]
    upsert?: DeliveryReportUpsertWithWhereUniqueWithoutUserInput | DeliveryReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeliveryReportCreateManyUserInputEnvelope
    set?: DeliveryReportWhereUniqueInput | DeliveryReportWhereUniqueInput[]
    disconnect?: DeliveryReportWhereUniqueInput | DeliveryReportWhereUniqueInput[]
    delete?: DeliveryReportWhereUniqueInput | DeliveryReportWhereUniqueInput[]
    connect?: DeliveryReportWhereUniqueInput | DeliveryReportWhereUniqueInput[]
    update?: DeliveryReportUpdateWithWhereUniqueWithoutUserInput | DeliveryReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeliveryReportUpdateManyWithWhereWithoutUserInput | DeliveryReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeliveryReportScalarWhereInput | DeliveryReportScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type LiveLocationUpdateManyWithoutUserNestedInput = {
    create?: XOR<LiveLocationCreateWithoutUserInput, LiveLocationUncheckedCreateWithoutUserInput> | LiveLocationCreateWithoutUserInput[] | LiveLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LiveLocationCreateOrConnectWithoutUserInput | LiveLocationCreateOrConnectWithoutUserInput[]
    upsert?: LiveLocationUpsertWithWhereUniqueWithoutUserInput | LiveLocationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LiveLocationCreateManyUserInputEnvelope
    set?: LiveLocationWhereUniqueInput | LiveLocationWhereUniqueInput[]
    disconnect?: LiveLocationWhereUniqueInput | LiveLocationWhereUniqueInput[]
    delete?: LiveLocationWhereUniqueInput | LiveLocationWhereUniqueInput[]
    connect?: LiveLocationWhereUniqueInput | LiveLocationWhereUniqueInput[]
    update?: LiveLocationUpdateWithWhereUniqueWithoutUserInput | LiveLocationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LiveLocationUpdateManyWithWhereWithoutUserInput | LiveLocationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LiveLocationScalarWhereInput | LiveLocationScalarWhereInput[]
  }

  export type ShiftAlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShiftAlertCreateWithoutUserInput, ShiftAlertUncheckedCreateWithoutUserInput> | ShiftAlertCreateWithoutUserInput[] | ShiftAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftAlertCreateOrConnectWithoutUserInput | ShiftAlertCreateOrConnectWithoutUserInput[]
    upsert?: ShiftAlertUpsertWithWhereUniqueWithoutUserInput | ShiftAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShiftAlertCreateManyUserInputEnvelope
    set?: ShiftAlertWhereUniqueInput | ShiftAlertWhereUniqueInput[]
    disconnect?: ShiftAlertWhereUniqueInput | ShiftAlertWhereUniqueInput[]
    delete?: ShiftAlertWhereUniqueInput | ShiftAlertWhereUniqueInput[]
    connect?: ShiftAlertWhereUniqueInput | ShiftAlertWhereUniqueInput[]
    update?: ShiftAlertUpdateWithWhereUniqueWithoutUserInput | ShiftAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShiftAlertUpdateManyWithWhereWithoutUserInput | ShiftAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShiftAlertScalarWhereInput | ShiftAlertScalarWhereInput[]
  }

  export type RegisterWarrantyUpdateManyWithoutSellerNestedInput = {
    create?: XOR<RegisterWarrantyCreateWithoutSellerInput, RegisterWarrantyUncheckedCreateWithoutSellerInput> | RegisterWarrantyCreateWithoutSellerInput[] | RegisterWarrantyUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: RegisterWarrantyCreateOrConnectWithoutSellerInput | RegisterWarrantyCreateOrConnectWithoutSellerInput[]
    upsert?: RegisterWarrantyUpsertWithWhereUniqueWithoutSellerInput | RegisterWarrantyUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: RegisterWarrantyCreateManySellerInputEnvelope
    set?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    disconnect?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    delete?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    connect?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    update?: RegisterWarrantyUpdateWithWhereUniqueWithoutSellerInput | RegisterWarrantyUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: RegisterWarrantyUpdateManyWithWhereWithoutSellerInput | RegisterWarrantyUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: RegisterWarrantyScalarWhereInput | RegisterWarrantyScalarWhereInput[]
  }

  export type PostDeliveryReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostDeliveryReportCreateWithoutUserInput, PostDeliveryReportUncheckedCreateWithoutUserInput> | PostDeliveryReportCreateWithoutUserInput[] | PostDeliveryReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostDeliveryReportCreateOrConnectWithoutUserInput | PostDeliveryReportCreateOrConnectWithoutUserInput[]
    upsert?: PostDeliveryReportUpsertWithWhereUniqueWithoutUserInput | PostDeliveryReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostDeliveryReportCreateManyUserInputEnvelope
    set?: PostDeliveryReportWhereUniqueInput | PostDeliveryReportWhereUniqueInput[]
    disconnect?: PostDeliveryReportWhereUniqueInput | PostDeliveryReportWhereUniqueInput[]
    delete?: PostDeliveryReportWhereUniqueInput | PostDeliveryReportWhereUniqueInput[]
    connect?: PostDeliveryReportWhereUniqueInput | PostDeliveryReportWhereUniqueInput[]
    update?: PostDeliveryReportUpdateWithWhereUniqueWithoutUserInput | PostDeliveryReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostDeliveryReportUpdateManyWithWhereWithoutUserInput | PostDeliveryReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostDeliveryReportScalarWhereInput | PostDeliveryReportScalarWhereInput[]
  }

  export type CommissionedWorkUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommissionedWorkCreateWithoutUserInput, CommissionedWorkUncheckedCreateWithoutUserInput> | CommissionedWorkCreateWithoutUserInput[] | CommissionedWorkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommissionedWorkCreateOrConnectWithoutUserInput | CommissionedWorkCreateOrConnectWithoutUserInput[]
    upsert?: CommissionedWorkUpsertWithWhereUniqueWithoutUserInput | CommissionedWorkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommissionedWorkCreateManyUserInputEnvelope
    set?: CommissionedWorkWhereUniqueInput | CommissionedWorkWhereUniqueInput[]
    disconnect?: CommissionedWorkWhereUniqueInput | CommissionedWorkWhereUniqueInput[]
    delete?: CommissionedWorkWhereUniqueInput | CommissionedWorkWhereUniqueInput[]
    connect?: CommissionedWorkWhereUniqueInput | CommissionedWorkWhereUniqueInput[]
    update?: CommissionedWorkUpdateWithWhereUniqueWithoutUserInput | CommissionedWorkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommissionedWorkUpdateManyWithWhereWithoutUserInput | CommissionedWorkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommissionedWorkScalarWhereInput | CommissionedWorkScalarWhereInput[]
  }

  export type CartUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutUserInput | CartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutUserInput | CartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutUserInput | CartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type AuditUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditCreateWithoutUserInput, AuditUncheckedCreateWithoutUserInput> | AuditCreateWithoutUserInput[] | AuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutUserInput | AuditCreateOrConnectWithoutUserInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutUserInput | AuditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditCreateManyUserInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutUserInput | AuditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutUserInput | AuditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FinancialLogUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<FinancialLogCreateWithoutCreatedByUserInput, FinancialLogUncheckedCreateWithoutCreatedByUserInput> | FinancialLogCreateWithoutCreatedByUserInput[] | FinancialLogUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: FinancialLogCreateOrConnectWithoutCreatedByUserInput | FinancialLogCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: FinancialLogUpsertWithWhereUniqueWithoutCreatedByUserInput | FinancialLogUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: FinancialLogCreateManyCreatedByUserInputEnvelope
    set?: FinancialLogWhereUniqueInput | FinancialLogWhereUniqueInput[]
    disconnect?: FinancialLogWhereUniqueInput | FinancialLogWhereUniqueInput[]
    delete?: FinancialLogWhereUniqueInput | FinancialLogWhereUniqueInput[]
    connect?: FinancialLogWhereUniqueInput | FinancialLogWhereUniqueInput[]
    update?: FinancialLogUpdateWithWhereUniqueWithoutCreatedByUserInput | FinancialLogUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: FinancialLogUpdateManyWithWhereWithoutCreatedByUserInput | FinancialLogUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: FinancialLogScalarWhereInput | FinancialLogScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutReceiverInput | ChatMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutReceiverInput | ChatMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutReceiverInput | ChatMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type SalesManagerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SalesManagerCreateWithoutUserInput, SalesManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: SalesManagerCreateOrConnectWithoutUserInput
    upsert?: SalesManagerUpsertWithoutUserInput
    disconnect?: SalesManagerWhereInput | boolean
    delete?: SalesManagerWhereInput | boolean
    connect?: SalesManagerWhereUniqueInput
    update?: XOR<XOR<SalesManagerUpdateToOneWithWhereWithoutUserInput, SalesManagerUpdateWithoutUserInput>, SalesManagerUncheckedUpdateWithoutUserInput>
  }

  export type PlumberUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlumberCreateWithoutUserInput, PlumberUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlumberCreateOrConnectWithoutUserInput
    upsert?: PlumberUpsertWithoutUserInput
    disconnect?: PlumberWhereInput | boolean
    delete?: PlumberWhereInput | boolean
    connect?: PlumberWhereUniqueInput
    update?: XOR<XOR<PlumberUpdateToOneWithWhereWithoutUserInput, PlumberUpdateWithoutUserInput>, PlumberUncheckedUpdateWithoutUserInput>
  }

  export type AccountantUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AccountantCreateWithoutUserInput, AccountantUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountantCreateOrConnectWithoutUserInput
    upsert?: AccountantUpsertWithoutUserInput
    disconnect?: AccountantWhereInput | boolean
    delete?: AccountantWhereInput | boolean
    connect?: AccountantWhereUniqueInput
    update?: XOR<XOR<AccountantUpdateToOneWithWhereWithoutUserInput, AccountantUpdateWithoutUserInput>, AccountantUncheckedUpdateWithoutUserInput>
  }

  export type DistributorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DistributorCreateWithoutUserInput, DistributorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutUserInput
    upsert?: DistributorUpsertWithoutUserInput
    disconnect?: DistributorWhereInput | boolean
    delete?: DistributorWhereInput | boolean
    connect?: DistributorWhereUniqueInput
    update?: XOR<XOR<DistributorUpdateToOneWithWhereWithoutUserInput, DistributorUpdateWithoutUserInput>, DistributorUncheckedUpdateWithoutUserInput>
  }

  export type FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<FieldExecutiveCreateWithoutUserInput, FieldExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutUserInput
    upsert?: FieldExecutiveUpsertWithoutUserInput
    disconnect?: FieldExecutiveWhereInput | boolean
    delete?: FieldExecutiveWhereInput | boolean
    connect?: FieldExecutiveWhereUniqueInput
    update?: XOR<XOR<FieldExecutiveUpdateToOneWithWhereWithoutUserInput, FieldExecutiveUpdateWithoutUserInput>, FieldExecutiveUncheckedUpdateWithoutUserInput>
  }

  export type WorkerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WorkerCreateWithoutUserInput, WorkerUncheckedCreateWithoutUserInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutUserInput
    upsert?: WorkerUpsertWithoutUserInput
    disconnect?: WorkerWhereInput | boolean
    delete?: WorkerWhereInput | boolean
    connect?: WorkerWhereUniqueInput
    update?: XOR<XOR<WorkerUpdateToOneWithWhereWithoutUserInput, WorkerUpdateWithoutUserInput>, WorkerUncheckedUpdateWithoutUserInput>
  }

  export type PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlumberAccountProfileCreateWithoutUserInput, PlumberAccountProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlumberAccountProfileCreateOrConnectWithoutUserInput
    upsert?: PlumberAccountProfileUpsertWithoutUserInput
    disconnect?: PlumberAccountProfileWhereInput | boolean
    delete?: PlumberAccountProfileWhereInput | boolean
    connect?: PlumberAccountProfileWhereUniqueInput
    update?: XOR<XOR<PlumberAccountProfileUpdateToOneWithWhereWithoutUserInput, PlumberAccountProfileUpdateWithoutUserInput>, PlumberAccountProfileUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type PointTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointTransactionCreateWithoutUserInput, PointTransactionUncheckedCreateWithoutUserInput> | PointTransactionCreateWithoutUserInput[] | PointTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutUserInput | PointTransactionCreateOrConnectWithoutUserInput[]
    upsert?: PointTransactionUpsertWithWhereUniqueWithoutUserInput | PointTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointTransactionCreateManyUserInputEnvelope
    set?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    disconnect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    delete?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    update?: PointTransactionUpdateWithWhereUniqueWithoutUserInput | PointTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointTransactionUpdateManyWithWhereWithoutUserInput | PointTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
  }

  export type IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<IncentiveCreateWithoutAssignedToInput, IncentiveUncheckedCreateWithoutAssignedToInput> | IncentiveCreateWithoutAssignedToInput[] | IncentiveUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: IncentiveCreateOrConnectWithoutAssignedToInput | IncentiveCreateOrConnectWithoutAssignedToInput[]
    upsert?: IncentiveUpsertWithWhereUniqueWithoutAssignedToInput | IncentiveUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: IncentiveCreateManyAssignedToInputEnvelope
    set?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    disconnect?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    delete?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    connect?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    update?: IncentiveUpdateWithWhereUniqueWithoutAssignedToInput | IncentiveUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: IncentiveUpdateManyWithWhereWithoutAssignedToInput | IncentiveUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: IncentiveScalarWhereInput | IncentiveScalarWhereInput[]
  }

  export type DeliveryReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeliveryReportCreateWithoutUserInput, DeliveryReportUncheckedCreateWithoutUserInput> | DeliveryReportCreateWithoutUserInput[] | DeliveryReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeliveryReportCreateOrConnectWithoutUserInput | DeliveryReportCreateOrConnectWithoutUserInput[]
    upsert?: DeliveryReportUpsertWithWhereUniqueWithoutUserInput | DeliveryReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeliveryReportCreateManyUserInputEnvelope
    set?: DeliveryReportWhereUniqueInput | DeliveryReportWhereUniqueInput[]
    disconnect?: DeliveryReportWhereUniqueInput | DeliveryReportWhereUniqueInput[]
    delete?: DeliveryReportWhereUniqueInput | DeliveryReportWhereUniqueInput[]
    connect?: DeliveryReportWhereUniqueInput | DeliveryReportWhereUniqueInput[]
    update?: DeliveryReportUpdateWithWhereUniqueWithoutUserInput | DeliveryReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeliveryReportUpdateManyWithWhereWithoutUserInput | DeliveryReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeliveryReportScalarWhereInput | DeliveryReportScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type LiveLocationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LiveLocationCreateWithoutUserInput, LiveLocationUncheckedCreateWithoutUserInput> | LiveLocationCreateWithoutUserInput[] | LiveLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LiveLocationCreateOrConnectWithoutUserInput | LiveLocationCreateOrConnectWithoutUserInput[]
    upsert?: LiveLocationUpsertWithWhereUniqueWithoutUserInput | LiveLocationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LiveLocationCreateManyUserInputEnvelope
    set?: LiveLocationWhereUniqueInput | LiveLocationWhereUniqueInput[]
    disconnect?: LiveLocationWhereUniqueInput | LiveLocationWhereUniqueInput[]
    delete?: LiveLocationWhereUniqueInput | LiveLocationWhereUniqueInput[]
    connect?: LiveLocationWhereUniqueInput | LiveLocationWhereUniqueInput[]
    update?: LiveLocationUpdateWithWhereUniqueWithoutUserInput | LiveLocationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LiveLocationUpdateManyWithWhereWithoutUserInput | LiveLocationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LiveLocationScalarWhereInput | LiveLocationScalarWhereInput[]
  }

  export type ShiftAlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShiftAlertCreateWithoutUserInput, ShiftAlertUncheckedCreateWithoutUserInput> | ShiftAlertCreateWithoutUserInput[] | ShiftAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftAlertCreateOrConnectWithoutUserInput | ShiftAlertCreateOrConnectWithoutUserInput[]
    upsert?: ShiftAlertUpsertWithWhereUniqueWithoutUserInput | ShiftAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShiftAlertCreateManyUserInputEnvelope
    set?: ShiftAlertWhereUniqueInput | ShiftAlertWhereUniqueInput[]
    disconnect?: ShiftAlertWhereUniqueInput | ShiftAlertWhereUniqueInput[]
    delete?: ShiftAlertWhereUniqueInput | ShiftAlertWhereUniqueInput[]
    connect?: ShiftAlertWhereUniqueInput | ShiftAlertWhereUniqueInput[]
    update?: ShiftAlertUpdateWithWhereUniqueWithoutUserInput | ShiftAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShiftAlertUpdateManyWithWhereWithoutUserInput | ShiftAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShiftAlertScalarWhereInput | ShiftAlertScalarWhereInput[]
  }

  export type RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<RegisterWarrantyCreateWithoutSellerInput, RegisterWarrantyUncheckedCreateWithoutSellerInput> | RegisterWarrantyCreateWithoutSellerInput[] | RegisterWarrantyUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: RegisterWarrantyCreateOrConnectWithoutSellerInput | RegisterWarrantyCreateOrConnectWithoutSellerInput[]
    upsert?: RegisterWarrantyUpsertWithWhereUniqueWithoutSellerInput | RegisterWarrantyUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: RegisterWarrantyCreateManySellerInputEnvelope
    set?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    disconnect?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    delete?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    connect?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    update?: RegisterWarrantyUpdateWithWhereUniqueWithoutSellerInput | RegisterWarrantyUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: RegisterWarrantyUpdateManyWithWhereWithoutSellerInput | RegisterWarrantyUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: RegisterWarrantyScalarWhereInput | RegisterWarrantyScalarWhereInput[]
  }

  export type PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostDeliveryReportCreateWithoutUserInput, PostDeliveryReportUncheckedCreateWithoutUserInput> | PostDeliveryReportCreateWithoutUserInput[] | PostDeliveryReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostDeliveryReportCreateOrConnectWithoutUserInput | PostDeliveryReportCreateOrConnectWithoutUserInput[]
    upsert?: PostDeliveryReportUpsertWithWhereUniqueWithoutUserInput | PostDeliveryReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostDeliveryReportCreateManyUserInputEnvelope
    set?: PostDeliveryReportWhereUniqueInput | PostDeliveryReportWhereUniqueInput[]
    disconnect?: PostDeliveryReportWhereUniqueInput | PostDeliveryReportWhereUniqueInput[]
    delete?: PostDeliveryReportWhereUniqueInput | PostDeliveryReportWhereUniqueInput[]
    connect?: PostDeliveryReportWhereUniqueInput | PostDeliveryReportWhereUniqueInput[]
    update?: PostDeliveryReportUpdateWithWhereUniqueWithoutUserInput | PostDeliveryReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostDeliveryReportUpdateManyWithWhereWithoutUserInput | PostDeliveryReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostDeliveryReportScalarWhereInput | PostDeliveryReportScalarWhereInput[]
  }

  export type CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommissionedWorkCreateWithoutUserInput, CommissionedWorkUncheckedCreateWithoutUserInput> | CommissionedWorkCreateWithoutUserInput[] | CommissionedWorkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommissionedWorkCreateOrConnectWithoutUserInput | CommissionedWorkCreateOrConnectWithoutUserInput[]
    upsert?: CommissionedWorkUpsertWithWhereUniqueWithoutUserInput | CommissionedWorkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommissionedWorkCreateManyUserInputEnvelope
    set?: CommissionedWorkWhereUniqueInput | CommissionedWorkWhereUniqueInput[]
    disconnect?: CommissionedWorkWhereUniqueInput | CommissionedWorkWhereUniqueInput[]
    delete?: CommissionedWorkWhereUniqueInput | CommissionedWorkWhereUniqueInput[]
    connect?: CommissionedWorkWhereUniqueInput | CommissionedWorkWhereUniqueInput[]
    update?: CommissionedWorkUpdateWithWhereUniqueWithoutUserInput | CommissionedWorkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommissionedWorkUpdateManyWithWhereWithoutUserInput | CommissionedWorkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommissionedWorkScalarWhereInput | CommissionedWorkScalarWhereInput[]
  }

  export type CartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutUserInput | CartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutUserInput | CartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutUserInput | CartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type AuditUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditCreateWithoutUserInput, AuditUncheckedCreateWithoutUserInput> | AuditCreateWithoutUserInput[] | AuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutUserInput | AuditCreateOrConnectWithoutUserInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutUserInput | AuditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditCreateManyUserInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutUserInput | AuditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutUserInput | AuditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<FinancialLogCreateWithoutCreatedByUserInput, FinancialLogUncheckedCreateWithoutCreatedByUserInput> | FinancialLogCreateWithoutCreatedByUserInput[] | FinancialLogUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: FinancialLogCreateOrConnectWithoutCreatedByUserInput | FinancialLogCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: FinancialLogUpsertWithWhereUniqueWithoutCreatedByUserInput | FinancialLogUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: FinancialLogCreateManyCreatedByUserInputEnvelope
    set?: FinancialLogWhereUniqueInput | FinancialLogWhereUniqueInput[]
    disconnect?: FinancialLogWhereUniqueInput | FinancialLogWhereUniqueInput[]
    delete?: FinancialLogWhereUniqueInput | FinancialLogWhereUniqueInput[]
    connect?: FinancialLogWhereUniqueInput | FinancialLogWhereUniqueInput[]
    update?: FinancialLogUpdateWithWhereUniqueWithoutCreatedByUserInput | FinancialLogUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: FinancialLogUpdateManyWithWhereWithoutCreatedByUserInput | FinancialLogUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: FinancialLogScalarWhereInput | FinancialLogScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutReceiverInput | ChatMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutReceiverInput | ChatMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutReceiverInput | ChatMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type AdminCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AdminCreateWithoutCompanyInput, AdminUncheckedCreateWithoutCompanyInput> | AdminCreateWithoutCompanyInput[] | AdminUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCompanyInput | AdminCreateOrConnectWithoutCompanyInput[]
    createMany?: AdminCreateManyCompanyInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AdminCreateWithoutCompanyInput, AdminUncheckedCreateWithoutCompanyInput> | AdminCreateWithoutCompanyInput[] | AdminUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCompanyInput | AdminCreateOrConnectWithoutCompanyInput[]
    createMany?: AdminCreateManyCompanyInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AdminUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AdminCreateWithoutCompanyInput, AdminUncheckedCreateWithoutCompanyInput> | AdminCreateWithoutCompanyInput[] | AdminUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCompanyInput | AdminCreateOrConnectWithoutCompanyInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutCompanyInput | AdminUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AdminCreateManyCompanyInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutCompanyInput | AdminUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutCompanyInput | AdminUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AdminCreateWithoutCompanyInput, AdminUncheckedCreateWithoutCompanyInput> | AdminCreateWithoutCompanyInput[] | AdminUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCompanyInput | AdminCreateOrConnectWithoutCompanyInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutCompanyInput | AdminUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AdminCreateManyCompanyInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutCompanyInput | AdminUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutCompanyInput | AdminUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutAdminsInput = {
    create?: XOR<CompanyCreateWithoutAdminsInput, CompanyUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAdminsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type CompanyUpdateOneWithoutAdminsNestedInput = {
    create?: XOR<CompanyCreateWithoutAdminsInput, CompanyUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAdminsInput
    upsert?: CompanyUpsertWithoutAdminsInput
    disconnect?: boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAdminsInput, CompanyUpdateWithoutAdminsInput>, CompanyUncheckedUpdateWithoutAdminsInput>
  }

  export type UserCreateNestedOneWithoutSalesManagerInput = {
    create?: XOR<UserCreateWithoutSalesManagerInput, UserUncheckedCreateWithoutSalesManagerInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesManagerInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSalesManagerNestedInput = {
    create?: XOR<UserCreateWithoutSalesManagerInput, UserUncheckedCreateWithoutSalesManagerInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesManagerInput
    upsert?: UserUpsertWithoutSalesManagerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalesManagerInput, UserUpdateWithoutSalesManagerInput>, UserUncheckedUpdateWithoutSalesManagerInput>
  }

  export type UserCreateNestedOneWithoutPlumberInput = {
    create?: XOR<UserCreateWithoutPlumberInput, UserUncheckedCreateWithoutPlumberInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlumberInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPlumberNestedInput = {
    create?: XOR<UserCreateWithoutPlumberInput, UserUncheckedCreateWithoutPlumberInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlumberInput
    upsert?: UserUpsertWithoutPlumberInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlumberInput, UserUpdateWithoutPlumberInput>, UserUncheckedUpdateWithoutPlumberInput>
  }

  export type UserCreateNestedOneWithoutAccountProfileInput = {
    create?: XOR<UserCreateWithoutAccountProfileInput, UserUncheckedCreateWithoutAccountProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountProfileNestedInput = {
    create?: XOR<UserCreateWithoutAccountProfileInput, UserUncheckedCreateWithoutAccountProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountProfileInput
    upsert?: UserUpsertWithoutAccountProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountProfileInput, UserUpdateWithoutAccountProfileInput>, UserUncheckedUpdateWithoutAccountProfileInput>
  }

  export type UserCreateNestedOneWithoutAccountantInput = {
    create?: XOR<UserCreateWithoutAccountantInput, UserUncheckedCreateWithoutAccountantInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountantInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountantNestedInput = {
    create?: XOR<UserCreateWithoutAccountantInput, UserUncheckedCreateWithoutAccountantInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountantInput
    upsert?: UserUpsertWithoutAccountantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountantInput, UserUpdateWithoutAccountantInput>, UserUncheckedUpdateWithoutAccountantInput>
  }

  export type UserCreateNestedOneWithoutDistributorInput = {
    create?: XOR<UserCreateWithoutDistributorInput, UserUncheckedCreateWithoutDistributorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDistributorInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDistributorNestedInput = {
    create?: XOR<UserCreateWithoutDistributorInput, UserUncheckedCreateWithoutDistributorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDistributorInput
    upsert?: UserUpsertWithoutDistributorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDistributorInput, UserUpdateWithoutDistributorInput>, UserUncheckedUpdateWithoutDistributorInput>
  }

  export type UserCreateNestedOneWithoutFieldExecutiveInput = {
    create?: XOR<UserCreateWithoutFieldExecutiveInput, UserUncheckedCreateWithoutFieldExecutiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutFieldExecutiveInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerFollowUpCreateNestedManyWithoutExecutiveInput = {
    create?: XOR<CustomerFollowUpCreateWithoutExecutiveInput, CustomerFollowUpUncheckedCreateWithoutExecutiveInput> | CustomerFollowUpCreateWithoutExecutiveInput[] | CustomerFollowUpUncheckedCreateWithoutExecutiveInput[]
    connectOrCreate?: CustomerFollowUpCreateOrConnectWithoutExecutiveInput | CustomerFollowUpCreateOrConnectWithoutExecutiveInput[]
    createMany?: CustomerFollowUpCreateManyExecutiveInputEnvelope
    connect?: CustomerFollowUpWhereUniqueInput | CustomerFollowUpWhereUniqueInput[]
  }

  export type DVRCreateNestedManyWithoutExecutiveInput = {
    create?: XOR<DVRCreateWithoutExecutiveInput, DVRUncheckedCreateWithoutExecutiveInput> | DVRCreateWithoutExecutiveInput[] | DVRUncheckedCreateWithoutExecutiveInput[]
    connectOrCreate?: DVRCreateOrConnectWithoutExecutiveInput | DVRCreateOrConnectWithoutExecutiveInput[]
    createMany?: DVRCreateManyExecutiveInputEnvelope
    connect?: DVRWhereUniqueInput | DVRWhereUniqueInput[]
  }

  export type CustomerFollowUpUncheckedCreateNestedManyWithoutExecutiveInput = {
    create?: XOR<CustomerFollowUpCreateWithoutExecutiveInput, CustomerFollowUpUncheckedCreateWithoutExecutiveInput> | CustomerFollowUpCreateWithoutExecutiveInput[] | CustomerFollowUpUncheckedCreateWithoutExecutiveInput[]
    connectOrCreate?: CustomerFollowUpCreateOrConnectWithoutExecutiveInput | CustomerFollowUpCreateOrConnectWithoutExecutiveInput[]
    createMany?: CustomerFollowUpCreateManyExecutiveInputEnvelope
    connect?: CustomerFollowUpWhereUniqueInput | CustomerFollowUpWhereUniqueInput[]
  }

  export type DVRUncheckedCreateNestedManyWithoutExecutiveInput = {
    create?: XOR<DVRCreateWithoutExecutiveInput, DVRUncheckedCreateWithoutExecutiveInput> | DVRCreateWithoutExecutiveInput[] | DVRUncheckedCreateWithoutExecutiveInput[]
    connectOrCreate?: DVRCreateOrConnectWithoutExecutiveInput | DVRCreateOrConnectWithoutExecutiveInput[]
    createMany?: DVRCreateManyExecutiveInputEnvelope
    connect?: DVRWhereUniqueInput | DVRWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutFieldExecutiveNestedInput = {
    create?: XOR<UserCreateWithoutFieldExecutiveInput, UserUncheckedCreateWithoutFieldExecutiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutFieldExecutiveInput
    upsert?: UserUpsertWithoutFieldExecutiveInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFieldExecutiveInput, UserUpdateWithoutFieldExecutiveInput>, UserUncheckedUpdateWithoutFieldExecutiveInput>
  }

  export type CustomerFollowUpUpdateManyWithoutExecutiveNestedInput = {
    create?: XOR<CustomerFollowUpCreateWithoutExecutiveInput, CustomerFollowUpUncheckedCreateWithoutExecutiveInput> | CustomerFollowUpCreateWithoutExecutiveInput[] | CustomerFollowUpUncheckedCreateWithoutExecutiveInput[]
    connectOrCreate?: CustomerFollowUpCreateOrConnectWithoutExecutiveInput | CustomerFollowUpCreateOrConnectWithoutExecutiveInput[]
    upsert?: CustomerFollowUpUpsertWithWhereUniqueWithoutExecutiveInput | CustomerFollowUpUpsertWithWhereUniqueWithoutExecutiveInput[]
    createMany?: CustomerFollowUpCreateManyExecutiveInputEnvelope
    set?: CustomerFollowUpWhereUniqueInput | CustomerFollowUpWhereUniqueInput[]
    disconnect?: CustomerFollowUpWhereUniqueInput | CustomerFollowUpWhereUniqueInput[]
    delete?: CustomerFollowUpWhereUniqueInput | CustomerFollowUpWhereUniqueInput[]
    connect?: CustomerFollowUpWhereUniqueInput | CustomerFollowUpWhereUniqueInput[]
    update?: CustomerFollowUpUpdateWithWhereUniqueWithoutExecutiveInput | CustomerFollowUpUpdateWithWhereUniqueWithoutExecutiveInput[]
    updateMany?: CustomerFollowUpUpdateManyWithWhereWithoutExecutiveInput | CustomerFollowUpUpdateManyWithWhereWithoutExecutiveInput[]
    deleteMany?: CustomerFollowUpScalarWhereInput | CustomerFollowUpScalarWhereInput[]
  }

  export type DVRUpdateManyWithoutExecutiveNestedInput = {
    create?: XOR<DVRCreateWithoutExecutiveInput, DVRUncheckedCreateWithoutExecutiveInput> | DVRCreateWithoutExecutiveInput[] | DVRUncheckedCreateWithoutExecutiveInput[]
    connectOrCreate?: DVRCreateOrConnectWithoutExecutiveInput | DVRCreateOrConnectWithoutExecutiveInput[]
    upsert?: DVRUpsertWithWhereUniqueWithoutExecutiveInput | DVRUpsertWithWhereUniqueWithoutExecutiveInput[]
    createMany?: DVRCreateManyExecutiveInputEnvelope
    set?: DVRWhereUniqueInput | DVRWhereUniqueInput[]
    disconnect?: DVRWhereUniqueInput | DVRWhereUniqueInput[]
    delete?: DVRWhereUniqueInput | DVRWhereUniqueInput[]
    connect?: DVRWhereUniqueInput | DVRWhereUniqueInput[]
    update?: DVRUpdateWithWhereUniqueWithoutExecutiveInput | DVRUpdateWithWhereUniqueWithoutExecutiveInput[]
    updateMany?: DVRUpdateManyWithWhereWithoutExecutiveInput | DVRUpdateManyWithWhereWithoutExecutiveInput[]
    deleteMany?: DVRScalarWhereInput | DVRScalarWhereInput[]
  }

  export type CustomerFollowUpUncheckedUpdateManyWithoutExecutiveNestedInput = {
    create?: XOR<CustomerFollowUpCreateWithoutExecutiveInput, CustomerFollowUpUncheckedCreateWithoutExecutiveInput> | CustomerFollowUpCreateWithoutExecutiveInput[] | CustomerFollowUpUncheckedCreateWithoutExecutiveInput[]
    connectOrCreate?: CustomerFollowUpCreateOrConnectWithoutExecutiveInput | CustomerFollowUpCreateOrConnectWithoutExecutiveInput[]
    upsert?: CustomerFollowUpUpsertWithWhereUniqueWithoutExecutiveInput | CustomerFollowUpUpsertWithWhereUniqueWithoutExecutiveInput[]
    createMany?: CustomerFollowUpCreateManyExecutiveInputEnvelope
    set?: CustomerFollowUpWhereUniqueInput | CustomerFollowUpWhereUniqueInput[]
    disconnect?: CustomerFollowUpWhereUniqueInput | CustomerFollowUpWhereUniqueInput[]
    delete?: CustomerFollowUpWhereUniqueInput | CustomerFollowUpWhereUniqueInput[]
    connect?: CustomerFollowUpWhereUniqueInput | CustomerFollowUpWhereUniqueInput[]
    update?: CustomerFollowUpUpdateWithWhereUniqueWithoutExecutiveInput | CustomerFollowUpUpdateWithWhereUniqueWithoutExecutiveInput[]
    updateMany?: CustomerFollowUpUpdateManyWithWhereWithoutExecutiveInput | CustomerFollowUpUpdateManyWithWhereWithoutExecutiveInput[]
    deleteMany?: CustomerFollowUpScalarWhereInput | CustomerFollowUpScalarWhereInput[]
  }

  export type DVRUncheckedUpdateManyWithoutExecutiveNestedInput = {
    create?: XOR<DVRCreateWithoutExecutiveInput, DVRUncheckedCreateWithoutExecutiveInput> | DVRCreateWithoutExecutiveInput[] | DVRUncheckedCreateWithoutExecutiveInput[]
    connectOrCreate?: DVRCreateOrConnectWithoutExecutiveInput | DVRCreateOrConnectWithoutExecutiveInput[]
    upsert?: DVRUpsertWithWhereUniqueWithoutExecutiveInput | DVRUpsertWithWhereUniqueWithoutExecutiveInput[]
    createMany?: DVRCreateManyExecutiveInputEnvelope
    set?: DVRWhereUniqueInput | DVRWhereUniqueInput[]
    disconnect?: DVRWhereUniqueInput | DVRWhereUniqueInput[]
    delete?: DVRWhereUniqueInput | DVRWhereUniqueInput[]
    connect?: DVRWhereUniqueInput | DVRWhereUniqueInput[]
    update?: DVRUpdateWithWhereUniqueWithoutExecutiveInput | DVRUpdateWithWhereUniqueWithoutExecutiveInput[]
    updateMany?: DVRUpdateManyWithWhereWithoutExecutiveInput | DVRUpdateManyWithWhereWithoutExecutiveInput[]
    deleteMany?: DVRScalarWhereInput | DVRScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWorkerInput = {
    create?: XOR<UserCreateWithoutWorkerInput, UserUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkerInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWorkerNestedInput = {
    create?: XOR<UserCreateWithoutWorkerInput, UserUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkerInput
    upsert?: UserUpsertWithoutWorkerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkerInput, UserUpdateWithoutWorkerInput>, UserUncheckedUpdateWithoutWorkerInput>
  }

  export type StockCreateNestedManyWithoutProductInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput> | StockCreateWithoutProductInput[] | StockUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockCreateOrConnectWithoutProductInput | StockCreateOrConnectWithoutProductInput[]
    createMany?: StockCreateManyProductInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type WarrantyCardCreateNestedManyWithoutProductInput = {
    create?: XOR<WarrantyCardCreateWithoutProductInput, WarrantyCardUncheckedCreateWithoutProductInput> | WarrantyCardCreateWithoutProductInput[] | WarrantyCardUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WarrantyCardCreateOrConnectWithoutProductInput | WarrantyCardCreateOrConnectWithoutProductInput[]
    createMany?: WarrantyCardCreateManyProductInputEnvelope
    connect?: WarrantyCardWhereUniqueInput | WarrantyCardWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type RegisterWarrantyCreateNestedManyWithoutProductInput = {
    create?: XOR<RegisterWarrantyCreateWithoutProductInput, RegisterWarrantyUncheckedCreateWithoutProductInput> | RegisterWarrantyCreateWithoutProductInput[] | RegisterWarrantyUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RegisterWarrantyCreateOrConnectWithoutProductInput | RegisterWarrantyCreateOrConnectWithoutProductInput[]
    createMany?: RegisterWarrantyCreateManyProductInputEnvelope
    connect?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
  }

  export type CartItemCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type StockUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput> | StockCreateWithoutProductInput[] | StockUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockCreateOrConnectWithoutProductInput | StockCreateOrConnectWithoutProductInput[]
    createMany?: StockCreateManyProductInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type WarrantyCardUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<WarrantyCardCreateWithoutProductInput, WarrantyCardUncheckedCreateWithoutProductInput> | WarrantyCardCreateWithoutProductInput[] | WarrantyCardUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WarrantyCardCreateOrConnectWithoutProductInput | WarrantyCardCreateOrConnectWithoutProductInput[]
    createMany?: WarrantyCardCreateManyProductInputEnvelope
    connect?: WarrantyCardWhereUniqueInput | WarrantyCardWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type RegisterWarrantyUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<RegisterWarrantyCreateWithoutProductInput, RegisterWarrantyUncheckedCreateWithoutProductInput> | RegisterWarrantyCreateWithoutProductInput[] | RegisterWarrantyUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RegisterWarrantyCreateOrConnectWithoutProductInput | RegisterWarrantyCreateOrConnectWithoutProductInput[]
    createMany?: RegisterWarrantyCreateManyProductInputEnvelope
    connect?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StockUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput> | StockCreateWithoutProductInput[] | StockUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockCreateOrConnectWithoutProductInput | StockCreateOrConnectWithoutProductInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutProductInput | StockUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockCreateManyProductInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutProductInput | StockUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockUpdateManyWithWhereWithoutProductInput | StockUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type WarrantyCardUpdateManyWithoutProductNestedInput = {
    create?: XOR<WarrantyCardCreateWithoutProductInput, WarrantyCardUncheckedCreateWithoutProductInput> | WarrantyCardCreateWithoutProductInput[] | WarrantyCardUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WarrantyCardCreateOrConnectWithoutProductInput | WarrantyCardCreateOrConnectWithoutProductInput[]
    upsert?: WarrantyCardUpsertWithWhereUniqueWithoutProductInput | WarrantyCardUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WarrantyCardCreateManyProductInputEnvelope
    set?: WarrantyCardWhereUniqueInput | WarrantyCardWhereUniqueInput[]
    disconnect?: WarrantyCardWhereUniqueInput | WarrantyCardWhereUniqueInput[]
    delete?: WarrantyCardWhereUniqueInput | WarrantyCardWhereUniqueInput[]
    connect?: WarrantyCardWhereUniqueInput | WarrantyCardWhereUniqueInput[]
    update?: WarrantyCardUpdateWithWhereUniqueWithoutProductInput | WarrantyCardUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WarrantyCardUpdateManyWithWhereWithoutProductInput | WarrantyCardUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WarrantyCardScalarWhereInput | WarrantyCardScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type RegisterWarrantyUpdateManyWithoutProductNestedInput = {
    create?: XOR<RegisterWarrantyCreateWithoutProductInput, RegisterWarrantyUncheckedCreateWithoutProductInput> | RegisterWarrantyCreateWithoutProductInput[] | RegisterWarrantyUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RegisterWarrantyCreateOrConnectWithoutProductInput | RegisterWarrantyCreateOrConnectWithoutProductInput[]
    upsert?: RegisterWarrantyUpsertWithWhereUniqueWithoutProductInput | RegisterWarrantyUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RegisterWarrantyCreateManyProductInputEnvelope
    set?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    disconnect?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    delete?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    connect?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    update?: RegisterWarrantyUpdateWithWhereUniqueWithoutProductInput | RegisterWarrantyUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RegisterWarrantyUpdateManyWithWhereWithoutProductInput | RegisterWarrantyUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RegisterWarrantyScalarWhereInput | RegisterWarrantyScalarWhereInput[]
  }

  export type CartItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    disconnect?: boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type StockUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput> | StockCreateWithoutProductInput[] | StockUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockCreateOrConnectWithoutProductInput | StockCreateOrConnectWithoutProductInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutProductInput | StockUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockCreateManyProductInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutProductInput | StockUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockUpdateManyWithWhereWithoutProductInput | StockUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type WarrantyCardUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<WarrantyCardCreateWithoutProductInput, WarrantyCardUncheckedCreateWithoutProductInput> | WarrantyCardCreateWithoutProductInput[] | WarrantyCardUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WarrantyCardCreateOrConnectWithoutProductInput | WarrantyCardCreateOrConnectWithoutProductInput[]
    upsert?: WarrantyCardUpsertWithWhereUniqueWithoutProductInput | WarrantyCardUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WarrantyCardCreateManyProductInputEnvelope
    set?: WarrantyCardWhereUniqueInput | WarrantyCardWhereUniqueInput[]
    disconnect?: WarrantyCardWhereUniqueInput | WarrantyCardWhereUniqueInput[]
    delete?: WarrantyCardWhereUniqueInput | WarrantyCardWhereUniqueInput[]
    connect?: WarrantyCardWhereUniqueInput | WarrantyCardWhereUniqueInput[]
    update?: WarrantyCardUpdateWithWhereUniqueWithoutProductInput | WarrantyCardUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WarrantyCardUpdateManyWithWhereWithoutProductInput | WarrantyCardUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WarrantyCardScalarWhereInput | WarrantyCardScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type RegisterWarrantyUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<RegisterWarrantyCreateWithoutProductInput, RegisterWarrantyUncheckedCreateWithoutProductInput> | RegisterWarrantyCreateWithoutProductInput[] | RegisterWarrantyUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RegisterWarrantyCreateOrConnectWithoutProductInput | RegisterWarrantyCreateOrConnectWithoutProductInput[]
    upsert?: RegisterWarrantyUpsertWithWhereUniqueWithoutProductInput | RegisterWarrantyUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RegisterWarrantyCreateManyProductInputEnvelope
    set?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    disconnect?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    delete?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    connect?: RegisterWarrantyWhereUniqueInput | RegisterWarrantyWhereUniqueInput[]
    update?: RegisterWarrantyUpdateWithWhereUniqueWithoutProductInput | RegisterWarrantyUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RegisterWarrantyUpdateManyWithWhereWithoutProductInput | RegisterWarrantyUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RegisterWarrantyScalarWhereInput | RegisterWarrantyScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutStocksInput = {
    create?: XOR<ProductCreateWithoutStocksInput, ProductUncheckedCreateWithoutStocksInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStocksInput
    connect?: ProductWhereUniqueInput
  }

  export type DamageReportCreateNestedManyWithoutStockInput = {
    create?: XOR<DamageReportCreateWithoutStockInput, DamageReportUncheckedCreateWithoutStockInput> | DamageReportCreateWithoutStockInput[] | DamageReportUncheckedCreateWithoutStockInput[]
    connectOrCreate?: DamageReportCreateOrConnectWithoutStockInput | DamageReportCreateOrConnectWithoutStockInput[]
    createMany?: DamageReportCreateManyStockInputEnvelope
    connect?: DamageReportWhereUniqueInput | DamageReportWhereUniqueInput[]
  }

  export type DamageReportUncheckedCreateNestedManyWithoutStockInput = {
    create?: XOR<DamageReportCreateWithoutStockInput, DamageReportUncheckedCreateWithoutStockInput> | DamageReportCreateWithoutStockInput[] | DamageReportUncheckedCreateWithoutStockInput[]
    connectOrCreate?: DamageReportCreateOrConnectWithoutStockInput | DamageReportCreateOrConnectWithoutStockInput[]
    createMany?: DamageReportCreateManyStockInputEnvelope
    connect?: DamageReportWhereUniqueInput | DamageReportWhereUniqueInput[]
  }

  export type EnumStockStatusFieldUpdateOperationsInput = {
    set?: $Enums.StockStatus
  }

  export type ProductUpdateOneRequiredWithoutStocksNestedInput = {
    create?: XOR<ProductCreateWithoutStocksInput, ProductUncheckedCreateWithoutStocksInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStocksInput
    upsert?: ProductUpsertWithoutStocksInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStocksInput, ProductUpdateWithoutStocksInput>, ProductUncheckedUpdateWithoutStocksInput>
  }

  export type DamageReportUpdateManyWithoutStockNestedInput = {
    create?: XOR<DamageReportCreateWithoutStockInput, DamageReportUncheckedCreateWithoutStockInput> | DamageReportCreateWithoutStockInput[] | DamageReportUncheckedCreateWithoutStockInput[]
    connectOrCreate?: DamageReportCreateOrConnectWithoutStockInput | DamageReportCreateOrConnectWithoutStockInput[]
    upsert?: DamageReportUpsertWithWhereUniqueWithoutStockInput | DamageReportUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: DamageReportCreateManyStockInputEnvelope
    set?: DamageReportWhereUniqueInput | DamageReportWhereUniqueInput[]
    disconnect?: DamageReportWhereUniqueInput | DamageReportWhereUniqueInput[]
    delete?: DamageReportWhereUniqueInput | DamageReportWhereUniqueInput[]
    connect?: DamageReportWhereUniqueInput | DamageReportWhereUniqueInput[]
    update?: DamageReportUpdateWithWhereUniqueWithoutStockInput | DamageReportUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: DamageReportUpdateManyWithWhereWithoutStockInput | DamageReportUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: DamageReportScalarWhereInput | DamageReportScalarWhereInput[]
  }

  export type DamageReportUncheckedUpdateManyWithoutStockNestedInput = {
    create?: XOR<DamageReportCreateWithoutStockInput, DamageReportUncheckedCreateWithoutStockInput> | DamageReportCreateWithoutStockInput[] | DamageReportUncheckedCreateWithoutStockInput[]
    connectOrCreate?: DamageReportCreateOrConnectWithoutStockInput | DamageReportCreateOrConnectWithoutStockInput[]
    upsert?: DamageReportUpsertWithWhereUniqueWithoutStockInput | DamageReportUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: DamageReportCreateManyStockInputEnvelope
    set?: DamageReportWhereUniqueInput | DamageReportWhereUniqueInput[]
    disconnect?: DamageReportWhereUniqueInput | DamageReportWhereUniqueInput[]
    delete?: DamageReportWhereUniqueInput | DamageReportWhereUniqueInput[]
    connect?: DamageReportWhereUniqueInput | DamageReportWhereUniqueInput[]
    update?: DamageReportUpdateWithWhereUniqueWithoutStockInput | DamageReportUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: DamageReportUpdateManyWithWhereWithoutStockInput | DamageReportUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: DamageReportScalarWhereInput | DamageReportScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutWarrantyCardsInput = {
    create?: XOR<ProductCreateWithoutWarrantyCardsInput, ProductUncheckedCreateWithoutWarrantyCardsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWarrantyCardsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutWarrantyCardsNestedInput = {
    create?: XOR<ProductCreateWithoutWarrantyCardsInput, ProductUncheckedCreateWithoutWarrantyCardsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWarrantyCardsInput
    upsert?: ProductUpsertWithoutWarrantyCardsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutWarrantyCardsInput, ProductUpdateWithoutWarrantyCardsInput>, ProductUncheckedUpdateWithoutWarrantyCardsInput>
  }

  export type UserCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type UserUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    upsert?: UserUpsertWithoutAttendancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendancesInput, UserUpdateWithoutAttendancesInput>, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type FieldExecutiveCreateNestedOneWithoutFollowUpsInput = {
    create?: XOR<FieldExecutiveCreateWithoutFollowUpsInput, FieldExecutiveUncheckedCreateWithoutFollowUpsInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutFollowUpsInput
    connect?: FieldExecutiveWhereUniqueInput
  }

  export type EnumFollowUpStatusFieldUpdateOperationsInput = {
    set?: $Enums.FollowUpStatus
  }

  export type FieldExecutiveUpdateOneRequiredWithoutFollowUpsNestedInput = {
    create?: XOR<FieldExecutiveCreateWithoutFollowUpsInput, FieldExecutiveUncheckedCreateWithoutFollowUpsInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutFollowUpsInput
    upsert?: FieldExecutiveUpsertWithoutFollowUpsInput
    connect?: FieldExecutiveWhereUniqueInput
    update?: XOR<XOR<FieldExecutiveUpdateToOneWithWhereWithoutFollowUpsInput, FieldExecutiveUpdateWithoutFollowUpsInput>, FieldExecutiveUncheckedUpdateWithoutFollowUpsInput>
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserCreateNestedOneWithoutIncentivesInput = {
    create?: XOR<UserCreateWithoutIncentivesInput, UserUncheckedCreateWithoutIncentivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncentivesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIncentivesNestedInput = {
    create?: XOR<UserCreateWithoutIncentivesInput, UserUncheckedCreateWithoutIncentivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncentivesInput
    upsert?: UserUpsertWithoutIncentivesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIncentivesInput, UserUpdateWithoutIncentivesInput>, UserUncheckedUpdateWithoutIncentivesInput>
  }

  export type FieldExecutiveCreateNestedOneWithoutDvrReportsInput = {
    create?: XOR<FieldExecutiveCreateWithoutDvrReportsInput, FieldExecutiveUncheckedCreateWithoutDvrReportsInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutDvrReportsInput
    connect?: FieldExecutiveWhereUniqueInput
  }

  export type FieldExecutiveUpdateOneRequiredWithoutDvrReportsNestedInput = {
    create?: XOR<FieldExecutiveCreateWithoutDvrReportsInput, FieldExecutiveUncheckedCreateWithoutDvrReportsInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutDvrReportsInput
    upsert?: FieldExecutiveUpsertWithoutDvrReportsInput
    connect?: FieldExecutiveWhereUniqueInput
    update?: XOR<XOR<FieldExecutiveUpdateToOneWithWhereWithoutDvrReportsInput, FieldExecutiveUpdateWithoutDvrReportsInput>, FieldExecutiveUncheckedUpdateWithoutDvrReportsInput>
  }

  export type UserCreateNestedOneWithoutDeliveryReportsInput = {
    create?: XOR<UserCreateWithoutDeliveryReportsInput, UserUncheckedCreateWithoutDeliveryReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDeliveryReportsNestedInput = {
    create?: XOR<UserCreateWithoutDeliveryReportsInput, UserUncheckedCreateWithoutDeliveryReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryReportsInput
    upsert?: UserUpsertWithoutDeliveryReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeliveryReportsInput, UserUpdateWithoutDeliveryReportsInput>, UserUncheckedUpdateWithoutDeliveryReportsInput>
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type PromoCodeCreateNestedOneWithoutOrdersInput = {
    create?: XOR<PromoCodeCreateWithoutOrdersInput, PromoCodeUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutOrdersInput
    connect?: PromoCodeWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    upsert?: InvoiceUpsertWithoutOrderInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutOrderInput, InvoiceUpdateWithoutOrderInput>, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type PromoCodeUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<PromoCodeCreateWithoutOrdersInput, PromoCodeUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutOrdersInput
    upsert?: PromoCodeUpsertWithoutOrdersInput
    disconnect?: boolean
    delete?: PromoCodeWhereInput | boolean
    connect?: PromoCodeWhereUniqueInput
    update?: XOR<XOR<PromoCodeUpdateToOneWithWhereWithoutOrdersInput, PromoCodeUpdateWithoutOrdersInput>, PromoCodeUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    upsert?: InvoiceUpsertWithoutOrderInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutOrderInput, InvoiceUpdateWithoutOrderInput>, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type OrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    upsert?: OrderUpsertWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderItemsInput, OrderUpdateWithoutOrderItemsInput>, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    connect?: OrderWhereUniqueInput
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type OrderUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    upsert?: OrderUpsertWithoutInvoiceInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutInvoiceInput, OrderUpdateWithoutInvoiceInput>, OrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type UserCreateNestedOneWithoutLiveLocationsInput = {
    create?: XOR<UserCreateWithoutLiveLocationsInput, UserUncheckedCreateWithoutLiveLocationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLiveLocationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLiveLocationsNestedInput = {
    create?: XOR<UserCreateWithoutLiveLocationsInput, UserUncheckedCreateWithoutLiveLocationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLiveLocationsInput
    upsert?: UserUpsertWithoutLiveLocationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLiveLocationsInput, UserUpdateWithoutLiveLocationsInput>, UserUncheckedUpdateWithoutLiveLocationsInput>
  }

  export type UserCreateNestedOneWithoutShiftAlertInput = {
    create?: XOR<UserCreateWithoutShiftAlertInput, UserUncheckedCreateWithoutShiftAlertInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftAlertInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutShiftAlertNestedInput = {
    create?: XOR<UserCreateWithoutShiftAlertInput, UserUncheckedCreateWithoutShiftAlertInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftAlertInput
    upsert?: UserUpsertWithoutShiftAlertInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShiftAlertInput, UserUpdateWithoutShiftAlertInput>, UserUncheckedUpdateWithoutShiftAlertInput>
  }

  export type ProductCreateNestedOneWithoutRegisteredWarrantiesInput = {
    create?: XOR<ProductCreateWithoutRegisteredWarrantiesInput, ProductUncheckedCreateWithoutRegisteredWarrantiesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRegisteredWarrantiesInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRegisteredWarrantiesInput = {
    create?: XOR<UserCreateWithoutRegisteredWarrantiesInput, UserUncheckedCreateWithoutRegisteredWarrantiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegisteredWarrantiesInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutRegisteredWarrantiesNestedInput = {
    create?: XOR<ProductCreateWithoutRegisteredWarrantiesInput, ProductUncheckedCreateWithoutRegisteredWarrantiesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRegisteredWarrantiesInput
    upsert?: ProductUpsertWithoutRegisteredWarrantiesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutRegisteredWarrantiesInput, ProductUpdateWithoutRegisteredWarrantiesInput>, ProductUncheckedUpdateWithoutRegisteredWarrantiesInput>
  }

  export type UserUpdateOneRequiredWithoutRegisteredWarrantiesNestedInput = {
    create?: XOR<UserCreateWithoutRegisteredWarrantiesInput, UserUncheckedCreateWithoutRegisteredWarrantiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegisteredWarrantiesInput
    upsert?: UserUpsertWithoutRegisteredWarrantiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRegisteredWarrantiesInput, UserUpdateWithoutRegisteredWarrantiesInput>, UserUncheckedUpdateWithoutRegisteredWarrantiesInput>
  }

  export type UserCreateNestedOneWithoutPostDeliveryReportsInput = {
    create?: XOR<UserCreateWithoutPostDeliveryReportsInput, UserUncheckedCreateWithoutPostDeliveryReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostDeliveryReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPostDeliveryReportsNestedInput = {
    create?: XOR<UserCreateWithoutPostDeliveryReportsInput, UserUncheckedCreateWithoutPostDeliveryReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostDeliveryReportsInput
    upsert?: UserUpsertWithoutPostDeliveryReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostDeliveryReportsInput, UserUpdateWithoutPostDeliveryReportsInput>, UserUncheckedUpdateWithoutPostDeliveryReportsInput>
  }

  export type UserCreateNestedOneWithoutCommissionedWorksInput = {
    create?: XOR<UserCreateWithoutCommissionedWorksInput, UserUncheckedCreateWithoutCommissionedWorksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommissionedWorksInput
    connect?: UserWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Uint8Array
  }

  export type UserUpdateOneRequiredWithoutCommissionedWorksNestedInput = {
    create?: XOR<UserCreateWithoutCommissionedWorksInput, UserUncheckedCreateWithoutCommissionedWorksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommissionedWorksInput
    upsert?: UserUpsertWithoutCommissionedWorksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommissionedWorksInput, UserUpdateWithoutCommissionedWorksInput>, UserUncheckedUpdateWithoutCommissionedWorksInput>
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCartsInput = {
    create?: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartsInput
    connect?: UserWhereUniqueInput
  }

  export type CartItemCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type EnumCartStatusFieldUpdateOperationsInput = {
    set?: $Enums.CartStatus
  }

  export type UserUpdateOneRequiredWithoutCartsNestedInput = {
    create?: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartsInput
    upsert?: UserUpsertWithoutCartsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartsInput, UserUpdateWithoutCartsInput>, UserUncheckedUpdateWithoutCartsInput>
  }

  export type CartItemUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartCreateNestedOneWithoutItemsInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    connect?: CartWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type CartUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    upsert?: CartUpsertWithoutItemsInput
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutItemsInput, CartUpdateWithoutItemsInput>, CartUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutCartItemsNestedInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    upsert?: ProductUpsertWithoutCartItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCartItemsInput, ProductUpdateWithoutCartItemsInput>, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type OrderCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput> | OrderCreateWithoutPromoCodeInput[] | OrderUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPromoCodeInput | OrderCreateOrConnectWithoutPromoCodeInput[]
    createMany?: OrderCreateManyPromoCodeInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput> | OrderCreateWithoutPromoCodeInput[] | OrderUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPromoCodeInput | OrderCreateOrConnectWithoutPromoCodeInput[]
    createMany?: OrderCreateManyPromoCodeInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type EnumPromoCodeStatusFieldUpdateOperationsInput = {
    set?: $Enums.PromoCodeStatus
  }

  export type OrderUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput> | OrderCreateWithoutPromoCodeInput[] | OrderUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPromoCodeInput | OrderCreateOrConnectWithoutPromoCodeInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPromoCodeInput | OrderUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: OrderCreateManyPromoCodeInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPromoCodeInput | OrderUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPromoCodeInput | OrderUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput> | OrderCreateWithoutPromoCodeInput[] | OrderUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPromoCodeInput | OrderCreateOrConnectWithoutPromoCodeInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPromoCodeInput | OrderUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: OrderCreateManyPromoCodeInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPromoCodeInput | OrderUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPromoCodeInput | OrderUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditsInput = {
    create?: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditsNestedInput = {
    create?: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditsInput
    upsert?: UserUpsertWithoutAuditsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditsInput, UserUpdateWithoutAuditsInput>, UserUncheckedUpdateWithoutAuditsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutFinancialLogsInput = {
    create?: XOR<UserCreateWithoutFinancialLogsInput, UserUncheckedCreateWithoutFinancialLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFinancialLogTypeFieldUpdateOperationsInput = {
    set?: $Enums.FinancialLogType
  }

  export type UserUpdateOneRequiredWithoutFinancialLogsNestedInput = {
    create?: XOR<UserCreateWithoutFinancialLogsInput, UserUncheckedCreateWithoutFinancialLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialLogsInput
    upsert?: UserUpsertWithoutFinancialLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFinancialLogsInput, UserUpdateWithoutFinancialLogsInput>, UserUncheckedUpdateWithoutFinancialLogsInput>
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type StockCreateNestedOneWithoutDamageReportsInput = {
    create?: XOR<StockCreateWithoutDamageReportsInput, StockUncheckedCreateWithoutDamageReportsInput>
    connectOrCreate?: StockCreateOrConnectWithoutDamageReportsInput
    connect?: StockWhereUniqueInput
  }

  export type StockUpdateOneRequiredWithoutDamageReportsNestedInput = {
    create?: XOR<StockCreateWithoutDamageReportsInput, StockUncheckedCreateWithoutDamageReportsInput>
    connectOrCreate?: StockCreateOrConnectWithoutDamageReportsInput
    upsert?: StockUpsertWithoutDamageReportsInput
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutDamageReportsInput, StockUpdateWithoutDamageReportsInput>, StockUncheckedUpdateWithoutDamageReportsInput>
  }

  export type CustomerVisitCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerVisitCreateWithoutCustomerInput, CustomerVisitUncheckedCreateWithoutCustomerInput> | CustomerVisitCreateWithoutCustomerInput[] | CustomerVisitUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerVisitCreateOrConnectWithoutCustomerInput | CustomerVisitCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerVisitCreateManyCustomerInputEnvelope
    connect?: CustomerVisitWhereUniqueInput | CustomerVisitWhereUniqueInput[]
  }

  export type CustomerVisitUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerVisitCreateWithoutCustomerInput, CustomerVisitUncheckedCreateWithoutCustomerInput> | CustomerVisitCreateWithoutCustomerInput[] | CustomerVisitUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerVisitCreateOrConnectWithoutCustomerInput | CustomerVisitCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerVisitCreateManyCustomerInputEnvelope
    connect?: CustomerVisitWhereUniqueInput | CustomerVisitWhereUniqueInput[]
  }

  export type CustomerVisitUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerVisitCreateWithoutCustomerInput, CustomerVisitUncheckedCreateWithoutCustomerInput> | CustomerVisitCreateWithoutCustomerInput[] | CustomerVisitUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerVisitCreateOrConnectWithoutCustomerInput | CustomerVisitCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerVisitUpsertWithWhereUniqueWithoutCustomerInput | CustomerVisitUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerVisitCreateManyCustomerInputEnvelope
    set?: CustomerVisitWhereUniqueInput | CustomerVisitWhereUniqueInput[]
    disconnect?: CustomerVisitWhereUniqueInput | CustomerVisitWhereUniqueInput[]
    delete?: CustomerVisitWhereUniqueInput | CustomerVisitWhereUniqueInput[]
    connect?: CustomerVisitWhereUniqueInput | CustomerVisitWhereUniqueInput[]
    update?: CustomerVisitUpdateWithWhereUniqueWithoutCustomerInput | CustomerVisitUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerVisitUpdateManyWithWhereWithoutCustomerInput | CustomerVisitUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerVisitScalarWhereInput | CustomerVisitScalarWhereInput[]
  }

  export type CustomerVisitUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerVisitCreateWithoutCustomerInput, CustomerVisitUncheckedCreateWithoutCustomerInput> | CustomerVisitCreateWithoutCustomerInput[] | CustomerVisitUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerVisitCreateOrConnectWithoutCustomerInput | CustomerVisitCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerVisitUpsertWithWhereUniqueWithoutCustomerInput | CustomerVisitUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerVisitCreateManyCustomerInputEnvelope
    set?: CustomerVisitWhereUniqueInput | CustomerVisitWhereUniqueInput[]
    disconnect?: CustomerVisitWhereUniqueInput | CustomerVisitWhereUniqueInput[]
    delete?: CustomerVisitWhereUniqueInput | CustomerVisitWhereUniqueInput[]
    connect?: CustomerVisitWhereUniqueInput | CustomerVisitWhereUniqueInput[]
    update?: CustomerVisitUpdateWithWhereUniqueWithoutCustomerInput | CustomerVisitUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerVisitUpdateManyWithWhereWithoutCustomerInput | CustomerVisitUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerVisitScalarWhereInput | CustomerVisitScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutVisitsInput = {
    create?: XOR<CustomerCreateWithoutVisitsInput, CustomerUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutVisitsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutVisitsNestedInput = {
    create?: XOR<CustomerCreateWithoutVisitsInput, CustomerUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutVisitsInput
    upsert?: CustomerUpsertWithoutVisitsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutVisitsInput, CustomerUpdateWithoutVisitsInput>, CustomerUncheckedUpdateWithoutVisitsInput>
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumStockStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StockStatus | EnumStockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockStatus[] | ListEnumStockStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockStatus[] | ListEnumStockStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStockStatusFilter<$PrismaModel> | $Enums.StockStatus
  }

  export type NestedEnumStockStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockStatus | EnumStockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockStatus[] | ListEnumStockStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockStatus[] | ListEnumStockStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStockStatusWithAggregatesFilter<$PrismaModel> | $Enums.StockStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockStatusFilter<$PrismaModel>
    _max?: NestedEnumStockStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumFollowUpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowUpStatus | EnumFollowUpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowUpStatusFilter<$PrismaModel> | $Enums.FollowUpStatus
  }

  export type NestedEnumFollowUpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowUpStatus | EnumFollowUpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowUpStatusWithAggregatesFilter<$PrismaModel> | $Enums.FollowUpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFollowUpStatusFilter<$PrismaModel>
    _max?: NestedEnumFollowUpStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedEnumCartStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CartStatus | EnumCartStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CartStatus[] | ListEnumCartStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CartStatus[] | ListEnumCartStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCartStatusFilter<$PrismaModel> | $Enums.CartStatus
  }

  export type NestedEnumCartStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CartStatus | EnumCartStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CartStatus[] | ListEnumCartStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CartStatus[] | ListEnumCartStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCartStatusWithAggregatesFilter<$PrismaModel> | $Enums.CartStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCartStatusFilter<$PrismaModel>
    _max?: NestedEnumCartStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumPromoCodeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoCodeStatus | EnumPromoCodeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PromoCodeStatus[] | ListEnumPromoCodeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromoCodeStatus[] | ListEnumPromoCodeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPromoCodeStatusFilter<$PrismaModel> | $Enums.PromoCodeStatus
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumPromoCodeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoCodeStatus | EnumPromoCodeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PromoCodeStatus[] | ListEnumPromoCodeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromoCodeStatus[] | ListEnumPromoCodeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPromoCodeStatusWithAggregatesFilter<$PrismaModel> | $Enums.PromoCodeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromoCodeStatusFilter<$PrismaModel>
    _max?: NestedEnumPromoCodeStatusFilter<$PrismaModel>
  }

  export type NestedEnumFinancialLogTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialLogType | EnumFinancialLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialLogType[] | ListEnumFinancialLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialLogType[] | ListEnumFinancialLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialLogTypeFilter<$PrismaModel> | $Enums.FinancialLogType
  }

  export type NestedEnumFinancialLogTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialLogType | EnumFinancialLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialLogType[] | ListEnumFinancialLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialLogType[] | ListEnumFinancialLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialLogTypeWithAggregatesFilter<$PrismaModel> | $Enums.FinancialLogType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinancialLogTypeFilter<$PrismaModel>
    _max?: NestedEnumFinancialLogTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    company?: CompanyCreateNestedOneWithoutAdminsInput
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    companyId?: string | null
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type SalesManagerCreateWithoutUserInput = {
    id?: string
  }

  export type SalesManagerUncheckedCreateWithoutUserInput = {
    id?: string
  }

  export type SalesManagerCreateOrConnectWithoutUserInput = {
    where: SalesManagerWhereUniqueInput
    create: XOR<SalesManagerCreateWithoutUserInput, SalesManagerUncheckedCreateWithoutUserInput>
  }

  export type PlumberCreateWithoutUserInput = {
    id?: string
  }

  export type PlumberUncheckedCreateWithoutUserInput = {
    id?: string
  }

  export type PlumberCreateOrConnectWithoutUserInput = {
    where: PlumberWhereUniqueInput
    create: XOR<PlumberCreateWithoutUserInput, PlumberUncheckedCreateWithoutUserInput>
  }

  export type AccountantCreateWithoutUserInput = {
    id?: string
  }

  export type AccountantUncheckedCreateWithoutUserInput = {
    id?: string
  }

  export type AccountantCreateOrConnectWithoutUserInput = {
    where: AccountantWhereUniqueInput
    create: XOR<AccountantCreateWithoutUserInput, AccountantUncheckedCreateWithoutUserInput>
  }

  export type DistributorCreateWithoutUserInput = {
    id?: string
  }

  export type DistributorUncheckedCreateWithoutUserInput = {
    id?: string
  }

  export type DistributorCreateOrConnectWithoutUserInput = {
    where: DistributorWhereUniqueInput
    create: XOR<DistributorCreateWithoutUserInput, DistributorUncheckedCreateWithoutUserInput>
  }

  export type FieldExecutiveCreateWithoutUserInput = {
    id?: string
    followUps?: CustomerFollowUpCreateNestedManyWithoutExecutiveInput
    dvrReports?: DVRCreateNestedManyWithoutExecutiveInput
  }

  export type FieldExecutiveUncheckedCreateWithoutUserInput = {
    id?: string
    followUps?: CustomerFollowUpUncheckedCreateNestedManyWithoutExecutiveInput
    dvrReports?: DVRUncheckedCreateNestedManyWithoutExecutiveInput
  }

  export type FieldExecutiveCreateOrConnectWithoutUserInput = {
    where: FieldExecutiveWhereUniqueInput
    create: XOR<FieldExecutiveCreateWithoutUserInput, FieldExecutiveUncheckedCreateWithoutUserInput>
  }

  export type WorkerCreateWithoutUserInput = {
    id?: string
  }

  export type WorkerUncheckedCreateWithoutUserInput = {
    id?: string
  }

  export type WorkerCreateOrConnectWithoutUserInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutUserInput, WorkerUncheckedCreateWithoutUserInput>
  }

  export type PlumberAccountProfileCreateWithoutUserInput = {
    id?: string
    fullName: string
    contactNumber: string
    upiId?: string | null
    upiQrUrl?: string | null
    email?: string | null
    bankName?: string | null
    accountNumber?: string | null
    accountHolderName?: string | null
    ifscCode?: string | null
    branchName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlumberAccountProfileUncheckedCreateWithoutUserInput = {
    id?: string
    fullName: string
    contactNumber: string
    upiId?: string | null
    upiQrUrl?: string | null
    email?: string | null
    bankName?: string | null
    accountNumber?: string | null
    accountHolderName?: string | null
    ifscCode?: string | null
    branchName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlumberAccountProfileCreateOrConnectWithoutUserInput = {
    where: PlumberAccountProfileWhereUniqueInput
    create: XOR<PlumberAccountProfileCreateWithoutUserInput, PlumberAccountProfileUncheckedCreateWithoutUserInput>
  }

  export type AttendanceCreateWithoutUserInput = {
    id?: string
    date: Date | string
    checkIn: Date | string
    checkOut?: Date | string | null
  }

  export type AttendanceUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    checkIn: Date | string
    checkOut?: Date | string | null
  }

  export type AttendanceCreateOrConnectWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceCreateManyUserInputEnvelope = {
    data: AttendanceCreateManyUserInput | AttendanceCreateManyUserInput[]
  }

  export type PointTransactionCreateWithoutUserInput = {
    id?: string
    points: number
    creditAmount: number
    date: Date | string
    reason: string
    type: $Enums.TransactionType
  }

  export type PointTransactionUncheckedCreateWithoutUserInput = {
    id?: string
    points: number
    creditAmount: number
    date: Date | string
    reason: string
    type: $Enums.TransactionType
  }

  export type PointTransactionCreateOrConnectWithoutUserInput = {
    where: PointTransactionWhereUniqueInput
    create: XOR<PointTransactionCreateWithoutUserInput, PointTransactionUncheckedCreateWithoutUserInput>
  }

  export type PointTransactionCreateManyUserInputEnvelope = {
    data: PointTransactionCreateManyUserInput | PointTransactionCreateManyUserInput[]
  }

  export type IncentiveCreateWithoutAssignedToInput = {
    id?: string
    description: string
    points: number
    assignedAt: Date | string
  }

  export type IncentiveUncheckedCreateWithoutAssignedToInput = {
    id?: string
    description: string
    points: number
    assignedAt: Date | string
  }

  export type IncentiveCreateOrConnectWithoutAssignedToInput = {
    where: IncentiveWhereUniqueInput
    create: XOR<IncentiveCreateWithoutAssignedToInput, IncentiveUncheckedCreateWithoutAssignedToInput>
  }

  export type IncentiveCreateManyAssignedToInputEnvelope = {
    data: IncentiveCreateManyAssignedToInput | IncentiveCreateManyAssignedToInput[]
  }

  export type DeliveryReportCreateWithoutUserInput = {
    id?: string
    product: string
    quantity: number
    isForecasted: boolean
    qrRequested?: boolean
    submittedAt: Date | string
  }

  export type DeliveryReportUncheckedCreateWithoutUserInput = {
    id?: string
    product: string
    quantity: number
    isForecasted: boolean
    qrRequested?: boolean
    submittedAt: Date | string
  }

  export type DeliveryReportCreateOrConnectWithoutUserInput = {
    where: DeliveryReportWhereUniqueInput
    create: XOR<DeliveryReportCreateWithoutUserInput, DeliveryReportUncheckedCreateWithoutUserInput>
  }

  export type DeliveryReportCreateManyUserInputEnvelope = {
    data: DeliveryReportCreateManyUserInput | DeliveryReportCreateManyUserInput[]
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    status: $Enums.OrderStatus
    orderDate: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    status: $Enums.OrderStatus
    orderDate: Date | string
    promoCodeId?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
  }

  export type LiveLocationCreateWithoutUserInput = {
    id?: string
    latitude: number
    longitude: number
    timeStamp: Date | string
  }

  export type LiveLocationUncheckedCreateWithoutUserInput = {
    id?: string
    latitude: number
    longitude: number
    timeStamp: Date | string
  }

  export type LiveLocationCreateOrConnectWithoutUserInput = {
    where: LiveLocationWhereUniqueInput
    create: XOR<LiveLocationCreateWithoutUserInput, LiveLocationUncheckedCreateWithoutUserInput>
  }

  export type LiveLocationCreateManyUserInputEnvelope = {
    data: LiveLocationCreateManyUserInput | LiveLocationCreateManyUserInput[]
  }

  export type ShiftAlertCreateWithoutUserInput = {
    id?: string
    message: string
    createdAt?: Date | string
    acknowledged?: boolean
  }

  export type ShiftAlertUncheckedCreateWithoutUserInput = {
    id?: string
    message: string
    createdAt?: Date | string
    acknowledged?: boolean
  }

  export type ShiftAlertCreateOrConnectWithoutUserInput = {
    where: ShiftAlertWhereUniqueInput
    create: XOR<ShiftAlertCreateWithoutUserInput, ShiftAlertUncheckedCreateWithoutUserInput>
  }

  export type ShiftAlertCreateManyUserInputEnvelope = {
    data: ShiftAlertCreateManyUserInput | ShiftAlertCreateManyUserInput[]
  }

  export type RegisterWarrantyCreateWithoutSellerInput = {
    id?: string
    serialNumber: string
    purchaseDate: Date | string
    warrantyMonths: number
    registeredAt?: Date | string
    qrImage?: string | null
    product: ProductCreateNestedOneWithoutRegisteredWarrantiesInput
  }

  export type RegisterWarrantyUncheckedCreateWithoutSellerInput = {
    id?: string
    productId: string
    serialNumber: string
    purchaseDate: Date | string
    warrantyMonths: number
    registeredAt?: Date | string
    qrImage?: string | null
  }

  export type RegisterWarrantyCreateOrConnectWithoutSellerInput = {
    where: RegisterWarrantyWhereUniqueInput
    create: XOR<RegisterWarrantyCreateWithoutSellerInput, RegisterWarrantyUncheckedCreateWithoutSellerInput>
  }

  export type RegisterWarrantyCreateManySellerInputEnvelope = {
    data: RegisterWarrantyCreateManySellerInput | RegisterWarrantyCreateManySellerInput[]
  }

  export type PostDeliveryReportCreateWithoutUserInput = {
    id?: string
    product: string
    quantity: number
    submittedAt?: Date | string
  }

  export type PostDeliveryReportUncheckedCreateWithoutUserInput = {
    id?: string
    product: string
    quantity: number
    submittedAt?: Date | string
  }

  export type PostDeliveryReportCreateOrConnectWithoutUserInput = {
    where: PostDeliveryReportWhereUniqueInput
    create: XOR<PostDeliveryReportCreateWithoutUserInput, PostDeliveryReportUncheckedCreateWithoutUserInput>
  }

  export type PostDeliveryReportCreateManyUserInputEnvelope = {
    data: PostDeliveryReportCreateManyUserInput | PostDeliveryReportCreateManyUserInput[]
  }

  export type CommissionedWorkCreateWithoutUserInput = {
    id?: string
    latitude: number
    longitude: number
    qrCode: string
    qrImage: Uint8Array
    appliedAt?: Date | string
  }

  export type CommissionedWorkUncheckedCreateWithoutUserInput = {
    id?: string
    latitude: number
    longitude: number
    qrCode: string
    qrImage: Uint8Array
    appliedAt?: Date | string
  }

  export type CommissionedWorkCreateOrConnectWithoutUserInput = {
    where: CommissionedWorkWhereUniqueInput
    create: XOR<CommissionedWorkCreateWithoutUserInput, CommissionedWorkUncheckedCreateWithoutUserInput>
  }

  export type CommissionedWorkCreateManyUserInputEnvelope = {
    data: CommissionedWorkCreateManyUserInput | CommissionedWorkCreateManyUserInput[]
  }

  export type CartCreateWithoutUserInput = {
    id?: string
    status?: $Enums.CartStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.CartStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutUserInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartCreateManyUserInputEnvelope = {
    data: CartCreateManyUserInput | CartCreateManyUserInput[]
  }

  export type AuditCreateWithoutUserInput = {
    id?: string
    action: string
    resource?: string | null
    details?: string | null
    timestamp?: Date | string
  }

  export type AuditUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resource?: string | null
    details?: string | null
    timestamp?: Date | string
  }

  export type AuditCreateOrConnectWithoutUserInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutUserInput, AuditUncheckedCreateWithoutUserInput>
  }

  export type AuditCreateManyUserInputEnvelope = {
    data: AuditCreateManyUserInput | AuditCreateManyUserInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type FinancialLogCreateWithoutCreatedByUserInput = {
    id?: string
    type: $Enums.FinancialLogType
    amount: number
    description: string
    category?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialLogUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    type: $Enums.FinancialLogType
    amount: number
    description: string
    category?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialLogCreateOrConnectWithoutCreatedByUserInput = {
    where: FinancialLogWhereUniqueInput
    create: XOR<FinancialLogCreateWithoutCreatedByUserInput, FinancialLogUncheckedCreateWithoutCreatedByUserInput>
  }

  export type FinancialLogCreateManyCreatedByUserInputEnvelope = {
    data: FinancialLogCreateManyCreatedByUserInput | FinancialLogCreateManyCreatedByUserInput[]
  }

  export type ChatMessageCreateWithoutSenderInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    receiver?: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    receiverId?: string | null
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageCreateManySenderInputEnvelope = {
    data: ChatMessageCreateManySenderInput | ChatMessageCreateManySenderInput[]
  }

  export type ChatMessageCreateWithoutReceiverInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    senderId: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput>
  }

  export type ChatMessageCreateManyReceiverInputEnvelope = {
    data: ChatMessageCreateManyReceiverInput | ChatMessageCreateManyReceiverInput[]
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    company?: CompanyUpdateOneWithoutAdminsNestedInput
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesManagerUpsertWithoutUserInput = {
    update: XOR<SalesManagerUpdateWithoutUserInput, SalesManagerUncheckedUpdateWithoutUserInput>
    create: XOR<SalesManagerCreateWithoutUserInput, SalesManagerUncheckedCreateWithoutUserInput>
    where?: SalesManagerWhereInput
  }

  export type SalesManagerUpdateToOneWithWhereWithoutUserInput = {
    where?: SalesManagerWhereInput
    data: XOR<SalesManagerUpdateWithoutUserInput, SalesManagerUncheckedUpdateWithoutUserInput>
  }

  export type SalesManagerUpdateWithoutUserInput = {

  }

  export type SalesManagerUncheckedUpdateWithoutUserInput = {

  }

  export type PlumberUpsertWithoutUserInput = {
    update: XOR<PlumberUpdateWithoutUserInput, PlumberUncheckedUpdateWithoutUserInput>
    create: XOR<PlumberCreateWithoutUserInput, PlumberUncheckedCreateWithoutUserInput>
    where?: PlumberWhereInput
  }

  export type PlumberUpdateToOneWithWhereWithoutUserInput = {
    where?: PlumberWhereInput
    data: XOR<PlumberUpdateWithoutUserInput, PlumberUncheckedUpdateWithoutUserInput>
  }

  export type PlumberUpdateWithoutUserInput = {

  }

  export type PlumberUncheckedUpdateWithoutUserInput = {

  }

  export type AccountantUpsertWithoutUserInput = {
    update: XOR<AccountantUpdateWithoutUserInput, AccountantUncheckedUpdateWithoutUserInput>
    create: XOR<AccountantCreateWithoutUserInput, AccountantUncheckedCreateWithoutUserInput>
    where?: AccountantWhereInput
  }

  export type AccountantUpdateToOneWithWhereWithoutUserInput = {
    where?: AccountantWhereInput
    data: XOR<AccountantUpdateWithoutUserInput, AccountantUncheckedUpdateWithoutUserInput>
  }

  export type AccountantUpdateWithoutUserInput = {

  }

  export type AccountantUncheckedUpdateWithoutUserInput = {

  }

  export type DistributorUpsertWithoutUserInput = {
    update: XOR<DistributorUpdateWithoutUserInput, DistributorUncheckedUpdateWithoutUserInput>
    create: XOR<DistributorCreateWithoutUserInput, DistributorUncheckedCreateWithoutUserInput>
    where?: DistributorWhereInput
  }

  export type DistributorUpdateToOneWithWhereWithoutUserInput = {
    where?: DistributorWhereInput
    data: XOR<DistributorUpdateWithoutUserInput, DistributorUncheckedUpdateWithoutUserInput>
  }

  export type DistributorUpdateWithoutUserInput = {

  }

  export type DistributorUncheckedUpdateWithoutUserInput = {

  }

  export type FieldExecutiveUpsertWithoutUserInput = {
    update: XOR<FieldExecutiveUpdateWithoutUserInput, FieldExecutiveUncheckedUpdateWithoutUserInput>
    create: XOR<FieldExecutiveCreateWithoutUserInput, FieldExecutiveUncheckedCreateWithoutUserInput>
    where?: FieldExecutiveWhereInput
  }

  export type FieldExecutiveUpdateToOneWithWhereWithoutUserInput = {
    where?: FieldExecutiveWhereInput
    data: XOR<FieldExecutiveUpdateWithoutUserInput, FieldExecutiveUncheckedUpdateWithoutUserInput>
  }

  export type FieldExecutiveUpdateWithoutUserInput = {
    followUps?: CustomerFollowUpUpdateManyWithoutExecutiveNestedInput
    dvrReports?: DVRUpdateManyWithoutExecutiveNestedInput
  }

  export type FieldExecutiveUncheckedUpdateWithoutUserInput = {
    followUps?: CustomerFollowUpUncheckedUpdateManyWithoutExecutiveNestedInput
    dvrReports?: DVRUncheckedUpdateManyWithoutExecutiveNestedInput
  }

  export type WorkerUpsertWithoutUserInput = {
    update: XOR<WorkerUpdateWithoutUserInput, WorkerUncheckedUpdateWithoutUserInput>
    create: XOR<WorkerCreateWithoutUserInput, WorkerUncheckedCreateWithoutUserInput>
    where?: WorkerWhereInput
  }

  export type WorkerUpdateToOneWithWhereWithoutUserInput = {
    where?: WorkerWhereInput
    data: XOR<WorkerUpdateWithoutUserInput, WorkerUncheckedUpdateWithoutUserInput>
  }

  export type WorkerUpdateWithoutUserInput = {

  }

  export type WorkerUncheckedUpdateWithoutUserInput = {

  }

  export type PlumberAccountProfileUpsertWithoutUserInput = {
    update: XOR<PlumberAccountProfileUpdateWithoutUserInput, PlumberAccountProfileUncheckedUpdateWithoutUserInput>
    create: XOR<PlumberAccountProfileCreateWithoutUserInput, PlumberAccountProfileUncheckedCreateWithoutUserInput>
    where?: PlumberAccountProfileWhereInput
  }

  export type PlumberAccountProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: PlumberAccountProfileWhereInput
    data: XOR<PlumberAccountProfileUpdateWithoutUserInput, PlumberAccountProfileUncheckedUpdateWithoutUserInput>
  }

  export type PlumberAccountProfileUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    upiQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlumberAccountProfileUncheckedUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    upiQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    userId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    checkIn?: DateTimeFilter<"Attendance"> | Date | string
    checkOut?: DateTimeNullableFilter<"Attendance"> | Date | string | null
  }

  export type PointTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: PointTransactionWhereUniqueInput
    update: XOR<PointTransactionUpdateWithoutUserInput, PointTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<PointTransactionCreateWithoutUserInput, PointTransactionUncheckedCreateWithoutUserInput>
  }

  export type PointTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: PointTransactionWhereUniqueInput
    data: XOR<PointTransactionUpdateWithoutUserInput, PointTransactionUncheckedUpdateWithoutUserInput>
  }

  export type PointTransactionUpdateManyWithWhereWithoutUserInput = {
    where: PointTransactionScalarWhereInput
    data: XOR<PointTransactionUpdateManyMutationInput, PointTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type PointTransactionScalarWhereInput = {
    AND?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
    OR?: PointTransactionScalarWhereInput[]
    NOT?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
    id?: StringFilter<"PointTransaction"> | string
    userId?: StringFilter<"PointTransaction"> | string
    points?: IntFilter<"PointTransaction"> | number
    creditAmount?: FloatFilter<"PointTransaction"> | number
    date?: DateTimeFilter<"PointTransaction"> | Date | string
    reason?: StringFilter<"PointTransaction"> | string
    type?: EnumTransactionTypeFilter<"PointTransaction"> | $Enums.TransactionType
  }

  export type IncentiveUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: IncentiveWhereUniqueInput
    update: XOR<IncentiveUpdateWithoutAssignedToInput, IncentiveUncheckedUpdateWithoutAssignedToInput>
    create: XOR<IncentiveCreateWithoutAssignedToInput, IncentiveUncheckedCreateWithoutAssignedToInput>
  }

  export type IncentiveUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: IncentiveWhereUniqueInput
    data: XOR<IncentiveUpdateWithoutAssignedToInput, IncentiveUncheckedUpdateWithoutAssignedToInput>
  }

  export type IncentiveUpdateManyWithWhereWithoutAssignedToInput = {
    where: IncentiveScalarWhereInput
    data: XOR<IncentiveUpdateManyMutationInput, IncentiveUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type IncentiveScalarWhereInput = {
    AND?: IncentiveScalarWhereInput | IncentiveScalarWhereInput[]
    OR?: IncentiveScalarWhereInput[]
    NOT?: IncentiveScalarWhereInput | IncentiveScalarWhereInput[]
    id?: StringFilter<"Incentive"> | string
    description?: StringFilter<"Incentive"> | string
    points?: IntFilter<"Incentive"> | number
    assignedId?: StringFilter<"Incentive"> | string
    assignedAt?: DateTimeFilter<"Incentive"> | Date | string
  }

  export type DeliveryReportUpsertWithWhereUniqueWithoutUserInput = {
    where: DeliveryReportWhereUniqueInput
    update: XOR<DeliveryReportUpdateWithoutUserInput, DeliveryReportUncheckedUpdateWithoutUserInput>
    create: XOR<DeliveryReportCreateWithoutUserInput, DeliveryReportUncheckedCreateWithoutUserInput>
  }

  export type DeliveryReportUpdateWithWhereUniqueWithoutUserInput = {
    where: DeliveryReportWhereUniqueInput
    data: XOR<DeliveryReportUpdateWithoutUserInput, DeliveryReportUncheckedUpdateWithoutUserInput>
  }

  export type DeliveryReportUpdateManyWithWhereWithoutUserInput = {
    where: DeliveryReportScalarWhereInput
    data: XOR<DeliveryReportUpdateManyMutationInput, DeliveryReportUncheckedUpdateManyWithoutUserInput>
  }

  export type DeliveryReportScalarWhereInput = {
    AND?: DeliveryReportScalarWhereInput | DeliveryReportScalarWhereInput[]
    OR?: DeliveryReportScalarWhereInput[]
    NOT?: DeliveryReportScalarWhereInput | DeliveryReportScalarWhereInput[]
    id?: StringFilter<"DeliveryReport"> | string
    userId?: StringFilter<"DeliveryReport"> | string
    product?: StringFilter<"DeliveryReport"> | string
    quantity?: IntFilter<"DeliveryReport"> | number
    isForecasted?: BoolFilter<"DeliveryReport"> | boolean
    qrRequested?: BoolFilter<"DeliveryReport"> | boolean
    submittedAt?: DateTimeFilter<"DeliveryReport"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    orderDate?: DateTimeFilter<"Order"> | Date | string
    promoCodeId?: StringNullableFilter<"Order"> | string | null
  }

  export type LiveLocationUpsertWithWhereUniqueWithoutUserInput = {
    where: LiveLocationWhereUniqueInput
    update: XOR<LiveLocationUpdateWithoutUserInput, LiveLocationUncheckedUpdateWithoutUserInput>
    create: XOR<LiveLocationCreateWithoutUserInput, LiveLocationUncheckedCreateWithoutUserInput>
  }

  export type LiveLocationUpdateWithWhereUniqueWithoutUserInput = {
    where: LiveLocationWhereUniqueInput
    data: XOR<LiveLocationUpdateWithoutUserInput, LiveLocationUncheckedUpdateWithoutUserInput>
  }

  export type LiveLocationUpdateManyWithWhereWithoutUserInput = {
    where: LiveLocationScalarWhereInput
    data: XOR<LiveLocationUpdateManyMutationInput, LiveLocationUncheckedUpdateManyWithoutUserInput>
  }

  export type LiveLocationScalarWhereInput = {
    AND?: LiveLocationScalarWhereInput | LiveLocationScalarWhereInput[]
    OR?: LiveLocationScalarWhereInput[]
    NOT?: LiveLocationScalarWhereInput | LiveLocationScalarWhereInput[]
    id?: StringFilter<"LiveLocation"> | string
    userId?: StringFilter<"LiveLocation"> | string
    latitude?: FloatFilter<"LiveLocation"> | number
    longitude?: FloatFilter<"LiveLocation"> | number
    timeStamp?: DateTimeFilter<"LiveLocation"> | Date | string
  }

  export type ShiftAlertUpsertWithWhereUniqueWithoutUserInput = {
    where: ShiftAlertWhereUniqueInput
    update: XOR<ShiftAlertUpdateWithoutUserInput, ShiftAlertUncheckedUpdateWithoutUserInput>
    create: XOR<ShiftAlertCreateWithoutUserInput, ShiftAlertUncheckedCreateWithoutUserInput>
  }

  export type ShiftAlertUpdateWithWhereUniqueWithoutUserInput = {
    where: ShiftAlertWhereUniqueInput
    data: XOR<ShiftAlertUpdateWithoutUserInput, ShiftAlertUncheckedUpdateWithoutUserInput>
  }

  export type ShiftAlertUpdateManyWithWhereWithoutUserInput = {
    where: ShiftAlertScalarWhereInput
    data: XOR<ShiftAlertUpdateManyMutationInput, ShiftAlertUncheckedUpdateManyWithoutUserInput>
  }

  export type ShiftAlertScalarWhereInput = {
    AND?: ShiftAlertScalarWhereInput | ShiftAlertScalarWhereInput[]
    OR?: ShiftAlertScalarWhereInput[]
    NOT?: ShiftAlertScalarWhereInput | ShiftAlertScalarWhereInput[]
    id?: StringFilter<"ShiftAlert"> | string
    userId?: StringFilter<"ShiftAlert"> | string
    message?: StringFilter<"ShiftAlert"> | string
    createdAt?: DateTimeFilter<"ShiftAlert"> | Date | string
    acknowledged?: BoolFilter<"ShiftAlert"> | boolean
  }

  export type RegisterWarrantyUpsertWithWhereUniqueWithoutSellerInput = {
    where: RegisterWarrantyWhereUniqueInput
    update: XOR<RegisterWarrantyUpdateWithoutSellerInput, RegisterWarrantyUncheckedUpdateWithoutSellerInput>
    create: XOR<RegisterWarrantyCreateWithoutSellerInput, RegisterWarrantyUncheckedCreateWithoutSellerInput>
  }

  export type RegisterWarrantyUpdateWithWhereUniqueWithoutSellerInput = {
    where: RegisterWarrantyWhereUniqueInput
    data: XOR<RegisterWarrantyUpdateWithoutSellerInput, RegisterWarrantyUncheckedUpdateWithoutSellerInput>
  }

  export type RegisterWarrantyUpdateManyWithWhereWithoutSellerInput = {
    where: RegisterWarrantyScalarWhereInput
    data: XOR<RegisterWarrantyUpdateManyMutationInput, RegisterWarrantyUncheckedUpdateManyWithoutSellerInput>
  }

  export type RegisterWarrantyScalarWhereInput = {
    AND?: RegisterWarrantyScalarWhereInput | RegisterWarrantyScalarWhereInput[]
    OR?: RegisterWarrantyScalarWhereInput[]
    NOT?: RegisterWarrantyScalarWhereInput | RegisterWarrantyScalarWhereInput[]
    id?: StringFilter<"RegisterWarranty"> | string
    productId?: StringFilter<"RegisterWarranty"> | string
    serialNumber?: StringFilter<"RegisterWarranty"> | string
    purchaseDate?: DateTimeFilter<"RegisterWarranty"> | Date | string
    warrantyMonths?: IntFilter<"RegisterWarranty"> | number
    sellerId?: StringFilter<"RegisterWarranty"> | string
    registeredAt?: DateTimeFilter<"RegisterWarranty"> | Date | string
    qrImage?: StringNullableFilter<"RegisterWarranty"> | string | null
  }

  export type PostDeliveryReportUpsertWithWhereUniqueWithoutUserInput = {
    where: PostDeliveryReportWhereUniqueInput
    update: XOR<PostDeliveryReportUpdateWithoutUserInput, PostDeliveryReportUncheckedUpdateWithoutUserInput>
    create: XOR<PostDeliveryReportCreateWithoutUserInput, PostDeliveryReportUncheckedCreateWithoutUserInput>
  }

  export type PostDeliveryReportUpdateWithWhereUniqueWithoutUserInput = {
    where: PostDeliveryReportWhereUniqueInput
    data: XOR<PostDeliveryReportUpdateWithoutUserInput, PostDeliveryReportUncheckedUpdateWithoutUserInput>
  }

  export type PostDeliveryReportUpdateManyWithWhereWithoutUserInput = {
    where: PostDeliveryReportScalarWhereInput
    data: XOR<PostDeliveryReportUpdateManyMutationInput, PostDeliveryReportUncheckedUpdateManyWithoutUserInput>
  }

  export type PostDeliveryReportScalarWhereInput = {
    AND?: PostDeliveryReportScalarWhereInput | PostDeliveryReportScalarWhereInput[]
    OR?: PostDeliveryReportScalarWhereInput[]
    NOT?: PostDeliveryReportScalarWhereInput | PostDeliveryReportScalarWhereInput[]
    id?: StringFilter<"PostDeliveryReport"> | string
    userId?: StringFilter<"PostDeliveryReport"> | string
    product?: StringFilter<"PostDeliveryReport"> | string
    quantity?: IntFilter<"PostDeliveryReport"> | number
    submittedAt?: DateTimeFilter<"PostDeliveryReport"> | Date | string
  }

  export type CommissionedWorkUpsertWithWhereUniqueWithoutUserInput = {
    where: CommissionedWorkWhereUniqueInput
    update: XOR<CommissionedWorkUpdateWithoutUserInput, CommissionedWorkUncheckedUpdateWithoutUserInput>
    create: XOR<CommissionedWorkCreateWithoutUserInput, CommissionedWorkUncheckedCreateWithoutUserInput>
  }

  export type CommissionedWorkUpdateWithWhereUniqueWithoutUserInput = {
    where: CommissionedWorkWhereUniqueInput
    data: XOR<CommissionedWorkUpdateWithoutUserInput, CommissionedWorkUncheckedUpdateWithoutUserInput>
  }

  export type CommissionedWorkUpdateManyWithWhereWithoutUserInput = {
    where: CommissionedWorkScalarWhereInput
    data: XOR<CommissionedWorkUpdateManyMutationInput, CommissionedWorkUncheckedUpdateManyWithoutUserInput>
  }

  export type CommissionedWorkScalarWhereInput = {
    AND?: CommissionedWorkScalarWhereInput | CommissionedWorkScalarWhereInput[]
    OR?: CommissionedWorkScalarWhereInput[]
    NOT?: CommissionedWorkScalarWhereInput | CommissionedWorkScalarWhereInput[]
    id?: StringFilter<"CommissionedWork"> | string
    userId?: StringFilter<"CommissionedWork"> | string
    latitude?: FloatFilter<"CommissionedWork"> | number
    longitude?: FloatFilter<"CommissionedWork"> | number
    qrCode?: StringFilter<"CommissionedWork"> | string
    qrImage?: BytesFilter<"CommissionedWork"> | Uint8Array
    appliedAt?: DateTimeFilter<"CommissionedWork"> | Date | string
  }

  export type CartUpsertWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    update: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartUpdateWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    data: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
  }

  export type CartUpdateManyWithWhereWithoutUserInput = {
    where: CartScalarWhereInput
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutUserInput>
  }

  export type CartScalarWhereInput = {
    AND?: CartScalarWhereInput | CartScalarWhereInput[]
    OR?: CartScalarWhereInput[]
    NOT?: CartScalarWhereInput | CartScalarWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringFilter<"Cart"> | string
    status?: EnumCartStatusFilter<"Cart"> | $Enums.CartStatus
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
  }

  export type AuditUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditWhereUniqueInput
    update: XOR<AuditUpdateWithoutUserInput, AuditUncheckedUpdateWithoutUserInput>
    create: XOR<AuditCreateWithoutUserInput, AuditUncheckedCreateWithoutUserInput>
  }

  export type AuditUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditWhereUniqueInput
    data: XOR<AuditUpdateWithoutUserInput, AuditUncheckedUpdateWithoutUserInput>
  }

  export type AuditUpdateManyWithWhereWithoutUserInput = {
    where: AuditScalarWhereInput
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditScalarWhereInput = {
    AND?: AuditScalarWhereInput | AuditScalarWhereInput[]
    OR?: AuditScalarWhereInput[]
    NOT?: AuditScalarWhereInput | AuditScalarWhereInput[]
    id?: StringFilter<"Audit"> | string
    userId?: StringFilter<"Audit"> | string
    action?: StringFilter<"Audit"> | string
    resource?: StringNullableFilter<"Audit"> | string | null
    details?: StringNullableFilter<"Audit"> | string | null
    timestamp?: DateTimeFilter<"Audit"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type FinancialLogUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: FinancialLogWhereUniqueInput
    update: XOR<FinancialLogUpdateWithoutCreatedByUserInput, FinancialLogUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<FinancialLogCreateWithoutCreatedByUserInput, FinancialLogUncheckedCreateWithoutCreatedByUserInput>
  }

  export type FinancialLogUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: FinancialLogWhereUniqueInput
    data: XOR<FinancialLogUpdateWithoutCreatedByUserInput, FinancialLogUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type FinancialLogUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: FinancialLogScalarWhereInput
    data: XOR<FinancialLogUpdateManyMutationInput, FinancialLogUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type FinancialLogScalarWhereInput = {
    AND?: FinancialLogScalarWhereInput | FinancialLogScalarWhereInput[]
    OR?: FinancialLogScalarWhereInput[]
    NOT?: FinancialLogScalarWhereInput | FinancialLogScalarWhereInput[]
    id?: StringFilter<"FinancialLog"> | string
    type?: EnumFinancialLogTypeFilter<"FinancialLog"> | $Enums.FinancialLogType
    amount?: FloatFilter<"FinancialLog"> | number
    description?: StringFilter<"FinancialLog"> | string
    category?: StringNullableFilter<"FinancialLog"> | string | null
    reference?: StringNullableFilter<"FinancialLog"> | string | null
    createdBy?: StringFilter<"FinancialLog"> | string
    createdAt?: DateTimeFilter<"FinancialLog"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialLog"> | Date | string
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSenderInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    senderId?: StringFilter<"ChatMessage"> | string
    receiverId?: StringNullableFilter<"ChatMessage"> | string | null
    content?: StringFilter<"ChatMessage"> | string
    isRead?: BoolFilter<"ChatMessage"> | boolean
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutReceiverInput, ChatMessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutReceiverInput, ChatMessageUncheckedUpdateWithoutReceiverInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutReceiverInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type AdminCreateWithoutCompanyInput = {
    id?: string
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
  }

  export type AdminCreateOrConnectWithoutCompanyInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCompanyInput, AdminUncheckedCreateWithoutCompanyInput>
  }

  export type AdminCreateManyCompanyInputEnvelope = {
    data: AdminCreateManyCompanyInput | AdminCreateManyCompanyInput[]
  }

  export type AdminUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutCompanyInput, AdminUncheckedUpdateWithoutCompanyInput>
    create: XOR<AdminCreateWithoutCompanyInput, AdminUncheckedCreateWithoutCompanyInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutCompanyInput, AdminUncheckedUpdateWithoutCompanyInput>
  }

  export type AdminUpdateManyWithWhereWithoutCompanyInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    companyId?: StringNullableFilter<"Admin"> | string | null
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type CompanyCreateWithoutAdminsInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUncheckedCreateWithoutAdminsInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyCreateOrConnectWithoutAdminsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAdminsInput, CompanyUncheckedCreateWithoutAdminsInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type CompanyUpsertWithoutAdminsInput = {
    update: XOR<CompanyUpdateWithoutAdminsInput, CompanyUncheckedUpdateWithoutAdminsInput>
    create: XOR<CompanyCreateWithoutAdminsInput, CompanyUncheckedCreateWithoutAdminsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAdminsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAdminsInput, CompanyUncheckedUpdateWithoutAdminsInput>
  }

  export type CompanyUpdateWithoutAdminsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateWithoutAdminsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSalesManagerInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutSalesManagerInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutSalesManagerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesManagerInput, UserUncheckedCreateWithoutSalesManagerInput>
  }

  export type UserUpsertWithoutSalesManagerInput = {
    update: XOR<UserUpdateWithoutSalesManagerInput, UserUncheckedUpdateWithoutSalesManagerInput>
    create: XOR<UserCreateWithoutSalesManagerInput, UserUncheckedCreateWithoutSalesManagerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalesManagerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalesManagerInput, UserUncheckedUpdateWithoutSalesManagerInput>
  }

  export type UserUpdateWithoutSalesManagerInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesManagerInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateWithoutPlumberInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutPlumberInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutPlumberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlumberInput, UserUncheckedCreateWithoutPlumberInput>
  }

  export type UserUpsertWithoutPlumberInput = {
    update: XOR<UserUpdateWithoutPlumberInput, UserUncheckedUpdateWithoutPlumberInput>
    create: XOR<UserCreateWithoutPlumberInput, UserUncheckedCreateWithoutPlumberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlumberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlumberInput, UserUncheckedUpdateWithoutPlumberInput>
  }

  export type UserUpdateWithoutPlumberInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutPlumberInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateWithoutAccountProfileInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutAccountProfileInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutAccountProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountProfileInput, UserUncheckedCreateWithoutAccountProfileInput>
  }

  export type UserUpsertWithoutAccountProfileInput = {
    update: XOR<UserUpdateWithoutAccountProfileInput, UserUncheckedUpdateWithoutAccountProfileInput>
    create: XOR<UserCreateWithoutAccountProfileInput, UserUncheckedCreateWithoutAccountProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountProfileInput, UserUncheckedUpdateWithoutAccountProfileInput>
  }

  export type UserUpdateWithoutAccountProfileInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountProfileInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateWithoutAccountantInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutAccountantInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutAccountantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountantInput, UserUncheckedCreateWithoutAccountantInput>
  }

  export type UserUpsertWithoutAccountantInput = {
    update: XOR<UserUpdateWithoutAccountantInput, UserUncheckedUpdateWithoutAccountantInput>
    create: XOR<UserCreateWithoutAccountantInput, UserUncheckedCreateWithoutAccountantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountantInput, UserUncheckedUpdateWithoutAccountantInput>
  }

  export type UserUpdateWithoutAccountantInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountantInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateWithoutDistributorInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutDistributorInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutDistributorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDistributorInput, UserUncheckedCreateWithoutDistributorInput>
  }

  export type UserUpsertWithoutDistributorInput = {
    update: XOR<UserUpdateWithoutDistributorInput, UserUncheckedUpdateWithoutDistributorInput>
    create: XOR<UserCreateWithoutDistributorInput, UserUncheckedCreateWithoutDistributorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDistributorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDistributorInput, UserUncheckedUpdateWithoutDistributorInput>
  }

  export type UserUpdateWithoutDistributorInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutDistributorInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateWithoutFieldExecutiveInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutFieldExecutiveInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutFieldExecutiveInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFieldExecutiveInput, UserUncheckedCreateWithoutFieldExecutiveInput>
  }

  export type CustomerFollowUpCreateWithoutExecutiveInput = {
    id?: string
    customerName: string
    contactDetails: string
    feedback: string
    status: $Enums.FollowUpStatus
    nextFollowUpDate: Date | string
  }

  export type CustomerFollowUpUncheckedCreateWithoutExecutiveInput = {
    id?: string
    customerName: string
    contactDetails: string
    feedback: string
    status: $Enums.FollowUpStatus
    nextFollowUpDate: Date | string
  }

  export type CustomerFollowUpCreateOrConnectWithoutExecutiveInput = {
    where: CustomerFollowUpWhereUniqueInput
    create: XOR<CustomerFollowUpCreateWithoutExecutiveInput, CustomerFollowUpUncheckedCreateWithoutExecutiveInput>
  }

  export type CustomerFollowUpCreateManyExecutiveInputEnvelope = {
    data: CustomerFollowUpCreateManyExecutiveInput | CustomerFollowUpCreateManyExecutiveInput[]
  }

  export type DVRCreateWithoutExecutiveInput = {
    id?: string
    feedback: string
    location: string
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
  }

  export type DVRUncheckedCreateWithoutExecutiveInput = {
    id?: string
    feedback: string
    location: string
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
  }

  export type DVRCreateOrConnectWithoutExecutiveInput = {
    where: DVRWhereUniqueInput
    create: XOR<DVRCreateWithoutExecutiveInput, DVRUncheckedCreateWithoutExecutiveInput>
  }

  export type DVRCreateManyExecutiveInputEnvelope = {
    data: DVRCreateManyExecutiveInput | DVRCreateManyExecutiveInput[]
  }

  export type UserUpsertWithoutFieldExecutiveInput = {
    update: XOR<UserUpdateWithoutFieldExecutiveInput, UserUncheckedUpdateWithoutFieldExecutiveInput>
    create: XOR<UserCreateWithoutFieldExecutiveInput, UserUncheckedCreateWithoutFieldExecutiveInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFieldExecutiveInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFieldExecutiveInput, UserUncheckedUpdateWithoutFieldExecutiveInput>
  }

  export type UserUpdateWithoutFieldExecutiveInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutFieldExecutiveInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type CustomerFollowUpUpsertWithWhereUniqueWithoutExecutiveInput = {
    where: CustomerFollowUpWhereUniqueInput
    update: XOR<CustomerFollowUpUpdateWithoutExecutiveInput, CustomerFollowUpUncheckedUpdateWithoutExecutiveInput>
    create: XOR<CustomerFollowUpCreateWithoutExecutiveInput, CustomerFollowUpUncheckedCreateWithoutExecutiveInput>
  }

  export type CustomerFollowUpUpdateWithWhereUniqueWithoutExecutiveInput = {
    where: CustomerFollowUpWhereUniqueInput
    data: XOR<CustomerFollowUpUpdateWithoutExecutiveInput, CustomerFollowUpUncheckedUpdateWithoutExecutiveInput>
  }

  export type CustomerFollowUpUpdateManyWithWhereWithoutExecutiveInput = {
    where: CustomerFollowUpScalarWhereInput
    data: XOR<CustomerFollowUpUpdateManyMutationInput, CustomerFollowUpUncheckedUpdateManyWithoutExecutiveInput>
  }

  export type CustomerFollowUpScalarWhereInput = {
    AND?: CustomerFollowUpScalarWhereInput | CustomerFollowUpScalarWhereInput[]
    OR?: CustomerFollowUpScalarWhereInput[]
    NOT?: CustomerFollowUpScalarWhereInput | CustomerFollowUpScalarWhereInput[]
    id?: StringFilter<"CustomerFollowUp"> | string
    executiveId?: StringFilter<"CustomerFollowUp"> | string
    customerName?: StringFilter<"CustomerFollowUp"> | string
    contactDetails?: StringFilter<"CustomerFollowUp"> | string
    feedback?: StringFilter<"CustomerFollowUp"> | string
    status?: EnumFollowUpStatusFilter<"CustomerFollowUp"> | $Enums.FollowUpStatus
    nextFollowUpDate?: DateTimeFilter<"CustomerFollowUp"> | Date | string
  }

  export type DVRUpsertWithWhereUniqueWithoutExecutiveInput = {
    where: DVRWhereUniqueInput
    update: XOR<DVRUpdateWithoutExecutiveInput, DVRUncheckedUpdateWithoutExecutiveInput>
    create: XOR<DVRCreateWithoutExecutiveInput, DVRUncheckedCreateWithoutExecutiveInput>
  }

  export type DVRUpdateWithWhereUniqueWithoutExecutiveInput = {
    where: DVRWhereUniqueInput
    data: XOR<DVRUpdateWithoutExecutiveInput, DVRUncheckedUpdateWithoutExecutiveInput>
  }

  export type DVRUpdateManyWithWhereWithoutExecutiveInput = {
    where: DVRScalarWhereInput
    data: XOR<DVRUpdateManyMutationInput, DVRUncheckedUpdateManyWithoutExecutiveInput>
  }

  export type DVRScalarWhereInput = {
    AND?: DVRScalarWhereInput | DVRScalarWhereInput[]
    OR?: DVRScalarWhereInput[]
    NOT?: DVRScalarWhereInput | DVRScalarWhereInput[]
    id?: StringFilter<"DVR"> | string
    executiveId?: StringFilter<"DVR"> | string
    feedback?: StringFilter<"DVR"> | string
    location?: StringFilter<"DVR"> | string
    status?: StringFilter<"DVR"> | string
    approvedBy?: StringNullableFilter<"DVR"> | string | null
    approvedAt?: DateTimeNullableFilter<"DVR"> | Date | string | null
  }

  export type UserCreateWithoutWorkerInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutWorkerInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutWorkerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkerInput, UserUncheckedCreateWithoutWorkerInput>
  }

  export type UserUpsertWithoutWorkerInput = {
    update: XOR<UserUpdateWithoutWorkerInput, UserUncheckedUpdateWithoutWorkerInput>
    create: XOR<UserCreateWithoutWorkerInput, UserUncheckedCreateWithoutWorkerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkerInput, UserUncheckedUpdateWithoutWorkerInput>
  }

  export type UserUpdateWithoutWorkerInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkerInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type StockCreateWithoutProductInput = {
    id?: string
    status: $Enums.StockStatus
    location: string
    damageReports?: DamageReportCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateWithoutProductInput = {
    id?: string
    status: $Enums.StockStatus
    location: string
    damageReports?: DamageReportUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutProductInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
  }

  export type StockCreateManyProductInputEnvelope = {
    data: StockCreateManyProductInput | StockCreateManyProductInput[]
  }

  export type WarrantyCardCreateWithoutProductInput = {
    id?: string
    serialNumber: string
    purchaseDate: Date | string
    expiryDate: Date | string
    scanQR: string
    validViaWarranIQ: string
  }

  export type WarrantyCardUncheckedCreateWithoutProductInput = {
    id?: string
    serialNumber: string
    purchaseDate: Date | string
    expiryDate: Date | string
    scanQR: string
    validViaWarranIQ: string
  }

  export type WarrantyCardCreateOrConnectWithoutProductInput = {
    where: WarrantyCardWhereUniqueInput
    create: XOR<WarrantyCardCreateWithoutProductInput, WarrantyCardUncheckedCreateWithoutProductInput>
  }

  export type WarrantyCardCreateManyProductInputEnvelope = {
    data: WarrantyCardCreateManyProductInput | WarrantyCardCreateManyProductInput[]
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice: number
    order: OrderCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    quantity: number
    unitPrice: number
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
  }

  export type RegisterWarrantyCreateWithoutProductInput = {
    id?: string
    serialNumber: string
    purchaseDate: Date | string
    warrantyMonths: number
    registeredAt?: Date | string
    qrImage?: string | null
    seller: UserCreateNestedOneWithoutRegisteredWarrantiesInput
  }

  export type RegisterWarrantyUncheckedCreateWithoutProductInput = {
    id?: string
    serialNumber: string
    purchaseDate: Date | string
    warrantyMonths: number
    sellerId: string
    registeredAt?: Date | string
    qrImage?: string | null
  }

  export type RegisterWarrantyCreateOrConnectWithoutProductInput = {
    where: RegisterWarrantyWhereUniqueInput
    create: XOR<RegisterWarrantyCreateWithoutProductInput, RegisterWarrantyUncheckedCreateWithoutProductInput>
  }

  export type RegisterWarrantyCreateManyProductInputEnvelope = {
    data: RegisterWarrantyCreateManyProductInput | RegisterWarrantyCreateManyProductInput[]
  }

  export type CartItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    addedAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
  }

  export type CartItemUncheckedCreateWithoutProductInput = {
    id?: string
    cartId: string
    quantity: number
    addedAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutProductInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemCreateManyProductInputEnvelope = {
    data: CartItemCreateManyProductInput | CartItemCreateManyProductInput[]
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type StockUpsertWithWhereUniqueWithoutProductInput = {
    where: StockWhereUniqueInput
    update: XOR<StockUpdateWithoutProductInput, StockUncheckedUpdateWithoutProductInput>
    create: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
  }

  export type StockUpdateWithWhereUniqueWithoutProductInput = {
    where: StockWhereUniqueInput
    data: XOR<StockUpdateWithoutProductInput, StockUncheckedUpdateWithoutProductInput>
  }

  export type StockUpdateManyWithWhereWithoutProductInput = {
    where: StockScalarWhereInput
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyWithoutProductInput>
  }

  export type StockScalarWhereInput = {
    AND?: StockScalarWhereInput | StockScalarWhereInput[]
    OR?: StockScalarWhereInput[]
    NOT?: StockScalarWhereInput | StockScalarWhereInput[]
    id?: StringFilter<"Stock"> | string
    productId?: StringFilter<"Stock"> | string
    status?: EnumStockStatusFilter<"Stock"> | $Enums.StockStatus
    location?: StringFilter<"Stock"> | string
  }

  export type WarrantyCardUpsertWithWhereUniqueWithoutProductInput = {
    where: WarrantyCardWhereUniqueInput
    update: XOR<WarrantyCardUpdateWithoutProductInput, WarrantyCardUncheckedUpdateWithoutProductInput>
    create: XOR<WarrantyCardCreateWithoutProductInput, WarrantyCardUncheckedCreateWithoutProductInput>
  }

  export type WarrantyCardUpdateWithWhereUniqueWithoutProductInput = {
    where: WarrantyCardWhereUniqueInput
    data: XOR<WarrantyCardUpdateWithoutProductInput, WarrantyCardUncheckedUpdateWithoutProductInput>
  }

  export type WarrantyCardUpdateManyWithWhereWithoutProductInput = {
    where: WarrantyCardScalarWhereInput
    data: XOR<WarrantyCardUpdateManyMutationInput, WarrantyCardUncheckedUpdateManyWithoutProductInput>
  }

  export type WarrantyCardScalarWhereInput = {
    AND?: WarrantyCardScalarWhereInput | WarrantyCardScalarWhereInput[]
    OR?: WarrantyCardScalarWhereInput[]
    NOT?: WarrantyCardScalarWhereInput | WarrantyCardScalarWhereInput[]
    id?: StringFilter<"WarrantyCard"> | string
    productId?: StringFilter<"WarrantyCard"> | string
    serialNumber?: StringFilter<"WarrantyCard"> | string
    purchaseDate?: DateTimeFilter<"WarrantyCard"> | Date | string
    expiryDate?: DateTimeFilter<"WarrantyCard"> | Date | string
    scanQR?: StringFilter<"WarrantyCard"> | string
    validViaWarranIQ?: StringFilter<"WarrantyCard"> | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
  }

  export type RegisterWarrantyUpsertWithWhereUniqueWithoutProductInput = {
    where: RegisterWarrantyWhereUniqueInput
    update: XOR<RegisterWarrantyUpdateWithoutProductInput, RegisterWarrantyUncheckedUpdateWithoutProductInput>
    create: XOR<RegisterWarrantyCreateWithoutProductInput, RegisterWarrantyUncheckedCreateWithoutProductInput>
  }

  export type RegisterWarrantyUpdateWithWhereUniqueWithoutProductInput = {
    where: RegisterWarrantyWhereUniqueInput
    data: XOR<RegisterWarrantyUpdateWithoutProductInput, RegisterWarrantyUncheckedUpdateWithoutProductInput>
  }

  export type RegisterWarrantyUpdateManyWithWhereWithoutProductInput = {
    where: RegisterWarrantyScalarWhereInput
    data: XOR<RegisterWarrantyUpdateManyMutationInput, RegisterWarrantyUncheckedUpdateManyWithoutProductInput>
  }

  export type CartItemUpsertWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
  }

  export type CartItemUpdateManyWithWhereWithoutProductInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutProductInput>
  }

  export type CartItemScalarWhereInput = {
    AND?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    OR?: CartItemScalarWhereInput[]
    NOT?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    addedAt?: DateTimeFilter<"CartItem"> | Date | string
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutStocksInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    warrantyCards?: WarrantyCardCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutStocksInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    categoryId?: string | null
    warrantyCards?: WarrantyCardUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStocksInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStocksInput, ProductUncheckedCreateWithoutStocksInput>
  }

  export type DamageReportCreateWithoutStockInput = {
    id?: string
    workerId: string
    reason: string
    quantity: number
    location: string
    reportedAt?: Date | string
  }

  export type DamageReportUncheckedCreateWithoutStockInput = {
    id?: string
    workerId: string
    reason: string
    quantity: number
    location: string
    reportedAt?: Date | string
  }

  export type DamageReportCreateOrConnectWithoutStockInput = {
    where: DamageReportWhereUniqueInput
    create: XOR<DamageReportCreateWithoutStockInput, DamageReportUncheckedCreateWithoutStockInput>
  }

  export type DamageReportCreateManyStockInputEnvelope = {
    data: DamageReportCreateManyStockInput | DamageReportCreateManyStockInput[]
  }

  export type ProductUpsertWithoutStocksInput = {
    update: XOR<ProductUpdateWithoutStocksInput, ProductUncheckedUpdateWithoutStocksInput>
    create: XOR<ProductCreateWithoutStocksInput, ProductUncheckedCreateWithoutStocksInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStocksInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStocksInput, ProductUncheckedUpdateWithoutStocksInput>
  }

  export type ProductUpdateWithoutStocksInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    warrantyCards?: WarrantyCardUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutStocksInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyCards?: WarrantyCardUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type DamageReportUpsertWithWhereUniqueWithoutStockInput = {
    where: DamageReportWhereUniqueInput
    update: XOR<DamageReportUpdateWithoutStockInput, DamageReportUncheckedUpdateWithoutStockInput>
    create: XOR<DamageReportCreateWithoutStockInput, DamageReportUncheckedCreateWithoutStockInput>
  }

  export type DamageReportUpdateWithWhereUniqueWithoutStockInput = {
    where: DamageReportWhereUniqueInput
    data: XOR<DamageReportUpdateWithoutStockInput, DamageReportUncheckedUpdateWithoutStockInput>
  }

  export type DamageReportUpdateManyWithWhereWithoutStockInput = {
    where: DamageReportScalarWhereInput
    data: XOR<DamageReportUpdateManyMutationInput, DamageReportUncheckedUpdateManyWithoutStockInput>
  }

  export type DamageReportScalarWhereInput = {
    AND?: DamageReportScalarWhereInput | DamageReportScalarWhereInput[]
    OR?: DamageReportScalarWhereInput[]
    NOT?: DamageReportScalarWhereInput | DamageReportScalarWhereInput[]
    id?: StringFilter<"DamageReport"> | string
    stockId?: StringFilter<"DamageReport"> | string
    workerId?: StringFilter<"DamageReport"> | string
    reason?: StringFilter<"DamageReport"> | string
    quantity?: IntFilter<"DamageReport"> | number
    location?: StringFilter<"DamageReport"> | string
    reportedAt?: DateTimeFilter<"DamageReport"> | Date | string
  }

  export type ProductCreateWithoutWarrantyCardsInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    stocks?: StockCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutWarrantyCardsInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    categoryId?: string | null
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutWarrantyCardsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutWarrantyCardsInput, ProductUncheckedCreateWithoutWarrantyCardsInput>
  }

  export type ProductUpsertWithoutWarrantyCardsInput = {
    update: XOR<ProductUpdateWithoutWarrantyCardsInput, ProductUncheckedUpdateWithoutWarrantyCardsInput>
    create: XOR<ProductCreateWithoutWarrantyCardsInput, ProductUncheckedCreateWithoutWarrantyCardsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutWarrantyCardsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutWarrantyCardsInput, ProductUncheckedUpdateWithoutWarrantyCardsInput>
  }

  export type ProductUpdateWithoutWarrantyCardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    stocks?: StockUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutWarrantyCardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    stocks?: StockUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutAttendancesInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutAttendancesInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutAttendancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
  }

  export type UserUpsertWithoutAttendancesInput = {
    update: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserUpdateWithoutAttendancesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendancesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type FieldExecutiveCreateWithoutFollowUpsInput = {
    id?: string
    user: UserCreateNestedOneWithoutFieldExecutiveInput
    dvrReports?: DVRCreateNestedManyWithoutExecutiveInput
  }

  export type FieldExecutiveUncheckedCreateWithoutFollowUpsInput = {
    id?: string
    userId: string
    dvrReports?: DVRUncheckedCreateNestedManyWithoutExecutiveInput
  }

  export type FieldExecutiveCreateOrConnectWithoutFollowUpsInput = {
    where: FieldExecutiveWhereUniqueInput
    create: XOR<FieldExecutiveCreateWithoutFollowUpsInput, FieldExecutiveUncheckedCreateWithoutFollowUpsInput>
  }

  export type FieldExecutiveUpsertWithoutFollowUpsInput = {
    update: XOR<FieldExecutiveUpdateWithoutFollowUpsInput, FieldExecutiveUncheckedUpdateWithoutFollowUpsInput>
    create: XOR<FieldExecutiveCreateWithoutFollowUpsInput, FieldExecutiveUncheckedCreateWithoutFollowUpsInput>
    where?: FieldExecutiveWhereInput
  }

  export type FieldExecutiveUpdateToOneWithWhereWithoutFollowUpsInput = {
    where?: FieldExecutiveWhereInput
    data: XOR<FieldExecutiveUpdateWithoutFollowUpsInput, FieldExecutiveUncheckedUpdateWithoutFollowUpsInput>
  }

  export type FieldExecutiveUpdateWithoutFollowUpsInput = {
    user?: UserUpdateOneRequiredWithoutFieldExecutiveNestedInput
    dvrReports?: DVRUpdateManyWithoutExecutiveNestedInput
  }

  export type FieldExecutiveUncheckedUpdateWithoutFollowUpsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    dvrReports?: DVRUncheckedUpdateManyWithoutExecutiveNestedInput
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateWithoutIncentivesInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutIncentivesInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutIncentivesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIncentivesInput, UserUncheckedCreateWithoutIncentivesInput>
  }

  export type UserUpsertWithoutIncentivesInput = {
    update: XOR<UserUpdateWithoutIncentivesInput, UserUncheckedUpdateWithoutIncentivesInput>
    create: XOR<UserCreateWithoutIncentivesInput, UserUncheckedCreateWithoutIncentivesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIncentivesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIncentivesInput, UserUncheckedUpdateWithoutIncentivesInput>
  }

  export type UserUpdateWithoutIncentivesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutIncentivesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type FieldExecutiveCreateWithoutDvrReportsInput = {
    id?: string
    user: UserCreateNestedOneWithoutFieldExecutiveInput
    followUps?: CustomerFollowUpCreateNestedManyWithoutExecutiveInput
  }

  export type FieldExecutiveUncheckedCreateWithoutDvrReportsInput = {
    id?: string
    userId: string
    followUps?: CustomerFollowUpUncheckedCreateNestedManyWithoutExecutiveInput
  }

  export type FieldExecutiveCreateOrConnectWithoutDvrReportsInput = {
    where: FieldExecutiveWhereUniqueInput
    create: XOR<FieldExecutiveCreateWithoutDvrReportsInput, FieldExecutiveUncheckedCreateWithoutDvrReportsInput>
  }

  export type FieldExecutiveUpsertWithoutDvrReportsInput = {
    update: XOR<FieldExecutiveUpdateWithoutDvrReportsInput, FieldExecutiveUncheckedUpdateWithoutDvrReportsInput>
    create: XOR<FieldExecutiveCreateWithoutDvrReportsInput, FieldExecutiveUncheckedCreateWithoutDvrReportsInput>
    where?: FieldExecutiveWhereInput
  }

  export type FieldExecutiveUpdateToOneWithWhereWithoutDvrReportsInput = {
    where?: FieldExecutiveWhereInput
    data: XOR<FieldExecutiveUpdateWithoutDvrReportsInput, FieldExecutiveUncheckedUpdateWithoutDvrReportsInput>
  }

  export type FieldExecutiveUpdateWithoutDvrReportsInput = {
    user?: UserUpdateOneRequiredWithoutFieldExecutiveNestedInput
    followUps?: CustomerFollowUpUpdateManyWithoutExecutiveNestedInput
  }

  export type FieldExecutiveUncheckedUpdateWithoutDvrReportsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    followUps?: CustomerFollowUpUncheckedUpdateManyWithoutExecutiveNestedInput
  }

  export type UserCreateWithoutDeliveryReportsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutDeliveryReportsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutDeliveryReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeliveryReportsInput, UserUncheckedCreateWithoutDeliveryReportsInput>
  }

  export type UserUpsertWithoutDeliveryReportsInput = {
    update: XOR<UserUpdateWithoutDeliveryReportsInput, UserUncheckedUpdateWithoutDeliveryReportsInput>
    create: XOR<UserCreateWithoutDeliveryReportsInput, UserUncheckedCreateWithoutDeliveryReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeliveryReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeliveryReportsInput, UserUncheckedUpdateWithoutDeliveryReportsInput>
  }

  export type UserUpdateWithoutDeliveryReportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutDeliveryReportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity: number
    unitPrice: number
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: number
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
  }

  export type InvoiceCreateWithoutOrderInput = {
    id?: string
    invoiceDate: Date | string
    totalAmount: number
    pdfUrl: string
    status?: $Enums.InvoiceStatus
    sentAt?: Date | string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
  }

  export type InvoiceUncheckedCreateWithoutOrderInput = {
    id?: string
    invoiceDate: Date | string
    totalAmount: number
    pdfUrl: string
    status?: $Enums.InvoiceStatus
    sentAt?: Date | string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
  }

  export type InvoiceCreateOrConnectWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type PromoCodeCreateWithoutOrdersInput = {
    id?: string
    code: string
    description: string
    discountType: string
    discountValue: number
    minOrderAmount?: number | null
    maxDiscount?: number | null
    usageLimit?: number | null
    usedCount?: number
    status?: $Enums.PromoCodeStatus
    validFrom: Date | string
    validUntil: Date | string
    createdAt?: Date | string
  }

  export type PromoCodeUncheckedCreateWithoutOrdersInput = {
    id?: string
    code: string
    description: string
    discountType: string
    discountValue: number
    minOrderAmount?: number | null
    maxDiscount?: number | null
    usageLimit?: number | null
    usedCount?: number
    status?: $Enums.PromoCodeStatus
    validFrom: Date | string
    validUntil: Date | string
    createdAt?: Date | string
  }

  export type PromoCodeCreateOrConnectWithoutOrdersInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutOrdersInput, PromoCodeUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type InvoiceUpsertWithoutOrderInput = {
    update: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutOrderInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type InvoiceUpdateWithoutOrderInput = {
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateWithoutOrderInput = {
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type PromoCodeUpsertWithoutOrdersInput = {
    update: XOR<PromoCodeUpdateWithoutOrdersInput, PromoCodeUncheckedUpdateWithoutOrdersInput>
    create: XOR<PromoCodeCreateWithoutOrdersInput, PromoCodeUncheckedCreateWithoutOrdersInput>
    where?: PromoCodeWhereInput
  }

  export type PromoCodeUpdateToOneWithWhereWithoutOrdersInput = {
    where?: PromoCodeWhereInput
    data: XOR<PromoCodeUpdateWithoutOrdersInput, PromoCodeUncheckedUpdateWithoutOrdersInput>
  }

  export type PromoCodeUpdateWithoutOrdersInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    minOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPromoCodeStatusFieldUpdateOperationsInput | $Enums.PromoCodeStatus
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateWithoutOrdersInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    minOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPromoCodeStatusFieldUpdateOperationsInput | $Enums.PromoCodeStatus
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateWithoutOrderItemsInput = {
    id?: string
    status: $Enums.OrderStatus
    orderDate: Date | string
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    user: UserCreateNestedOneWithoutOrdersInput
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    userId: string
    status: $Enums.OrderStatus
    orderDate: Date | string
    promoCodeId?: string | null
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    stocks?: StockCreateNestedManyWithoutProductInput
    warrantyCards?: WarrantyCardCreateNestedManyWithoutProductInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    categoryId?: string | null
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    warrantyCards?: WarrantyCardUncheckedCreateNestedManyWithoutProductInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutOrderItemsInput = {
    update: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderUpdateWithoutOrderItemsInput = {
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderItemsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    stocks?: StockUpdateManyWithoutProductNestedInput
    warrantyCards?: WarrantyCardUpdateManyWithoutProductNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    stocks?: StockUncheckedUpdateManyWithoutProductNestedInput
    warrantyCards?: WarrantyCardUncheckedUpdateManyWithoutProductNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateWithoutInvoiceInput = {
    id?: string
    status: $Enums.OrderStatus
    orderDate: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    user: UserCreateNestedOneWithoutOrdersInput
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutInvoiceInput = {
    id?: string
    userId: string
    status: $Enums.OrderStatus
    orderDate: Date | string
    promoCodeId?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutInvoiceInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
  }

  export type OrderUpsertWithoutInvoiceInput = {
    update: XOR<OrderUpdateWithoutInvoiceInput, OrderUncheckedUpdateWithoutInvoiceInput>
    create: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutInvoiceInput, OrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type OrderUpdateWithoutInvoiceInput = {
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutInvoiceInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserCreateWithoutLiveLocationsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutLiveLocationsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutLiveLocationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLiveLocationsInput, UserUncheckedCreateWithoutLiveLocationsInput>
  }

  export type UserUpsertWithoutLiveLocationsInput = {
    update: XOR<UserUpdateWithoutLiveLocationsInput, UserUncheckedUpdateWithoutLiveLocationsInput>
    create: XOR<UserCreateWithoutLiveLocationsInput, UserUncheckedCreateWithoutLiveLocationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLiveLocationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLiveLocationsInput, UserUncheckedUpdateWithoutLiveLocationsInput>
  }

  export type UserUpdateWithoutLiveLocationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutLiveLocationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateWithoutShiftAlertInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutShiftAlertInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutShiftAlertInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShiftAlertInput, UserUncheckedCreateWithoutShiftAlertInput>
  }

  export type UserUpsertWithoutShiftAlertInput = {
    update: XOR<UserUpdateWithoutShiftAlertInput, UserUncheckedUpdateWithoutShiftAlertInput>
    create: XOR<UserCreateWithoutShiftAlertInput, UserUncheckedCreateWithoutShiftAlertInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShiftAlertInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShiftAlertInput, UserUncheckedUpdateWithoutShiftAlertInput>
  }

  export type UserUpdateWithoutShiftAlertInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutShiftAlertInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type ProductCreateWithoutRegisteredWarrantiesInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    stocks?: StockCreateNestedManyWithoutProductInput
    warrantyCards?: WarrantyCardCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutRegisteredWarrantiesInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    categoryId?: string | null
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    warrantyCards?: WarrantyCardUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRegisteredWarrantiesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRegisteredWarrantiesInput, ProductUncheckedCreateWithoutRegisteredWarrantiesInput>
  }

  export type UserCreateWithoutRegisteredWarrantiesInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutRegisteredWarrantiesInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutRegisteredWarrantiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRegisteredWarrantiesInput, UserUncheckedCreateWithoutRegisteredWarrantiesInput>
  }

  export type ProductUpsertWithoutRegisteredWarrantiesInput = {
    update: XOR<ProductUpdateWithoutRegisteredWarrantiesInput, ProductUncheckedUpdateWithoutRegisteredWarrantiesInput>
    create: XOR<ProductCreateWithoutRegisteredWarrantiesInput, ProductUncheckedCreateWithoutRegisteredWarrantiesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutRegisteredWarrantiesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutRegisteredWarrantiesInput, ProductUncheckedUpdateWithoutRegisteredWarrantiesInput>
  }

  export type ProductUpdateWithoutRegisteredWarrantiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    stocks?: StockUpdateManyWithoutProductNestedInput
    warrantyCards?: WarrantyCardUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutRegisteredWarrantiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    stocks?: StockUncheckedUpdateManyWithoutProductNestedInput
    warrantyCards?: WarrantyCardUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutRegisteredWarrantiesInput = {
    update: XOR<UserUpdateWithoutRegisteredWarrantiesInput, UserUncheckedUpdateWithoutRegisteredWarrantiesInput>
    create: XOR<UserCreateWithoutRegisteredWarrantiesInput, UserUncheckedCreateWithoutRegisteredWarrantiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRegisteredWarrantiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRegisteredWarrantiesInput, UserUncheckedUpdateWithoutRegisteredWarrantiesInput>
  }

  export type UserUpdateWithoutRegisteredWarrantiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutRegisteredWarrantiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateWithoutPostDeliveryReportsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutPostDeliveryReportsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutPostDeliveryReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostDeliveryReportsInput, UserUncheckedCreateWithoutPostDeliveryReportsInput>
  }

  export type UserUpsertWithoutPostDeliveryReportsInput = {
    update: XOR<UserUpdateWithoutPostDeliveryReportsInput, UserUncheckedUpdateWithoutPostDeliveryReportsInput>
    create: XOR<UserCreateWithoutPostDeliveryReportsInput, UserUncheckedCreateWithoutPostDeliveryReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostDeliveryReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostDeliveryReportsInput, UserUncheckedUpdateWithoutPostDeliveryReportsInput>
  }

  export type UserUpdateWithoutPostDeliveryReportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutPostDeliveryReportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateWithoutCommissionedWorksInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutCommissionedWorksInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutCommissionedWorksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommissionedWorksInput, UserUncheckedCreateWithoutCommissionedWorksInput>
  }

  export type UserUpsertWithoutCommissionedWorksInput = {
    update: XOR<UserUpdateWithoutCommissionedWorksInput, UserUncheckedUpdateWithoutCommissionedWorksInput>
    create: XOR<UserCreateWithoutCommissionedWorksInput, UserUncheckedCreateWithoutCommissionedWorksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommissionedWorksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommissionedWorksInput, UserUncheckedUpdateWithoutCommissionedWorksInput>
  }

  export type UserUpdateWithoutCommissionedWorksInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutCommissionedWorksInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    stocks?: StockCreateNestedManyWithoutProductInput
    warrantyCards?: WarrantyCardCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    warrantyCards?: WarrantyCardUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    stockQuantity?: IntFilter<"Product"> | number
    warrantyPeriodInMonths?: IntFilter<"Product"> | number
    categoryId?: StringNullableFilter<"Product"> | string | null
  }

  export type UserCreateWithoutCartsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutCartsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutCartsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
  }

  export type CartItemCreateWithoutCartInput = {
    id?: string
    quantity: number
    addedAt?: Date | string
    product: ProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateWithoutCartInput = {
    id?: string
    productId: string
    quantity: number
    addedAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutCartInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemCreateManyCartInputEnvelope = {
    data: CartItemCreateManyCartInput | CartItemCreateManyCartInput[]
  }

  export type UserUpsertWithoutCartsInput = {
    update: XOR<UserUpdateWithoutCartsInput, UserUncheckedUpdateWithoutCartsInput>
    create: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCartsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCartsInput, UserUncheckedUpdateWithoutCartsInput>
  }

  export type UserUpdateWithoutCartsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutCartsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type CartItemUpsertWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
  }

  export type CartItemUpdateManyWithWhereWithoutCartInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutCartInput>
  }

  export type CartCreateWithoutItemsInput = {
    id?: string
    status?: $Enums.CartStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCartsInput
  }

  export type CartUncheckedCreateWithoutItemsInput = {
    id?: string
    userId: string
    status?: $Enums.CartStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartCreateOrConnectWithoutItemsInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutCartItemsInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    stocks?: StockCreateNestedManyWithoutProductInput
    warrantyCards?: WarrantyCardCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutCartItemsInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
    categoryId?: string | null
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    warrantyCards?: WarrantyCardUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCartItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
  }

  export type CartUpsertWithoutItemsInput = {
    update: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutItemsInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
  }

  export type CartUpdateWithoutItemsInput = {
    status?: EnumCartStatusFieldUpdateOperationsInput | $Enums.CartStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCartsNestedInput
  }

  export type CartUncheckedUpdateWithoutItemsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumCartStatusFieldUpdateOperationsInput | $Enums.CartStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutCartItemsInput = {
    update: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type ProductUpdateWithoutCartItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    stocks?: StockUpdateManyWithoutProductNestedInput
    warrantyCards?: WarrantyCardUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutCartItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    stocks?: StockUncheckedUpdateManyWithoutProductNestedInput
    warrantyCards?: WarrantyCardUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateWithoutPromoCodeInput = {
    id?: string
    status: $Enums.OrderStatus
    orderDate: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    user: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutPromoCodeInput = {
    id?: string
    userId: string
    status: $Enums.OrderStatus
    orderDate: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPromoCodeInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput>
  }

  export type OrderCreateManyPromoCodeInputEnvelope = {
    data: OrderCreateManyPromoCodeInput | OrderCreateManyPromoCodeInput[]
  }

  export type OrderUpsertWithWhereUniqueWithoutPromoCodeInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutPromoCodeInput, OrderUncheckedUpdateWithoutPromoCodeInput>
    create: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutPromoCodeInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutPromoCodeInput, OrderUncheckedUpdateWithoutPromoCodeInput>
  }

  export type OrderUpdateManyWithWhereWithoutPromoCodeInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutPromoCodeInput>
  }

  export type UserCreateWithoutAuditsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutAuditsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutAuditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
  }

  export type UserUpsertWithoutAuditsInput = {
    update: XOR<UserUpdateWithoutAuditsInput, UserUncheckedUpdateWithoutAuditsInput>
    create: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditsInput, UserUncheckedUpdateWithoutAuditsInput>
  }

  export type UserUpdateWithoutAuditsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateWithoutFinancialLogsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutFinancialLogsInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutFinancialLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFinancialLogsInput, UserUncheckedCreateWithoutFinancialLogsInput>
  }

  export type UserUpsertWithoutFinancialLogsInput = {
    update: XOR<UserUpdateWithoutFinancialLogsInput, UserUncheckedUpdateWithoutFinancialLogsInput>
    create: XOR<UserCreateWithoutFinancialLogsInput, UserUncheckedCreateWithoutFinancialLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFinancialLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFinancialLogsInput, UserUncheckedUpdateWithoutFinancialLogsInput>
  }

  export type UserUpdateWithoutFinancialLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutFinancialLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type StockCreateWithoutDamageReportsInput = {
    id?: string
    status: $Enums.StockStatus
    location: string
    product: ProductCreateNestedOneWithoutStocksInput
  }

  export type StockUncheckedCreateWithoutDamageReportsInput = {
    id?: string
    productId: string
    status: $Enums.StockStatus
    location: string
  }

  export type StockCreateOrConnectWithoutDamageReportsInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutDamageReportsInput, StockUncheckedCreateWithoutDamageReportsInput>
  }

  export type StockUpsertWithoutDamageReportsInput = {
    update: XOR<StockUpdateWithoutDamageReportsInput, StockUncheckedUpdateWithoutDamageReportsInput>
    create: XOR<StockCreateWithoutDamageReportsInput, StockUncheckedCreateWithoutDamageReportsInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutDamageReportsInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutDamageReportsInput, StockUncheckedUpdateWithoutDamageReportsInput>
  }

  export type StockUpdateWithoutDamageReportsInput = {
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    location?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutStocksNestedInput
  }

  export type StockUncheckedUpdateWithoutDamageReportsInput = {
    productId?: StringFieldUpdateOperationsInput | string
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    location?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerVisitCreateWithoutCustomerInput = {
    id?: string
    executiveId: string
    visitDate: Date | string
    location: string
    peoplePresent?: string | null
    productsDiscussed?: string | null
    reasonForVisit?: string | null
    customerConcerns?: string | null
    investigationStatus?: string | null
    rootCause?: string | null
    correctiveAction?: string | null
    recommendations?: string | null
    feedback?: string | null
    reportCompletedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerVisitUncheckedCreateWithoutCustomerInput = {
    id?: string
    executiveId: string
    visitDate: Date | string
    location: string
    peoplePresent?: string | null
    productsDiscussed?: string | null
    reasonForVisit?: string | null
    customerConcerns?: string | null
    investigationStatus?: string | null
    rootCause?: string | null
    correctiveAction?: string | null
    recommendations?: string | null
    feedback?: string | null
    reportCompletedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerVisitCreateOrConnectWithoutCustomerInput = {
    where: CustomerVisitWhereUniqueInput
    create: XOR<CustomerVisitCreateWithoutCustomerInput, CustomerVisitUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerVisitCreateManyCustomerInputEnvelope = {
    data: CustomerVisitCreateManyCustomerInput | CustomerVisitCreateManyCustomerInput[]
  }

  export type CustomerVisitUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerVisitWhereUniqueInput
    update: XOR<CustomerVisitUpdateWithoutCustomerInput, CustomerVisitUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerVisitCreateWithoutCustomerInput, CustomerVisitUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerVisitUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerVisitWhereUniqueInput
    data: XOR<CustomerVisitUpdateWithoutCustomerInput, CustomerVisitUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerVisitUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerVisitScalarWhereInput
    data: XOR<CustomerVisitUpdateManyMutationInput, CustomerVisitUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerVisitScalarWhereInput = {
    AND?: CustomerVisitScalarWhereInput | CustomerVisitScalarWhereInput[]
    OR?: CustomerVisitScalarWhereInput[]
    NOT?: CustomerVisitScalarWhereInput | CustomerVisitScalarWhereInput[]
    id?: StringFilter<"CustomerVisit"> | string
    customerId?: StringFilter<"CustomerVisit"> | string
    executiveId?: StringFilter<"CustomerVisit"> | string
    visitDate?: DateTimeFilter<"CustomerVisit"> | Date | string
    location?: StringFilter<"CustomerVisit"> | string
    peoplePresent?: StringNullableFilter<"CustomerVisit"> | string | null
    productsDiscussed?: StringNullableFilter<"CustomerVisit"> | string | null
    reasonForVisit?: StringNullableFilter<"CustomerVisit"> | string | null
    customerConcerns?: StringNullableFilter<"CustomerVisit"> | string | null
    investigationStatus?: StringNullableFilter<"CustomerVisit"> | string | null
    rootCause?: StringNullableFilter<"CustomerVisit"> | string | null
    correctiveAction?: StringNullableFilter<"CustomerVisit"> | string | null
    recommendations?: StringNullableFilter<"CustomerVisit"> | string | null
    feedback?: StringNullableFilter<"CustomerVisit"> | string | null
    reportCompletedBy?: StringFilter<"CustomerVisit"> | string
    createdAt?: DateTimeFilter<"CustomerVisit"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerVisit"> | Date | string
  }

  export type CustomerCreateWithoutVisitsInput = {
    id?: string
    name: string
    email?: string | null
    phone: string
    location: string
    address?: string | null
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUncheckedCreateWithoutVisitsInput = {
    id?: string
    name: string
    email?: string | null
    phone: string
    location: string
    address?: string | null
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateOrConnectWithoutVisitsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutVisitsInput, CustomerUncheckedCreateWithoutVisitsInput>
  }

  export type CustomerUpsertWithoutVisitsInput = {
    update: XOR<CustomerUpdateWithoutVisitsInput, CustomerUncheckedUpdateWithoutVisitsInput>
    create: XOR<CustomerCreateWithoutVisitsInput, CustomerUncheckedCreateWithoutVisitsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutVisitsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutVisitsInput, CustomerUncheckedUpdateWithoutVisitsInput>
  }

  export type CustomerUpdateWithoutVisitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateWithoutVisitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerCreateNestedOneWithoutUserInput
    plumber?: PlumberCreateNestedOneWithoutUserInput
    accountant?: AccountantCreateNestedOneWithoutUserInput
    distributor?: DistributorCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    worker?: WorkerCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileCreateNestedOneWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    transactions?: PointTransactionCreateNestedManyWithoutUserInput
    incentives?: IncentiveCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    audits?: AuditCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    name: string
    email: string
    phone: string
    password: string
    role: $Enums.UserRole
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    salesManager?: SalesManagerUncheckedCreateNestedOneWithoutUserInput
    plumber?: PlumberUncheckedCreateNestedOneWithoutUserInput
    accountant?: AccountantUncheckedCreateNestedOneWithoutUserInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    worker?: WorkerUncheckedCreateNestedOneWithoutUserInput
    accountProfile?: PlumberAccountProfileUncheckedCreateNestedOneWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutAssignedToInput
    deliveryReports?: DeliveryReportUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    liveLocations?: LiveLocationUncheckedCreateNestedManyWithoutUserInput
    ShiftAlert?: ShiftAlertUncheckedCreateNestedManyWithoutUserInput
    registeredWarranties?: RegisterWarrantyUncheckedCreateNestedManyWithoutSellerInput
    postDeliveryReports?: PostDeliveryReportUncheckedCreateNestedManyWithoutUserInput
    commissionedWorks?: CommissionedWorkUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    financialLogs?: FinancialLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUpdateOneWithoutUserNestedInput
    plumber?: PlumberUpdateOneWithoutUserNestedInput
    accountant?: AccountantUpdateOneWithoutUserNestedInput
    distributor?: DistributorUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    worker?: WorkerUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    audits?: AuditUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    salesManager?: SalesManagerUncheckedUpdateOneWithoutUserNestedInput
    plumber?: PlumberUncheckedUpdateOneWithoutUserNestedInput
    accountant?: AccountantUncheckedUpdateOneWithoutUserNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutUserNestedInput
    accountProfile?: PlumberAccountProfileUncheckedUpdateOneWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutAssignedToNestedInput
    deliveryReports?: DeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    liveLocations?: LiveLocationUncheckedUpdateManyWithoutUserNestedInput
    ShiftAlert?: ShiftAlertUncheckedUpdateManyWithoutUserNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutSellerNestedInput
    postDeliveryReports?: PostDeliveryReportUncheckedUpdateManyWithoutUserNestedInput
    commissionedWorks?: CommissionedWorkUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    financialLogs?: FinancialLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type AttendanceCreateManyUserInput = {
    id?: string
    date: Date | string
    checkIn: Date | string
    checkOut?: Date | string | null
  }

  export type PointTransactionCreateManyUserInput = {
    id?: string
    points: number
    creditAmount: number
    date: Date | string
    reason: string
    type: $Enums.TransactionType
  }

  export type IncentiveCreateManyAssignedToInput = {
    id?: string
    description: string
    points: number
    assignedAt: Date | string
  }

  export type DeliveryReportCreateManyUserInput = {
    id?: string
    product: string
    quantity: number
    isForecasted: boolean
    qrRequested?: boolean
    submittedAt: Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    status: $Enums.OrderStatus
    orderDate: Date | string
    promoCodeId?: string | null
  }

  export type LiveLocationCreateManyUserInput = {
    id?: string
    latitude: number
    longitude: number
    timeStamp: Date | string
  }

  export type ShiftAlertCreateManyUserInput = {
    id?: string
    message: string
    createdAt?: Date | string
    acknowledged?: boolean
  }

  export type RegisterWarrantyCreateManySellerInput = {
    id?: string
    productId: string
    serialNumber: string
    purchaseDate: Date | string
    warrantyMonths: number
    registeredAt?: Date | string
    qrImage?: string | null
  }

  export type PostDeliveryReportCreateManyUserInput = {
    id?: string
    product: string
    quantity: number
    submittedAt?: Date | string
  }

  export type CommissionedWorkCreateManyUserInput = {
    id?: string
    latitude: number
    longitude: number
    qrCode: string
    qrImage: Uint8Array
    appliedAt?: Date | string
  }

  export type CartCreateManyUserInput = {
    id?: string
    status?: $Enums.CartStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditCreateManyUserInput = {
    id?: string
    action: string
    resource?: string | null
    details?: string | null
    timestamp?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type FinancialLogCreateManyCreatedByUserInput = {
    id?: string
    type: $Enums.FinancialLogType
    amount: number
    description: string
    category?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageCreateManySenderInput = {
    id?: string
    receiverId?: string | null
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ChatMessageCreateManyReceiverInput = {
    id?: string
    senderId: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type AttendanceUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PointTransactionUpdateWithoutUserInput = {
    points?: IntFieldUpdateOperationsInput | number
    creditAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
  }

  export type PointTransactionUncheckedUpdateWithoutUserInput = {
    points?: IntFieldUpdateOperationsInput | number
    creditAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
  }

  export type PointTransactionUncheckedUpdateManyWithoutUserInput = {
    points?: IntFieldUpdateOperationsInput | number
    creditAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
  }

  export type IncentiveUpdateWithoutAssignedToInput = {
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncentiveUncheckedUpdateWithoutAssignedToInput = {
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncentiveUncheckedUpdateManyWithoutAssignedToInput = {
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryReportUpdateWithoutUserInput = {
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isForecasted?: BoolFieldUpdateOperationsInput | boolean
    qrRequested?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryReportUncheckedUpdateWithoutUserInput = {
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isForecasted?: BoolFieldUpdateOperationsInput | boolean
    qrRequested?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryReportUncheckedUpdateManyWithoutUserInput = {
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isForecasted?: BoolFieldUpdateOperationsInput | boolean
    qrRequested?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LiveLocationUpdateWithoutUserInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveLocationUncheckedUpdateWithoutUserInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveLocationUncheckedUpdateManyWithoutUserInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAlertUpdateWithoutUserInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShiftAlertUncheckedUpdateWithoutUserInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShiftAlertUncheckedUpdateManyWithoutUserInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegisterWarrantyUpdateWithoutSellerInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyMonths?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrImage?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutRegisteredWarrantiesNestedInput
  }

  export type RegisterWarrantyUncheckedUpdateWithoutSellerInput = {
    productId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyMonths?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegisterWarrantyUncheckedUpdateManyWithoutSellerInput = {
    productId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyMonths?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostDeliveryReportUpdateWithoutUserInput = {
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostDeliveryReportUncheckedUpdateWithoutUserInput = {
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostDeliveryReportUncheckedUpdateManyWithoutUserInput = {
    product?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionedWorkUpdateWithoutUserInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    qrCode?: StringFieldUpdateOperationsInput | string
    qrImage?: BytesFieldUpdateOperationsInput | Uint8Array
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionedWorkUncheckedUpdateWithoutUserInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    qrCode?: StringFieldUpdateOperationsInput | string
    qrImage?: BytesFieldUpdateOperationsInput | Uint8Array
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionedWorkUncheckedUpdateManyWithoutUserInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    qrCode?: StringFieldUpdateOperationsInput | string
    qrImage?: BytesFieldUpdateOperationsInput | Uint8Array
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUpdateWithoutUserInput = {
    status?: EnumCartStatusFieldUpdateOperationsInput | $Enums.CartStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutUserInput = {
    status?: EnumCartStatusFieldUpdateOperationsInput | $Enums.CartStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateManyWithoutUserInput = {
    status?: EnumCartStatusFieldUpdateOperationsInput | $Enums.CartStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditUncheckedUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditUncheckedUpdateManyWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialLogUpdateWithoutCreatedByUserInput = {
    type?: EnumFinancialLogTypeFieldUpdateOperationsInput | $Enums.FinancialLogType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialLogUncheckedUpdateWithoutCreatedByUserInput = {
    type?: EnumFinancialLogTypeFieldUpdateOperationsInput | $Enums.FinancialLogType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialLogUncheckedUpdateManyWithoutCreatedByUserInput = {
    type?: EnumFinancialLogTypeFieldUpdateOperationsInput | $Enums.FinancialLogType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUpdateWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneWithoutReceivedMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutSenderInput = {
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderInput = {
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUpdateWithoutReceiverInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutReceiverInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutReceiverInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyCompanyInput = {
    id?: string
    userId: string
  }

  export type AdminUpdateWithoutCompanyInput = {
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutCompanyInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateManyWithoutCompanyInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerFollowUpCreateManyExecutiveInput = {
    id?: string
    customerName: string
    contactDetails: string
    feedback: string
    status: $Enums.FollowUpStatus
    nextFollowUpDate: Date | string
  }

  export type DVRCreateManyExecutiveInput = {
    id?: string
    feedback: string
    location: string
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
  }

  export type CustomerFollowUpUpdateWithoutExecutiveInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    contactDetails?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
    nextFollowUpDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerFollowUpUncheckedUpdateWithoutExecutiveInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    contactDetails?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
    nextFollowUpDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerFollowUpUncheckedUpdateManyWithoutExecutiveInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    contactDetails?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
    nextFollowUpDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DVRUpdateWithoutExecutiveInput = {
    feedback?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DVRUncheckedUpdateWithoutExecutiveInput = {
    feedback?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DVRUncheckedUpdateManyWithoutExecutiveInput = {
    feedback?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockCreateManyProductInput = {
    id?: string
    status: $Enums.StockStatus
    location: string
  }

  export type WarrantyCardCreateManyProductInput = {
    id?: string
    serialNumber: string
    purchaseDate: Date | string
    expiryDate: Date | string
    scanQR: string
    validViaWarranIQ: string
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    orderId: string
    quantity: number
    unitPrice: number
  }

  export type RegisterWarrantyCreateManyProductInput = {
    id?: string
    serialNumber: string
    purchaseDate: Date | string
    warrantyMonths: number
    sellerId: string
    registeredAt?: Date | string
    qrImage?: string | null
  }

  export type CartItemCreateManyProductInput = {
    id?: string
    cartId: string
    quantity: number
    addedAt?: Date | string
  }

  export type StockUpdateWithoutProductInput = {
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    location?: StringFieldUpdateOperationsInput | string
    damageReports?: DamageReportUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutProductInput = {
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    location?: StringFieldUpdateOperationsInput | string
    damageReports?: DamageReportUncheckedUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateManyWithoutProductInput = {
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    location?: StringFieldUpdateOperationsInput | string
  }

  export type WarrantyCardUpdateWithoutProductInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scanQR?: StringFieldUpdateOperationsInput | string
    validViaWarranIQ?: StringFieldUpdateOperationsInput | string
  }

  export type WarrantyCardUncheckedUpdateWithoutProductInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scanQR?: StringFieldUpdateOperationsInput | string
    validViaWarranIQ?: StringFieldUpdateOperationsInput | string
  }

  export type WarrantyCardUncheckedUpdateManyWithoutProductInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scanQR?: StringFieldUpdateOperationsInput | string
    validViaWarranIQ?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type RegisterWarrantyUpdateWithoutProductInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyMonths?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrImage?: NullableStringFieldUpdateOperationsInput | string | null
    seller?: UserUpdateOneRequiredWithoutRegisteredWarrantiesNestedInput
  }

  export type RegisterWarrantyUncheckedUpdateWithoutProductInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyMonths?: IntFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegisterWarrantyUncheckedUpdateManyWithoutProductInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyMonths?: IntFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
  }

  export type CartItemUncheckedUpdateWithoutProductInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutProductInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DamageReportCreateManyStockInput = {
    id?: string
    workerId: string
    reason: string
    quantity: number
    location: string
    reportedAt?: Date | string
  }

  export type DamageReportUpdateWithoutStockInput = {
    workerId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DamageReportUncheckedUpdateWithoutStockInput = {
    workerId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DamageReportUncheckedUpdateManyWithoutStockInput = {
    workerId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: number
  }

  export type OrderItemUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    name: string
    price: number
    stockQuantity: number
    warrantyPeriodInMonths: number
  }

  export type ProductUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    stocks?: StockUpdateManyWithoutProductNestedInput
    warrantyCards?: WarrantyCardUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    registeredWarranties?: RegisterWarrantyUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
    stocks?: StockUncheckedUpdateManyWithoutProductNestedInput
    warrantyCards?: WarrantyCardUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    registeredWarranties?: RegisterWarrantyUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stockQuantity?: IntFieldUpdateOperationsInput | number
    warrantyPeriodInMonths?: IntFieldUpdateOperationsInput | number
  }

  export type CartItemCreateManyCartInput = {
    id?: string
    productId: string
    quantity: number
    addedAt?: Date | string
  }

  export type CartItemUpdateWithoutCartInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateWithoutCartInput = {
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutCartInput = {
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyPromoCodeInput = {
    id?: string
    userId: string
    status: $Enums.OrderStatus
    orderDate: Date | string
  }

  export type OrderUpdateWithoutPromoCodeInput = {
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutPromoCodeInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutPromoCodeInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerVisitCreateManyCustomerInput = {
    id?: string
    executiveId: string
    visitDate: Date | string
    location: string
    peoplePresent?: string | null
    productsDiscussed?: string | null
    reasonForVisit?: string | null
    customerConcerns?: string | null
    investigationStatus?: string | null
    rootCause?: string | null
    correctiveAction?: string | null
    recommendations?: string | null
    feedback?: string | null
    reportCompletedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerVisitUpdateWithoutCustomerInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    peoplePresent?: NullableStringFieldUpdateOperationsInput | string | null
    productsDiscussed?: NullableStringFieldUpdateOperationsInput | string | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    customerConcerns?: NullableStringFieldUpdateOperationsInput | string | null
    investigationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveAction?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompletedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerVisitUncheckedUpdateWithoutCustomerInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    peoplePresent?: NullableStringFieldUpdateOperationsInput | string | null
    productsDiscussed?: NullableStringFieldUpdateOperationsInput | string | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    customerConcerns?: NullableStringFieldUpdateOperationsInput | string | null
    investigationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveAction?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompletedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerVisitUncheckedUpdateManyWithoutCustomerInput = {
    executiveId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    peoplePresent?: NullableStringFieldUpdateOperationsInput | string | null
    productsDiscussed?: NullableStringFieldUpdateOperationsInput | string | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    customerConcerns?: NullableStringFieldUpdateOperationsInput | string | null
    investigationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveAction?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompletedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}